(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{"./manual/Go/Cheat-Sheet.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return c});var a=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),i={},o="wrapper";function c(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(o,Object.assign({},i,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"go-cheat-sheet"},"Go Cheat Sheet"),Object(r.b)("h2",{id:"references"},"References"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/a8m/go-lang-cheat-sheet"}),"Golang Cheat Sheet")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"https://hackernoon.com/time-to-go-learning-golang-through-examples-480a90c5e7f9"}),"Go by example"))),Object(r.b)("h2",{id:"in-a-nutshell"},"In a nutshell"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Imperative language"),Object(r.b)("li",{parentName:"ul"},"Statically typed"),Object(r.b)("li",{parentName:"ul"},"Syntax tokens similar to C (but less parentheses and no semicolons) and the structure to Oberon-2"),Object(r.b)("li",{parentName:"ul"},"Compiles to native code (no JVM)"),Object(r.b)("li",{parentName:"ul"},"No classes, but structs with methods"),Object(r.b)("li",{parentName:"ul"},"Interfaces"),Object(r.b)("li",{parentName:"ul"},"No implementation inheritance. There's type embedding, though."),Object(r.b)("li",{parentName:"ul"},"Functions are first class citizens"),Object(r.b)("li",{parentName:"ul"},"Functions can return multiple values"),Object(r.b)("li",{parentName:"ul"},"Has closures"),Object(r.b)("li",{parentName:"ul"},"Pointers, but not pointer arithmetic"),Object(r.b)("li",{parentName:"ul"},"Built-in concurrency primitives: Goroutines and Channels")),Object(r.b)("h2",{id:"basics"},"Basics"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-go"}),'// hello.go\npackage main\n\nimport "fmt"\n\nfunc main() {\n    fmt.Println("Hello Go")\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"go run hello.go\n")),Object(r.b)("h2",{id:"declarations"},"Declarations"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-go"}),'var foo int // declaration without initialization\nvar foo int = 42 // declaration with initialization\nvar foo, bar int = 42, 1302 // declare and init multiple vars at once\nvar foo = 42 // type omitted, will be inferred\nfoo := 42 // shorthand, only in func bodies, omit var keyword, type is always implicit\nconst constant = "This is a constant"\n')),Object(r.b)("h2",{id:"functions"},"Functions"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-go"}),'// a simple function\nfunc functionName() {}\n\n// function with parameters (again, types go after identifiers)\nfunc functionName(param1 string, param2 int) {}\n\n// multiple parameters of the same type\nfunc functionName(param1, param2 int) {}\n\n// return type declaration\nfunc functionName() int {\n    return 42\n}\n\n// Can return multiple values at once\nfunc returnMulti() (int, string) {\n    return 42, "foobar"\n}\nvar x, str = returnMulti()\n\n// Return multiple named results simply by return\nfunc returnMulti2() (n int, s string) {\n    n = 42\n    s = "foobar"\n    // n and s will be returned\n    return\n}\nvar x, str = returnMulti2()\n')),Object(r.b)("h2",{id:"funcs-as-values-and-closures"},"Funcs as values and closures"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-go"}),"func main() {\n    // assign a function to a name\n    add := func(a, b int) int {\n        return a + b\n    }\n    // use the name to call the function\n    fmt.Println(add(3, 4))\n}\n\n// Closures, lexically scoped: Functions can access values that were\n// in scope when defining the function\nfunc scope() func() int {\n    outer_var := 2\n    foo := func() int { return outer_var}\n    return foo\n}\n\n\n// Closures\nfunc outer() (func() int, int) {\n    outer_var := 2\n    inner := func() int {\n        outer_var += 99 // outer_var from outer scope is mutated.\n        return outer_var\n    }\n    inner()\n    return inner, outer_var // return inner func and mutated outer_var 101\n}\n")))}c&&c===Object(c)&&Object.isExtensible(c)&&Object.defineProperty(c,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Go/Cheat-Sheet.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-go-cheat-sheet.101a1afd2417ec7a4a77.js.map