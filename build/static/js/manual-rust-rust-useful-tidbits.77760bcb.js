(window.webpackJsonp=window.webpackJsonp||[]).push([[441],{"./manual/Rust/Rust-Useful-Tidbits.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return l});var s=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),a=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),r={},i="wrapper";function l(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(a.b)(i,Object.assign({},r,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"useful-tidbits"},"Useful Tidbits"),Object(a.b)("h2",{id:"importing-crates-vs-std-lib"},"Importing crates vs std lib"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),"// for extenal dependencies\nextern crate clap;\nuse clap::App;\n// for standard Rust libraries\nuse std::fs;\n")),Object(a.b)("h2",{id:"reading-yaml"},"Reading YAML"),Object(a.b)("p",null,"Note that this is being done by using the ",Object(a.b)("inlineCode",{parentName:"p"},"clap")," crate that is used for CLI tools - may need to update for appropraite use with ",Object(a.b)("inlineCode",{parentName:"p"},"rust-yaml"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'#[macro_use]\nextern crate clap;\nuse clap::App;\n\nfn main() {\n  let yaml = load_yaml!("cli.yml");\n  println!("{:#?}", yaml);\n}\n')),Object(a.b)("h2",{id:"reading-json"},"Reading JSON"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'#[macro_use]\nextern crate serde_json;\n\nuse std::path::Path;\nuse std::fs::File;\n\nfn main() {\n    let json_file_path = Path::new("src/test.json");\n    let json_file = File::open(json_file_path).expect("file not found");\n    let json: serde_json::Value = serde_json::from_reader(json_file).expect("JSON was not well-formatted");\n    println!("{:#?}", json);\n}\n')),Object(a.b)("p",null,"Output:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),'Object(\n    {\n        "id": String(\n            "1234"\n        ),\n        "object": Object(\n            {\n                "array": Array(\n                    [\n                        Number(\n                            1\n                        ),\n                        Number(\n                            2\n                        ),\n                        Number(\n                            3\n                        )\n                    ]\n                )\n            }\n        )\n    }\n)\n')),Object(a.b)("h2",{id:"logging"},"Logging"),Object(a.b)("p",null,"You want to implement the Debug trait on your struct. Using #","[derive(Debug)]"," is the easiest solution. Then you can print it with {:?}:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'#[derive(Debug)]\nstruct MyStruct{\n    a: i32,\n    b: i32\n}\n\nfn main() {\n    let x = MyStruct{ a: 10, b: 20 };\n    println!("{:?}", x);\n}\n')),Object(a.b)("p",null,"In use:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'// assuming matches is a struct or array\nprintln!("{:?}", matches); // logging out structs or arrays\nprintln!("{:#?}", matches); // pretty print\nprintln!("{}", matches.occurrences_of("verbose"));\n')))}l&&l===Object(l)&&Object.isExtensible(l)&&Object.defineProperty(l,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Rust/Rust-Useful-Tidbits.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-rust-rust-useful-tidbits.101a1afd2417ec7a4a77.js.map