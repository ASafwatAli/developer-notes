{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Go/Go-Methods-And-Pointers.md"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_dennis_okeeffe_Project_Imposter_developer_notes_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"4XAWMA,EAAc,GAGdC,EAAY,UACH,SAASC,EAATC,GAGZ,IAFDC,EAECD,EAFDC,WACGC,EACFC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,gBACD,OAAOG,OAAAE,EAAA,EAAAF,CAACL,EAADK,OAAAG,OAAA,GAAeT,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYM,QAAQ,cAC5EJ,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,wCADR,yCAGAL,OAAAE,EAAA,EAAAF,CAAA,qCACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,oBADZ,6ZAgCLP,OAAAE,EAAA,EAAAF,CAAA,8HACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,oBADZ,+EAMLP,OAAAE,EAAA,EAAAF,CAAA,wHACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,oBADZ,kEAOLP,OAAAE,EAAA,EAAAF,CAAA,8BAAyBA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,cAAzB,sKAAsPN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,cAAtP,OAAoTN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,iBAApT,mDACAN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,qBADR,qBAGAL,OAAAE,EAAA,EAAAF,CAAA,mEACAA,OAAAE,EAAA,EAAAF,CAAA,qCACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,oBADZ,ybA+BLP,OAAAE,EAAA,EAAAF,CAAA,0FACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,oBADZ,+FAMLP,OAAAE,EAAA,EAAAF,CAAA,sHACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,oBADZ,oFAOLP,OAAAE,EAAA,EAAAF,CAAA,0CAAqCA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,WAArC,sBAA+GN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,gBAA/G,KACAN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,wCADR,wCAGAL,OAAAE,EAAA,EAAAF,CAAA,6DACAA,OAAAE,EAAA,EAAAF,CAAA,iCAA4BA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,+DAA5B,KACAN,OAAAE,EAAA,EAAAF,CAAA,0BAAqBA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,kDAArB,gFACAN,OAAAE,EAAA,EAAAF,CAAA,kCAA6BA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,SAA7B,QAAuFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,OAAvF,2BAAkKN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,WAAlK,6DACAN,OAAAE,EAAA,EAAAF,CAAA,kWAIJJ,EAAWY,gBAAiB","file":"static/js/manual-go-go-methods-and-pointers.24a45291.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"go-tour-methods--pointer-indirection\"\n    }}>{`Go Tour Methods & Pointer Indirection`}</h1>\n    <p>{`Take the following code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    v.Scale(2)\n    ScaleFunc(&v, 10)\n\n    p := &Vertex{4, 3}\n    p.Scale(3)\n    ScaleFunc(p, 8)\n\n    fmt.Println(v, p)\n}\n`}</code></pre>\n    <p>{`Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK\n`}</code></pre>\n    <p>{`While methods with pointer receivers take either a value or a pointer as the receiver when they are called:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n`}</code></pre>\n    <p>{`For the statement `}<inlineCode parentName=\"p\">{`v.Scale(5)`}</inlineCode>{`, even though v is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement `}<inlineCode parentName=\"p\">{`v.Scale(5)`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`(&v).Scale(5)`}</inlineCode>{` since the Scale method has a pointer receiver.`}</p>\n    <h2 {...{\n      \"id\": \"reverse-direction\"\n    }}>{`Reverse direction`}</h2>\n    <p>{`The equivalent thing happens in the reverse direction.`}</p>\n    <p>{`Take the following code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(v.Abs())\n    fmt.Println(AbsFunc(v))\n\n    p := &Vertex{4, 3}\n    fmt.Println(p.Abs())\n    fmt.Println(AbsFunc(*p))\n}\n`}</code></pre>\n    <p>{`Functions that take a value argument must take a value of that specific type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!\n`}</code></pre>\n    <p>{`While methods with value receivers take either a value or a pointer as the receiver when they are called:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n`}</code></pre>\n    <p>{`In this case, the method call `}<inlineCode parentName=\"p\">{`p.Abs()`}</inlineCode>{` is interpreted as `}<inlineCode parentName=\"p\">{`(\\\\*p).Abs()`}</inlineCode>{`.`}</p>\n    <h1 {...{\n      \"id\": \"choosing-a-value-or-pointer-receiver\"\n    }}>{`Choosing a value or pointer receiver`}</h1>\n    <p>{`There are two reasons to use a pointer receiver.`}</p>\n    <p>{`The first is so that `}<strong parentName=\"p\">{`the method can modify the value that its receiver points to`}</strong>{`.`}</p>\n    <p>{`The second is `}<strong parentName=\"p\">{`to avoid copying the value on each method call`}</strong>{`. This can be more efficient if the receiver is a large struct, for example.`}</p>\n    <p>{`In this example, both `}<inlineCode parentName=\"p\">{`Scale`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Abs`}</inlineCode>{` are with receiver type `}<inlineCode parentName=\"p\">{`*Vertex`}</inlineCode>{`, even though the Abs method needn't modify its receiver.`}</p>\n    <p>{`In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We'll see why over the next few pages.)`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}