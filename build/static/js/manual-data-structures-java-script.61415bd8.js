(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{"./manual/Data-Structures/JavaScript.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return l});var a=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),s={},i="wrapper";function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(i,Object.assign({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"javascript-data-structures"},"JavaScript Data Structures"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#javascript-data-structures"}),"JavaScript Data Structures"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#string-reversal"}),"String reversal")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#basic-debugger-statements"}),"Basic debugger statements")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#palindromes"}),"Palindromes")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#reverse-integer"}),"Reverse Integer")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#max-chars"}),"Max Chars")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#fizz-buzz"}),"Fizz Buzz")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#array-chunk-problem"}),"Array Chunk Problem")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#anagrams"}),"Anagrams")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#capitalising-a-sentece"}),"Capitalising a sentece")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#stepper"}),"Stepper")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#pyramids"}),"Pyramids")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#vowel-counting"}),"Vowel Counting")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#general-matrix"}),"General Matrix")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#matrix-spiral"}),"Matrix Spiral")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#runtime-complexity"}),"Runtime Complexity"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#determining-complexity"}),"Determining complexity")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#big-o-notation"}),"Big 'O' Notation")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#common-complexities-runtime"}),"Common Complexities (Runtime)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#space-complexity"}),"Space Complexity")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#fibonacci"}),"Fibonacci")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#memoization"}),"Memoization"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#implementing-memoization"}),"Implementing memoization")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#whats-a-data-structure"}),"What's a data structure?")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#queueing"}),"Queueing")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#weave"}),"Weave")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#stacks"}),"Stacks")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#queue-from-stacks"}),"Queue from Stacks")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#linked-list"}),"Linked List")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#basic-notes-on-generators"}),"Basic notes on generators")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#midpoint-of-a-linked-list"}),"Midpoint of a Linked List")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#detecting-linked-list-loops"}),"Detecting Linked List Loops")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#linked-list-distance-n-from-last"}),"Linked List distance n from last")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#trees-overview"}),"Trees Overview")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#level-width"}),"Level width")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#binary-search-trees"}),"Binary Search Trees")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#validating-a-bst"}),"Validating a BST")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#eventing-system"}),"Eventing system")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#sort-algos-and-complexities"}),"Sort Algos and Complexities"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#bubble-sort"}),"Bubble sort")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#selection-sort"}),"Selection Sort")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object.assign({parentName:"li"},{href:"#merge-sort"}),"Merge Sort"))))))),Object(r.b)("h2",{id:"string-reversal"},"String reversal"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const str = 'test';\n\nconst reverseOne = (str) => {\n  let reversed = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed = reversed + str[i];\n  }\n\n  return reversed;\n};\n\nconst reverseTwo = (str) => {\n  return str\n    .split('')\n    .reverse()\n    .join('');\n};\n\nconst reverseThree = (str) => {\n  let reversed = '';\n  for (let char of str) {\n    reversed = char + reversed;\n  }\n\n  return reversed;\n};\n\nconst reverseFour = (str) => {\n  let arr = str.split('').reduce((reversed, char) => {\n    return char + reversed;\n  }, '');\n\n  return reversed;\n};\n")),Object(r.b)("h2",{id:"basic-debugger-statements"},"Basic debugger statements"),Object(r.b)("p",null,"Sometimes that we to pause during execution to do some debugging."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const reverse = (str) => {\n  debugger;\n  let reversed = '';\n  for (let char of str) {\n    reversed = char + reversed;\n  }\n\n  return reversed;\n};\n\nreverse(str);\n")),Object(r.b)("p",null,"From within the terminal, we can then inspect by running:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"node inspect path/to/file.js\ncont # to continue execution (can also use c)\nrepl # kicks you into a js repl\n")),Object(r.b)("h2",{id:"palindromes"},"Palindromes"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const palindrome = (str) => {\n  if (typeof str === String) {\n    return str === reverse(str);\n  } else {\n    return false;\n  }\n};\n\npalindrome('noon'); // true\npalindrome('asdf'); // false\n\nconst palindromeTwo = (str) => {\n  str.split('').every((char, index) => {\n    if (i <= Math.ceil(str.length / 2)) {\n      return char === str[str.length - 1 - index];\n    }\n  });\n};\n")),Object(r.b)("h2",{id:"reverse-integer"},"Reverse Integer"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const reverseInt = (n) => {\n  // Check if negative\n  const isPos = Math.sign(n);\n  // 1. cast to string\n  const str = n.toString();\n  // 2. reverse\n  str\n    .split('')\n    .reverse()\n    .join('');\n  // 3. cast to int\n  const revInt = parseInt(str);\n  return isPos > 0 ? revInt : revInt * -1;\n  // return isPos * Math.sign(n);\n};\n")),Object(r.b)("h2",{id:"max-chars"},"Max Chars"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// 1\n// maxChar('abccccccd'); // 'c'\nconst maxChar = (str) => {\n    let obj = {};\n    for (let char of str) {\n        if (typeof obj[char] !== 'undefined') {\n            obj[char] = obj[char] + 1l\n        } else {\n            obj[char] = 1;\n        }\n    }\n\n    let maxChar = '';\n    let max = 0;\n    for (let key of obj) {\n        if (obj[key] > max) {\n            max = obj[key];\n            maxChar = key;\n        }\n    }\n\n    return maxChar;\n};\n\n// 2\nconst chars = {};\nconst maxCharTwo = str => {\n    for (let char of str) {\n        if (!chars[char]) {\n            chars[char] = 1;\n        } else {\n            chars[char]++;\n        }\n    }\n\n    let maxChar = '';\n    let max = 0;\n\n    for (let key of obj) {\n        if (obj[key] > max) {\n            max = obj[key];\n            maxChar = key;\n        }\n    }\n    return maxChar;\n}\n\n// 3\nconst maxCharThree = str => {\n    for (let char of str) {\n        chars[char] === !chars[char] ? 1 : chars[char]++;\n    }\n}\n")),Object(r.b)("h2",{id:"fizz-buzz"},"Fizz Buzz"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"let fizzBuzz = (i) => {\n  switch (true) {\n    case i % 3 === 0 && i % 5 === 0:\n      return 'fizzbuzz';\n    case i % 3 === 0:\n      return 'fizz';\n    case i % 5 === 0:\n      return 'buzz';\n    default:\n      return i;\n  }\n};\n")),Object(r.b)("h2",{id:"array-chunk-problem"},"Array Chunk Problem"),Object(r.b)("p",null,"One solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"/**\n * Given an 1D array, chunk into 2D based on int\n *\n * @param {*} arr Init array\n * @param {*} i Chunk size\n * @returns {Object} Chunked array object\n */\nlet arrayChunk = (arr, i) => {\n  let tmp = [];\n  let chunkedArr = [];\n  arr.map((d, index) => {\n    tmp.push(d);\n    if (index % i === i - 1) {\n      chunkedArr.push(tmp);\n      tmp = [];\n    }\n  });\n\n  return chunkedArr;\n};\n")),Object(r.b)("p",null,"Second solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"/**\n * Given an 1D array, chunk into 2D based on int\n *\n * @param {*} arr Init array\n * @param {*} i Chunk size\n * @returns {Object} Chunked array object\n */\nlet arrayChunk = (arr, i) => {\n  const chunkedArr = [];\n  for (let el of arr) {\n    const last = chunkedArr[chunkedArr.length - 1];\n\n    if (!last || last.length === size) {\n      chunkedArr.push([el]);\n    } else [\n      last.push([el]);\n    ]\n  }\n  return chunkedArr;\n};\n")),Object(r.b)("p",null,"Third solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"/**\n * Given an 1D array, chunk into 2D based on int\n *\n * @param {*} arr Init array\n * @param {*} i Chunk size\n * @returns {Object} Chunked array object\n */\nlet arrayChunk = (arr, i) => {\n  const chunkedArr = [];\n  let start = 0;\n  let index = 1;\n  while (start < arr.length) {\n    chunkedArr.push(arr.slice(start, index * i));\n\n    start = start + i;\n    index++;\n  }\n  return chunkedArr;\n};\n")),Object(r.b)("p",null,"Fourth solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"/**\n * Given an 1D array, chunk into 2D based on int\n *\n * @param {*} arr Init array\n * @param {*} i Chunk size\n * @returns {Object} Chunked array object\n */\nlet arrayChunk = (arr, i) => {\n  const chunkedArr = [];\n  let start = 0;\n  while (start < arr.length) {\n    chunkedArr.push(arr.slice(start, start + i));\n    start += i;\n  }\n  return chunkedArr;\n};\n")),Object(r.b)("h2",{id:"anagrams"},"Anagrams"),Object(r.b)("p",null,"Solution one:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const anagram = (strA, strB) => {\n  // use regexp to remove spaces and grammar\n  const cmpA = strA.replace(/[^\\w]/g, '').toLowerCase();\n  const cmpB = strB.replace(/[^\\w]/g, '').toLowerCase();\n\n  if (cmpA.length !== cmpB.length) {\n    return false;\n  }\n\n  let charMapA = {};\n  let charMapB = {};\n  for (let i in cmpA) {\n    if (!charMapA[cmpA[i]]) {\n      charMapA[cmpA[i]] = 1;\n    } else {\n      charMapA[cmpA[i]] = charMapA[cmpA[i]]++;\n    }\n\n    if (!charMapB[cmpB[i]]) {\n      charMapB[cmpB[i]] = 1;\n    } else {\n      charMapB[cmpB[i]] = charMapB[cmpB[i]]++;\n    }\n  }\n\n  const keysA = Object.keys(charMapA);\n  const keysB = Object.keys(charMapB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let k in keysA) {\n    if (typeof keysB[k] === 'undefined') {\n      return false;\n    }\n\n    if (keysA[k] !== keysB[k]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n")),Object(r.b)("p",null,"Solution two (basic refactor):"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const anagram = (strA, strB) => {\n  const filterStr = (str) => str.replace(/[^\\w]/g, '').toLowerCase();\n\n  // use regexp to remove spaces and grammar\n  const cmpA = filterStr(str);\n  const cmpB = filterStr(str);\n\n  if (cmpA.length !== cmpB.length) {\n    return false;\n  }\n\n  let charMapA = {};\n  let charMapB = {};\n  const mapHelper = (i, str, map) => {\n    if (!map[str[i]]) {\n      map[str[i]] = 1;\n    } else {\n      map[str[i]] = map[str[i]]++;\n    }\n  };\n\n  for (let i in cmpA) {\n    mapHelper(i, cmpA, charMapA);\n    mapHelper(i, cmpB, charMapB);\n  }\n\n  const keysA = Object.keys(charMapA);\n  const keysB = Object.keys(charMapB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let k in keysA) {\n    if (typeof keysB[k] === 'undefined') {\n      return false;\n    }\n\n    if (keysA[k] !== keysB[k]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n")),Object(r.b)("p",null,"Solution three:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const anagrams = (strA, strB) => {\n  const charMapA = buildCharMap(strA);\n  const charMapB = buildCharMap(strB);\n\n  if (Object.keys(charMapA).length !== Object.keys(charMapB).length) {\n    return false;\n  }\n\n  for (let char in charMapA) {\n    if (aCharMap[char] !== bCharMap[char]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst buildCharMap = (str) => {\n  const charMap = {};\n  for (let char of str.replace(/[^\\w]/g, '').toLowerCase()) {\n    charMap[char] = charMap[char] + 1 || 1;\n  }\n\n  return charMap;\n};\n")),Object(r.b)("p",null,"Solution four:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const anagrams = (strA, strB) => cleanStr(strA) === cleanStr(strB);\n\nconst cleanStr = (str) =>\n  str\n    .replace(/[^\\w]/g, '')\n    .toLowerCase()\n    .split('')\n    .sort()\n    .join('');\n")),Object(r.b)("h2",{id:"capitalising-a-sentece"},"Capitalising a sentece"),Object(r.b)("p",null,"Easy solution for first of sentence:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const capitaliseStr = (str) => str[0].toUpperCase() + str.slice(1);\n")),Object(r.b)("p",null,"If you actually need to capitalise all sentences..."),Object(r.b)("p",null,"First solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const capitaliseStr = (str) => {\n  const arr = str.split(' ');\n\n  return arr\n    .map((str) => {\n      return str[0].toUpperCase() + str.slice(1);\n    })\n    .join(' ');\n};\n")),Object(r.b)("p",null,"Second solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const capitaliseStr = (str) => {\n  let res = str[0].toUpperCase();\n  for (let i = 1; i < str.length; i++) {\n    if (str[i - 1] === ' ') {\n      res = res + str[i].toUpperCase();\n    } else {\n      res = res + str[i];\n    }\n  }\n  return res;\n};\n")),Object(r.b)("h2",{id:"stepper"},"Stepper"),Object(r.b)("p",null,"Without a space:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const step = (stepper) => {\n  let res = '';\n  for (let i = 0; i < stepper; i++) {\n    let count = 0;\n    while (count <= i) {\n      res = res + '#';\n      count++;\n    }\n\n    if (i !== stepper - 1) {\n      res = res + '\\n';\n    }\n  }\n\n  console.log(res);\n  return res;\n};\n\nmodule.exports = {\n  step\n};\n")),Object(r.b)("p",null,"With a space:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const step = (stepper) => {\n  let res = '';\n  for (let i = 0; i < stepper; i++) {\n    let count = 0;\n    while (count <= i) {\n      res = res + '#';\n      count++;\n    }\n\n    while (count <= stepper) {\n      res = res + ' ';\n      count++;\n    }\n\n    if (i !== stepper - 1) {\n      res = res + '\\n';\n    }\n  }\n\n  console.log(res);\n  return res;\n};\n\nmodule.exports = {\n  step\n};\n")),Object(r.b)("p",null,"Using recursion (doesn't return the string):"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const step = (n, row = 0, stair = '') => {\n  // Complete\n  if (n === row) {\n    return;\n  }\n\n  // Handling a row\n  if (n === stair.length) {\n    console.log(stair);\n    return step(n, row + 1);\n  }\n\n  // Handling str on row\n  if (stair.length <= row) {\n    stair += '#';\n  } else {\n    stair += ' ';\n  }\n\n  return step(n, row, stair);\n};\n")),Object(r.b)("h2",{id:"pyramids"},"Pyramids"),Object(r.b)("p",null,"Solution One:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const pyramid = (n) => {\n  const midpoint = Math.floor((2 * n - 1) / 2);\n  let level = '';\n  for (let row = 0; row < n; row++) {\n    for (let column = 0; column < 2 * n - 1; column++) {\n      if (midpoint - row <= column && midpoint + row >= column) {\n        level += '#';\n      } else {\n        level += ' ';\n      }\n\n      if (column === 2 * n - 2) {\n        level += '\\n';\n      }\n    }\n  }\n\n  return level;\n};\n")),Object(r.b)("p",null,"Solution with recursion:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const pyramid = (n, row = 0, level = '') => {\n  // Complete\n  if (n === row) {\n    console.log(level);\n    return;\n  }\n\n  // Handling a row\n  if (2 * n - 1 === level.length) {\n    console.log(level);\n    return pyramid(n, row + 1);\n  }\n\n  const midpoint = Math.floor((2 * n - 1) / 2);\n  let add = '';\n  if (midpoint - row <= level.length && midpoint + row >= level.length) {\n    add += '#';\n  } else {\n    add += ' ';\n  }\n\n  return pyramid(n, row, level + add);\n};\n")),Object(r.b)("h2",{id:"vowel-counting"},"Vowel Counting"),Object(r.b)("p",null,"Solution One:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"let vowels = (str) => {\n  let count = 0;\n  // could also just use vowels = 'aeiou'\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let char of str) {\n    if (vowels.includes(char)) {\n      count++;\n    }\n  }\n\n  return count;\n};\n")),Object(r.b)("p",null,"Solution Two:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"let vowels = (str) => {\n  const matches = str.match(/[aeiou]/gi);\n  return matches ? matches.length : 0;\n};\n")),Object(r.b)("h2",{id:"general-matrix"},"General Matrix"),Object(r.b)("p",null,"Solution One:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"let matrix = (n) => {\n  let mat = [];\n  let count = 1;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (j === 0) {\n        mat[i] = [];\n      }\n\n      mat[i][j] = count;\n      count++;\n    }\n  }\n\n  return mat;\n};\n")),Object(r.b)("h2",{id:"matrix-spiral"},"Matrix Spiral"),Object(r.b)("p",null,"Solution One:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"let matrix = (n) => {\n  let results = [];\n\n  // init all 2d arrays\n  for (let i = 0; i < n; i++) {\n    results.push([]);\n  }\n\n  let count = 1;\n  let startRow = 0;\n  let endRow = n - 1;\n  let startCol = 0;\n  let endCol = n - 1;\n\n  while (startCol <= endCol && endRow >= startRow) {\n    // Top row\n    for (let i = startCol; i <= endCol; i++) {\n      results[startRow][i] = count;\n      count++;\n    }\n    startRow++;\n\n    // Right col\n    for (let i = startRow; i <= endRow; i++) {\n      results[i][endCol] = count;\n      count++;\n    }\n    endCol--;\n\n    // Bottom row\n    for (let i = endCol; i >= startCol; i--) {\n      results[endRow][i] = count;\n      count++;\n    }\n    endRow--;\n\n    // Start col\n    for (let i = endRow; i >= startRow; i--) {\n      results[i][startCol] = count;\n      count++;\n    }\n    startCol++;\n  }\n  console.log('results', results);\n  // find midpoint to start at (base on even/odd) console.log(results);\n  return results;\n};\n")),Object(r.b)("h2",{id:"runtime-complexity"},"Runtime Complexity"),Object(r.b)("p",null,"Linear runtime (N):"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const capitaliseStr = (str) => {\n  let res = str[0].toUpperCase();\n  for (let i = 1; i < str.length; i++) {\n    if (str[i - 1] === ' ') {\n      res = res + str[i].toUpperCase();\n    } else {\n      res = res + str[i];\n    }\n  }\n  return res;\n};\n")),Object(r.b)("p",null,"For an example of quadratic runtime (N^2):"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const step = (n, row = 0, stair = '') => {\n  // Complete\n  if (n === row) {\n    return;\n  }\n\n  // Handling a row\n  if (n === stair.length) {\n    console.log(stair);\n    return step(n, row + 1);\n  }\n\n  // Handling str on row\n  if (stair.length <= row) {\n    stair += '#';\n  } else {\n    stair += ' ';\n  }\n\n  return step(n, row, stair);\n};\n")),Object(r.b)("h3",{id:"determining-complexity"},"Determining complexity"),Object(r.b)("p",null,"How can we determine complexity?"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Time"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Value"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Definition"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Constant"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"1"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"No mantter how many elements we're working with, the algorithm/operation/whatever will always take the same amount of time")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Logarithmic"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"log(n)"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"You have this if doubling the number of elements you are iterating over doesn't double the amount of work. Always assume search algorithms to be log(n)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Linear"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"n"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Iterating through all elements in a colection of data (think arrays)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Quasilinear"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"n * log(n)"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"You have this if doubling the number of elements you are iterating over doesn't double the amount of work. Always assume sort algorithms to be n*log(n)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Quadratic"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"n^2"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Every el in a collection has to be compared to every other elements (handshake problem)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Exponential"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"2^n"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),'If you add a "single" element to a collection, the processing power required doubles')))),Object(r.b)("h3",{id:"big-o-notation"},"Big 'O' Notation"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Complexity"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n)"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Linear")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(1)"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Constant")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n^2)"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Quadratic")))),Object(r.b)("h3",{id:"common-complexities-runtime"},"Common Complexities (Runtime)"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Example"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Likely complexity"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Iterating through simple loop on single collection"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Probably O(n)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Iterating through half a collection?"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Still O(n). There are no constants in runtime.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Iterating through 2 different collections with separate for loops"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n + m)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Two nested for loops iterating over the same collection?"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n^2)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Two nested for loops iterating over different collections?"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n*m)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Sorting"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n*log(n))")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Two nested for loops"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n^2)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Two nested for loops on different collections"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n*m)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Sorting?"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(n*log(n))")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Searching a sorted array?"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"O(log(n))")))),Object(r.b)("h3",{id:"space-complexity"},"Space Complexity"),Object(r.b)("p",null,"Extremely similar to performance but related to memory."),Object(r.b)("h2",{id:"fibonacci"},"Fibonacci"),Object(r.b)("p",null,"First solution:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const fib = n => {\n  const result = [0,1];\n\n  for (let i = 2; i <= n; i++) {\n    const a = result[result.length -1];\n    const b = result[result.length -2];\n\n    result.push(a + b);\n  }\n\n  return result[n];\n}\n")),Object(r.b)("p",null,"Recursive solution one:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const fibonacci = (n, iter = 0, value = 1, prev = 0) => {\n    // 0, 1, 1, 2, 3, 5 ... handle base cases\n    if (n === 0) {\n        return 1;\n    } else if (n === 1) {\n        return 2;\n    }\n\n    if (iter < n - 1) {\n        const newValue = value + prev;\n        return fibonacci(n, iter + 1, newValue, value);\n    }\n\n    return value;\n};\n")),Object(r.b)("p",null,"Recursive solution two:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const fibonacci = n => {\n  if (n < 2) {\n    return n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n")),Object(r.b)("p",null,"To get the complexity of the Fibonacci sequence, we need to think about how all the totals come together for the return calls."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Fibonacci tree",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1550011633/developer-notes/Screen_Shot_2019-02-13_at_9.46.05_am.png"})),Object(r.b)("p",null,"We don't care of fib(0) since it comes back with zero."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Remove fib(0)",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1550011724/developer-notes/Screen_Shot_2019-02-13_at_9.48.20_am.png"})),Object(r.b)("p",null,"Therefore for us, we can total calls of ",Object(r.b)("inlineCode",{parentName:"p"},"fib(1)")," and that is how we see that we get 5 for ",Object(r.b)("inlineCode",{parentName:"p"},"fib(4)"),"."),Object(r.b)("p",null,"The time complexity is O(2^n)."),Object(r.b)("h2",{id:"memoization"},"Memoization"),Object(r.b)("p",null,"Here are some of the performance characteristics of recursion vs quadratic. "),Object(r.b)("p",null,"For the recusive function, if we saw the tree that represents all the calls, you will see quickly that each iteration requires two more calls until we reach ",Object(r.b)("inlineCode",{parentName:"p"},"fib(1)")," and ",Object(r.b)("inlineCode",{parentName:"p"},"fib(0)"),"."),Object(r.b)("p",null,"Given the number of operations increases exponentially, we then know that it becomes ",Object(r.b)("inlineCode",{parentName:"p"},"O(2^n)"),". This is a massive no no."),Object(r.b)("p",null,"With the first iterative solutin, we will get linear runtime. "),Object(r.b)("p",null,"What the interviewer wants to hear for the recursive answer is that we are wasting resources by recalling the same functions over and over (think of how often ",Object(r.b)("inlineCode",{parentName:"p"},"fib(3)")," might be called lower in the recursion tree when running ",Object(r.b)("inlineCode",{parentName:"p"},"fib(6)"),")."),Object(r.b)("p",null,"What they want to here is ",Object(r.b)("inlineCode",{parentName:"p"},"memoization")," - store the arguments of each function call along with the result. If the function is called again with the same arguments, return the precomputed results, rather than running the function again. "),Object(r.b)("p",null,"Using this will dramatically improve runtime."),Object(r.b)("h3",{id:"implementing-memoization"},"Implementing memoization"),Object(r.b)("p",null,"Recursive solution with memoization:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    if (cache[args]) {\n      return cache[args];\n    }\n\n    // NOTE: apply is integral - check MDN if you don't know how it works \n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\n    const result = fn.apply(this, args);\n    cache[args] = result;\n\n    return result;\n  };\n}\n\nconst slowFib = n => {\n  if (n < 2) {\n    return n;\n  }\n\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst fibonacci = memoize(slowFib);\n// fib = memoize(fib); // could also do this if we rename slowFib => fib\n")),Object(r.b)("h2",{id:"whats-a-data-structure"},"What's a data structure?"),Object(r.b)("p",null,"Data structures are all about runtime complexity:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Ways of organizing information with optimal 'runtime complexity' for adding or removing records."),Object(r.b)("li",{parentName:"ul"},"Javascript natively implements several data structures. You will still be asked about 'inferior' data structures.")),Object(r.b)("h2",{id:"queueing"},"Queueing"),Object(r.b)("p",null,"Enqueing: push to back, dequeueing: pop from top."),Object(r.b)("p",null,"Implementing a queue in JS:"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Queue"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Array equivalent"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Add to queue"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"array.unshift();")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"Remove from queue"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"array.pop();")))),Object(r.b)("p",null,"So we could handicap an array. Why would we do that? Just to basically help hide some of the array functionality to lock it down."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"export default class Queue {\n  constructor() {\n    this.data = [];\n  }\n\n  add(record) {\n    this.data.unshift(record);\n  }\n\n  remove() {\n    return this.data.pop();\n  }\n}\n\n// another file \nimport Queue from 'path/to/file';\nconst q = new Queue();\n\nq.add({foo: 'bar'});\nconst nextInQ = q.remove();\n")),Object(r.b)("h2",{id:"weave"},"Weave"),Object(r.b)("p",null,"Weave receives two queues as arguments and combines the contents of each into a new, third queue. The third queue should contain the ",Object(r.b)("inlineCode",{parentName:"p"},"alterating")," content of the two queues. The function should handle queues of different lengths without inserting ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," into the new one."),Object(r.b)("p",null,"Image you have queue one ",Object(r.b)("inlineCode",{parentName:"p"},"[1,2,3]")," and queue two ",Object(r.b)("inlineCode",{parentName:"p"},"'hello', 'world', '!")," then we want to have ",Object(r.b)("inlineCode",{parentName:"p"},"[1, 'hello', 2, 'world', 3, '!']"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// first, update queue\nexport default class Queue {\n  constructor() {\n    this.data = [];\n  }\n\n  add(record) {\n    this.data.unshift(record);\n  }\n\n  remove() {\n    return this.data.pop();\n  }\n\n  peek() {\n    return this.data[this.data.length - 1];\n  }\n}\n\nimport Queue from 'path/to/file';\n// using weave\nfunction weave(srcOne, srcTwo) {\n  const q = new Queue();\n}\n\nmodule.exports = weave;\n")),Object(r.b)("p",null,"Assuming we have that queue class, one implementation is:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const runWeave = (qOne, qTwo) => {\n    const weave = new Queue();\n\n    while (qOne.peek() || qTwo.peek()) {\n        if (qOne.peek()) {\n            weave.add(qOne.remove());\n        }\n\n        if (qTwo.peek()) {\n            weave.add(qTwo.remove());\n        }\n    }\n\n    return weave;\n}\n")),Object(r.b)("h2",{id:"stacks"},"Stacks"),Object(r.b)("p",null,"Stack is like a push pop implementation of records. It is ",Object(r.b)("inlineCode",{parentName:"p"},"First in, Last out"),"."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Stack implemntation",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1550020065/developer-notes/Screen_Shot_2019-02-13_at_12.07.28_pm.png"})),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Stack {\n  constructor() {\n    this.data = [];\n  }\n\n  push(record) {\n    this.data.push(record);\n  }\n\n  pop() {\n    return this.data.pop();\n  }\n\n  peek() {\n    return this.data[this.data.length - 1];\n  }\n}\n")),Object(r.b)("h2",{id:"queue-from-stacks"},"Queue from Stacks"),Object(r.b)("p",null,"Using two stacks, can we emulate a queue?"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const Stack = require('stack');\nconst Queue = require('queue');\n\nconst s1 = new Stack();\nconst s2 = new Stack();\n\nconst q = new Queue();\n\nconst base = ['green', 'blue', 'red'];\n// start with ['green', 'blue', 'red']\n// act as if we were queueing to get green out first\nwhile (base.length > 0) {\n  s1.push(base.unshift());\n}\n\nwhile (s1.peek()) {\n  s2.push(s1.pop());\n}\n\n// now to act as if it is FIFO\ns2.pop(); // gets out green\n")),Object(r.b)("p",null,"Instead of just emulating, if we create a new queue:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Queue {\n  constructor() {\n    this.first = new Stack();\n    this.second = new Stack();\n\n    add(record) {\n      this.first.push(record);\n    }\n\n    remove() {\n      while (this.first.peek()) {\n        this.second.push(this.first.pop());\n      }\n      const record = this.second.pop();\n\n      while (this.second.peek()) {\n        this.first.push(this.second.pop());\n      }\n\n      return record;\n    }\n\n    peek() {\n      while (this.first.peek()) {\n        this.second.push(this.first.pop());\n      }\n\n      const record = this.second.peek();\n\n      while (this.second.peek()) {\n        this.first.push(this.second.pop());\n      }\n\n      return record;\n    }\n  }\n}\n")),Object(r.b)("p",null,"To clarify with the above challenge, it's to go A => StackA => StackB and back treating both the stacks as a queue."),Object(r.b)("h2",{id:"linked-list"},"Linked List"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Basic singularly linked list",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1550023986/developer-notes/Screen_Shot_2019-02-13_at_1.12.51_pm.png"})),Object(r.b)("p",null,"A node generally contains data and a reference to the next node and the linked list is the collections of nodes linked to each other."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const nodeOne = {\n  data: 123\n}\n\nconst nodeTwo = {\n  data: 456\n}\n\nnodeOne.next = nodeTwo;\n")),Object(r.b)("p",null,"We can build a ",Object(r.b)("inlineCode",{parentName:"p"},"Node")," and ",Object(r.b)("inlineCode",{parentName:"p"},"LinkedList")," class to help us out here:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Node {\n    constructor(data, next = null) {\n        this.data = data;\n        this.next = next;\n    }\n}\n\nclass LinkedList {\n    constructor(head = null) {\n        this.head = head;\n    }\n\n    insertFirst(data) {\n        const node = new Node(data, this.head);\n        this.head = node;\n    }\n\n    /**\n     * Return size of LinkedList\n     *\n     * @returns {Number} Size of list\n     * @memberof LinkedList\n     */\n    size() {\n        if (this.head) {\n            // traverse the head\n            let node = this.head;\n            let size = 1;\n            while (node.next) {\n                node = node.next;\n                size++;\n            }\n\n            return size;\n        }\n\n        return 0;\n    }\n\n    getFirst() {\n        return this.head;\n    }\n\n    getLast() {\n        let node = this.head;\n        while (node.next) {\n            node = node.next;\n        }\n\n        return node;\n    }\n\n    /**\n     * Note, we might not have to iterate through all the null values.\n     *\n     * @memberof LinkedList\n     */\n    clear() {\n        if (this.head.next) {\n            let node = this.head.next;\n            while (node.next) {\n                let temp = node.next;\n                node = null;\n                node = temp;\n            }\n        }\n\n        this.head = null;\n    }\n\n    removeFirst() {\n        if (!this.head) {\n            return;\n        }\n\n        this.head = this.head.next;\n    }\n\n    removeLast() {\n        if (!this.head) {\n            return;\n        }\n\n        if (!this.head.next) {\n            this.head = null\n            return;\n        }\n\n        let node = this.head.next;\n        let prev = this.head;\n\n        while (node.next) {\n            prev = node;\n            node = node.next;\n        }\n\n        prev.next = null;\n    }\n\n    insertLast(data) {\n        // this could also be done using this.getLast()\n        const n = new Node(data);\n\n        if (!this.head) {\n            this.head = n;\n            return;\n        }\n\n        if (!this.head.next) {\n            this.head.next = n;\n            return;\n        }\n\n        let node = this.head.next;\n\n        while (node.next) {\n            node = node.next;\n        }\n\n        node.next = n;\n    }\n\n    /**\n     * Get node at a particular index with head equating to 0.\n     *\n     * @param {*} index Index to fetch at.\n     * @memberof LinkedList\n     */\n    getAt(index) {\n        if (!this.head) {\n            return null;\n        }\n\n        let count = 0;\n        let node = this.head;\n        while (count < index) {\n            if (!node.next) {\n                return null;\n            }\n\n            count++;\n            node = node.next;\n        }\n\n        return node;\n    }\n\n    /**\n     * Remove at a particular index.\n     *\n     * @param {*} index index to remove.\n     * @memberof LinkedList\n     */\n    removeAt(index) {\n        if (!this.head) {\n            return;\n        } else if (index === 0 && this.head.next) {\n            let node = this.head.next;\n            this.head = node;\n        }\n\n        let prev = this.head;\n        let node = this.head.next;\n        let counter = 0;\n\n        while (counter < index) {\n            if (!node.next) {\n                return;\n            }\n\n            prev = node;\n            node = node.next;\n        }\n\n        prev.next = node.next;\n    }\n\n    /**\n     * Insert node at a particular index. Ensure it can handle cases where there is a next or no next.\n     * Insert at end if index is out of bounds.\n     *\n     * @param {*} index Index to insert the object at.\n     * @memberof LinkedList\n     */\n    insertAt(data, index) {\n        if (!this.head) {\n            this.head = new Node(data);\n        }\n\n        if (index === 0) {\n            this.head = new Node(data, this.head);\n        }\n\n        let counter = 0;\n        let prev = this.head;\n        let node = this.head.next;\n        while (counter < index) {\n            if (!node.next) {\n                node.next = new Node(data);\n            }\n\n            prev = node;\n            node = node.next;\n        }\n\n        prev.next = new Node(data, node);\n    }\n}\n")),Object(r.b)("h2",{id:"basic-notes-on-generators"},"Basic notes on generators"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"function *numbers() {\n  yield 1;\n  yield 2;\n  yield* moreNumbers(); // I will pass another generator, next should continue to receive yields from this function\n  yield 6;\n  yield 7;\n}\n\nfunction *moreNumbers() {\n  yield 3;\n  yield 4;\n  yield 5;\n}\n\nconst generator = numbers();\n\nconst values = [];\nfor (let value of generator) {\n  values.push(value);\n}\n\nconsole.log(values); // [1,2,3,4,5,6,7]\n")),Object(r.b)("p",null,"A practical example:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Tree {\n  constructor(value = null, children = []) {\n    this.value = value;\n    this.children = children;\n  }\n\n  *printValues() {\n    yield this.value;\n    for (let child of this.children) {\n      yield* child.printValues();\n    }\n  }\n}\n\nconst tree = new Tree(1, [\n  new Tree(2, [new Tree(4)]),\n  new Tree(3)\n]);\n\n// Go in a Depth First Search way to print out the tree\nconst values = [];\nfor (let value of tree.printValues()) {\n  values.push(value);\n}\n\nconsole.log(values); // [1,2,4,3]\n")),Object(r.b)("p",null,"In practise with linked lists:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class LinkedList {\n    constructor(head = null) {\n        this.head = head;\n    }\n\n    // ... other methods\n\n    /**\n     * This will allow us to use a for/of loop with our linked list.\n     *\n     * @memberof LinkedList\n     */ \n    * [Symbol.iterator]() {\n        let node = this.head;\n        while (node) {\n            yield node;\n            node = node.next;\n        }\n    }\n}\n\n// in use assuming we have a LinkedList object list\nfor (let node of list) {\n  console.log(node.data);\n}\n")),Object(r.b)("h2",{id:"midpoint-of-a-linked-list"},"Midpoint of a Linked List"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Get list length / 2 but fetch the roof.")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const midpoint = list => {\n  let slow = list.getFirst();\n  let fast = list.getFirst();\n\n  while (fast.next && fast.next.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n\n  return slow;\n}\n")),Object(r.b)("h2",{id:"detecting-linked-list-loops"},"Detecting Linked List Loops"),Object(r.b)("p",null,"How can you detect if a linked list has a circular reference?"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const circular = list => {\n  let slow = list.getFirst();\n  let fast = list.getFirst();\n\n  while (fast.next && fast.next.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n\n    if (slow === fast) {\n      return true;\n    }\n  }\n\n  return false;\n}\n")),Object(r.b)("h2",{id:"linked-list-distance-n-from-last"},"Linked List distance n from last"),Object(r.b)("p",null,"Given linked list and int n, return el ",Object(r.b)("inlineCode",{parentName:"p"},"n")," spaces from the last node in the list. Do not call the size method. Always assume that nwill be less than the length of the list."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const fromLast = (list, n) => {\n  let slow = list.getFirst();\n  let fast = list.getFirst();\n\n  while (n > 0) {\n    fast = fast.next;\n    n--;\n  }\n\n  while (fast.next && fast.next) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n}\n")),Object(r.b)("h2",{id:"trees-overview"},"Trees Overview"),Object(r.b)("p",null,"Two basics ways we will go through the trees. Depth First Search and Breadth First Search."),Object(r.b)("p",null,"A node class should have a data property, add method and remove method."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Node {\n  constructor(data) {\n    this.data = data;\n    this.children = [];\n  }\n\n  /**\n   * Given some data, create a new node and add it to the current node's 'children' array\n   */\n  add(data) {\n    this.children.push(new Node(data));\n  }\n\n  /**\n   * Given some data, look at each child of the current node and remove any node with data === data\n   */\n  remove(data) {\n    this.children = this.children.filter(node => node.data !== data);\n  }\n}\n")),Object(r.b)("p",null,"For the tree class, we want a constructor with root set to null."),Object(r.b)("p",null,"We then want a ",Object(r.b)("inlineCode",{parentName:"p"},"traverseBFS")," and ",Object(r.b)("inlineCode",{parentName:"p"},"traverseDFS")," method."),Object(r.b)("p",null,"Note: Practical reasoning for BFS vs DFS. "),Object(r.b)("p",null,"BFS example includes a tree of the position hierarchy of a company and wanting to print a tree of positions given importance. "),Object(r.b)("p",null,"DFS example."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Tree {\n  constructor() {\n    this.root = null;\n  }\n  \n  /**\n   * (node) => // do something with node\n   */\n  traverseBFS(fn) {\n    // start at root\n    // check if children\n    // if children, iterate through and recall function \n    const arr = [this.root];\n    while (arr.length) {\n      const node = arr.shift();\n      arr.push(...node.children);\n      fn(node);\n    }\n  }\n\n  traverseDFS(fn) {\n    // start with root\n    // check if children\n    // if children, iterate through in depth fashion\n    const arr = [this.root];\n    while (arr.length) {\n      const node = arr.shift();\n      arr.unshift(...node.children);\n      fn(node);\n    }\n  }\n}\n")),Object(r.b)("h2",{id:"level-width"},"Level width"),Object(r.b)("p",null,"Given the root node of a tree, return an array where each element is the width of the tree at each level."),Object(r.b)("p",null,'What we need to do is use a "stopper" variable to help us define when we hit the end of level.'),Object(r.b)("p",null,Object(r.b)("img",{alt:"Approach to level width",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1550103801/developer-notes/Screen_Shot_2019-02-14_at_11.22.10_am.png"})),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// given a node \nlet node = new Node(); // assume initiated with a bunch of children\n\nconst levelWidth = node => {\n  const counters = [0];\n  const arr = [node, 's'];\n  while (arr.length > 1) {\n    const node = arr.shift();\n    if (node === 's') {\n      arr.push('s');\n      counters.push(0);\n    } else if (arr.length) {\n      counters[counters.length - 1]++;\n      arr.push(...node.children);\n    }\n  } \n\n  return counters;\n}\n\nlevelWidth(node.root);\n")),Object(r.b)("h2",{id:"binary-search-trees"},"Binary Search Trees"),Object(r.b)("p",null,"Binary trees can only have at most 2 children."),Object(r.b)("p",null,"Because of the restrictions of ",Object(r.b)("inlineCode",{parentName:"p"},"binary search trees"),", we generally set them up so that the node has properties ",Object(r.b)("inlineCode",{parentName:"p"},"left")," and ",Object(r.b)("inlineCode",{parentName:"p"},"right")," with a ",Object(r.b)("inlineCode",{parentName:"p"},"value")," property that is greater than ",Object(r.b)("inlineCode",{parentName:"p"},"left.value")," but smaller than ",Object(r.b)("inlineCode",{parentName:"p"},"right.value"),"."),Object(r.b)("p",null,"Creating a BST:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(data) {\n    if (data < this.data && this.left) {\n      this.left.insert(data);\n    } else if (data < this.data && !this.left) {\n      this.left = new Node(data);\n    } else if (data > this.data && this.right) {\n      this.right.insert(data);\n    } else if (data > this.data && !this.right) {\n      this.right = new Node(data);\n    }\n  }\n\n  // Find node with data value\n  contains(data) {\n    if (this.data === data) {\n      return this;\n    } else if (data < this.data) {\n      return this.left.contains(data);\n    } else if (data > this.data && this.right) {\n      return this.right.contains(data);\n    }\n  }\n}\n")),Object(r.b)("h2",{id:"validating-a-bst"},"Validating a BST"),Object(r.b)("p",null,"To handle this, we basically want to keep a ",Object(r.b)("inlineCode",{parentName:"p"},"min")," and ",Object(r.b)("inlineCode",{parentName:"p"},"max")," value to ensure that the thresholds are kept correctly."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const validation = (node, min = null, max = null) => {\n  if (max !== null && node.data > max) {\n    return false;\n  } else if (min !== null && node.data < min) {\n    return false;\n  }\n\n  if (node.left && !validate(node.left, min, node.data)) {\n    return false;\n  }\n\n  if (node.right && !validate(node.right, node.data, max)) {\n    return false;\n  }\n\n  return true;\n} \n\nvalidation(rootNode);\n")),Object(r.b)("h2",{id:"eventing-system"},"Eventing system"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Events {\n  constructor() {\n    this.events = {};\n  }\n\n  on(eventName, callback) {\n    if (this.events[eventName]) {\n      this.events[eventName].push(callback);\n    } else {\n      this.events[eventName] = [callback];\n    }\n  }\n\n  trigger(eventName) {\n    if (this.events[eventName]) {\n      for (let fn of this.events[eventName]) {\n        fn();\n      }\n    }\n  }\n\n  off(eventName) {\n    delete this.events[eventName];\n  }\n}\n")),Object(r.b)("h2",{id:"sort-algos-and-complexities"},"Sort Algos and Complexities"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Name"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Worst case runtime"),Object(r.b)("th",Object.assign({parentName:"tr"},{align:null}),"Difficulty"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"BubbleSort"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"n^2"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"easiest")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"SelectionSort"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"n^2"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"easier")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"MergeSort"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"n*log(n)"),Object(r.b)("td",Object.assign({parentName:"tr"},{align:null}),"medium")))),Object(r.b)("h3",{id:"bubble-sort"},"Bubble sort"),Object(r.b)("p",null,"Take example ",Object(r.b)("inlineCode",{parentName:"p"},"[10,-30,97,0,5]"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const arr = [10,-30,97,0,5];\n\nconst bubbleSort = arr => {\n  for (let i=0; i < arr.length; i++) {\n    for (let j=0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j+1]) {\n        let temp = arr[j+1];\n        arr[j+1] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  return arr;\n}\nconst bubbleSorted = bubbleSort(arr);\n")),Object(r.b)("h3",{id:"selection-sort"},"Selection Sort"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const selectionSort = arr => { \n  for (let i=0; i < arr.length; i++) {\n    let indexOfMin = i;\n    for (let j=i+1; j < arr.length; j++) {\n      if (arr[j] > arr[indexOfMin]) {\n        indexOfMin = j;\n      }\n    }\n\n    if (indexOfMin !== i) {\n        let temp = arr[j];\n        arr[j] = arr[indexOfMin];\n        arr[indexOfMin] = temp;\n    }\n  }\n  return arr;\n}\n\nconst selectionSorted = selectionSort(arr);\n")),Object(r.b)("h3",{id:"merge-sort"},"Merge Sort"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// Used to break down array recursively\nconst mergeSort = arr => {\n  if (arr.length === 1) {\n    return arr;\n  }\n\n  const center = Math.floor(arr.length / 2);\n  const left = arr.slice(0, center);\n  const right = arr.slice(center);\n\n  return merge (\n    mergeSort(left);\n    mergeSort(right);\n  );\n}\n\n// Used to build the array back together\nconst merge = (left, right) => {\n  // create results array \n  let results = [];\n  // while elements in BOTH arrays\n  while (left.length && right.length) {\n    // compare first left < first right \n    if (left[0] < right[0]) {\n      // shift el into res arr\n      results.push(left.shift());\n    } else {\n      results.push(right.shift());\n    }\n  }\n\n  // take everything from the arr that has stuff in it and put it in results\n  return [...results, ...left, ...right];\n}\n")))}l&&l===Object(l)&&Object.isExtensible(l)&&Object.defineProperty(l,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Data-Structures/JavaScript.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-data-structures-java-script.101a1afd2417ec7a4a77.js.map