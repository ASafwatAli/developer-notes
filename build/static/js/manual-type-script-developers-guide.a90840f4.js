(window.webpackJsonp=window.webpackJsonp||[]).push([[503],{"./manual/TypeScript/Developers-Guide.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return o});var a=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),s={},i="wrapper";function o(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(i,Object.assign({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"developers-guide-to-typescript"},"Developer's Guide to TypeScript"),Object(r.b)("h2",{id:"types"},"Types"),Object(r.b)("p",null,"For types, we have all our basic types and we can also have custom types."),Object(r.b)("p",null,"There are two types, ",Object(r.b)("inlineCode",{parentName:"p"},"primitive")," and ",Object(r.b)("inlineCode",{parentName:"p"},"object")," - the ",Object(r.b)("inlineCode",{parentName:"p"},"object")," types itself can be what we define."),Object(r.b)("p",null,"Why do we care? The compiler uses it to search for errors and it allows other engineers to understand what type of data is flowing around."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"interface Todo {\n  id: number;\n  completed: boolean;\n};\n\nconst todo = obj.data as Todo;\n")),Object(r.b)("h2",{id:"declaring-types-examples"},"Declaring types examples"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// array\nlet colors: string[] = ['a', 'b', 'c'];\n\n// class\nclass Car {}\nlet car: Car = new Car();\n\n// object literal\nlet point: { x: number, y: number } = {\n  x: 10,\n  y: 20\n};\n\n// functions\nconst logNumber: (i: number) => void = (i: number) => {\n  console.log(i);\n};\n")),Object(r.b)("p",null,"The object literal gets a bit nasty, but we have ways around this using ",Object(r.b)("inlineCode",{parentName:"p"},"types")," and ",Object(r.b)("inlineCode",{parentName:"p"},"interfaces"),"."),Object(r.b)("h2",{id:"the-any-type"},"The 'any' type"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'const json = \'{"x":10, "y": 20}\';\nconst coordinates = JSON.parse(json); // by default gets any time\n\n// this is the better\nconst coor: { x: number, y: number } = JSON.parse(json);\n')),Object(r.b)("h2",{id:"the-void-and-never-return-types"},"The 'void' and 'never' return types"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// Returns nothing\nconst logger = (message: string): void => console.log(message);\n\n// Never returns\nconst throwError = (message: string): never => throw new Error(message);\n")),Object(r.b)("h2",{id:"interfaces"},"Interfaces"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"interface Vehicle {\n  name: string;\n  year: number;\n  broken: boolean;\n}\n\nconst oldCivic = {\n  name: 'civic',\n  year: 2000,\n  broken: true\n};\n\nconst printVehicle = (vehicle: Vehicle): void => {};\n")),Object(r.b)("h2",{id:"abstract-classes"},"Abstract Classes"),Object(r.b)("p",null,"Good for classes that we only want to use to extend. Think expectation vs reality."),Object(r.b)("p",null,"Abstract classes:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Cannot create objects directly"),Object(r.b)("li",{parentName:"ol"},"Only used as a parent class"),Object(r.b)("li",{parentName:"ol"},"Can contain real implementations of some methods"),Object(r.b)("li",{parentName:"ol"},"Can refer to methods that don't exist yet")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"abstract class Examlpe {\n  // promises we will create this func later\n  abstract requireFunc(argA: number): void;\n\n  swap = (a:number) => requireFunc(a);\n}\n")),Object(r.b)("h2",{id:"abstract-classes-vs-interfaces"},"Abstract classes vs Interfaces"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Interfaces promot loose coupling, Abstract/Inheritance is for strong coupling"),Object(r.b)("li",{parentName:"ul"},"Interfaces for very different objects we want to work together, Abstract/Inheritance for when we want to build up a definition of an object")),Object(r.b)("h2",{id:"enums"},"Enums"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"enum Result {\n  Win = 'W',\n  Loss = 'L',\n  Draw = 'D'\n}\n")),Object(r.b)("h2",{id:"generics"},"Generics"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Like function args, but for types in class/function definitions"),Object(r.b)("li",{parentName:"ul"},"Allow us to define the type of a property/argument/return value at a future point"),Object(r.b)("li",{parentName:"ul"},"Used heavily when writing useable code")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class HoldAnything<TypeOfData> {\n  data: TypeOfData;\n}\n\nconst holdNumber = new HolderAnything<number>();\nconst holdString = new HolderAnything<string>();\n\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\nconst holdCoordinates = new HolderAnything<Coordinates>();\n\n// TypeOfData can actually be called anything\n// Convention is normally T, but then we go alphabetical order if we need multiple generics\n\nclass holdMultipleAnything<T,U,V> {\n  firstThing: T;\n  secondThing: U;\n  thirdThing: V;\n}\n\nconst holdAllTheThings = new holdMultipleAnything<string, number, Coordinates>();\n")),Object(r.b)("h3",{id:"constraints-with-generics"},"Constraints with Generics"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Cannot call base methods on generics since there is no guarantee without a interface"),Object(r.b)("li",{parentName:"ul"})),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class Car {\n  print() {\n    console.log('Car');\n  }\n}\n\nclass House {\n  print() {\n    console.log('House');\n  }\n}\n\ninterface Printable {\n  print(): void;\n}\n\nfunction printWhatever<T extends Printable>(el: T) {\n  el.print();\n}\n\nprintWhatever(new Car());\nprintWhatever(new House());\n")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// what you have to do without method overloading\nclass Utility {\n  static function addNumbers(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function addStrings(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.addNumbers(1,2) // return 2\nUtility.addStrings('Hello','World') // return \"Hello World\"\n\n// method overloading in other languages\nclass Utility {\n  static function add(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function add(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"Hello World\"\n\n// method overloading in other typescript\nclass Utility {\n  static function add(a:number, b: number): number;\n  static function add(a:string, b: string): string;\n\n  static function add(a, b) {\n    return a + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"HelloWorld\"\n")))}o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/TypeScript/Developers-Guide.md"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-type-script-developers-guide.101a1afd2417ec7a4a77.js.map