{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Go/Go-Interfaces.md"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_dennis_okeeffe_Project_Imposter_developer_notes_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"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","file":"static/js/manual-go-go-interfaces.105fe429.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"go-tour-interfaces\"\n    }}>{`Go Tour Interfaces`}</h1>\n    <p>{`A type implements an interface by implementing its methods. There is no explicit declaration of intent, no \"implements\" keyword.`}</p>\n    <p>{`Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement`}</p>\n    <p>{`Under the hood, interface values can be thought of as a tuple of a value and a concrete type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`(value, type)\n`}</code></pre>\n    <p>{`An interface value holds a value of a specific underlying concrete type.`}</p>\n    <p>{`Calling a method on an interface value executes the method of the same name on its underlying type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\nfunc (t *T) M() {\n    fmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n    fmt.Println(f)\n}\n\nfunc main() {\n    var i I\n\n    i = &T{\"Hello\"}\n    describe(i)\n    i.M()\n\n    i = F(math.Pi)\n    describe(i)\n    i.M()\n}\n\nfunc describe(i I) {\n    fmt.Printf(\"(%v, %T)\\\\n\", i, i)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"nil-interface-values\"\n    }}>{`Nil interface values`}</h2>\n    <p>{`A nil interface value holds neither value nor concrete type.`}</p>\n    <p>{`Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.`}</p>\n    <h2 {...{\n      \"id\": \"the-empty-interface\"\n    }}>{`The empty interface`}</h2>\n    <p>{`The interface type that specifies zero methods is known as the empty interface:`}</p>\n    <p>{`interface{}\nAn empty interface may hold values of any type. (Every type implements at least zero methods.)`}</p>\n    <p>{`Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{}\n    describe(i)\n\n    i = 42\n    describe(i)\n\n    i = \"hello\"\n    describe(i)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"(%v, %T)\\\\n\", i, i)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`(<nil>, <nil>)\n(42, int)\n(hello, string)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-assertions\"\n    }}>{`Type assertions`}</h2>\n    <p>{`A type assertion provides access to an interface value's underlying concrete value.`}</p>\n    <p><inlineCode parentName=\"p\">{`t := i.(T)`}</inlineCode></p>\n    <p>{`This statement asserts that the interface value `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` holds the concrete type `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` and assigns the underlying `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` value to the variable `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{`.`}</p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` does not hold a `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, the statement will trigger a panic.`}</p>\n    <p>{`To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.`}</p>\n    <p><inlineCode parentName=\"p\">{`t, ok := i.(T)`}</inlineCode></p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` holds a `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, then `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{` will be the underlying value and ok will be true.`}</p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`not, ok`}</inlineCode>{` will be false and `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{` will be the zero value of type `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, and no panic occurs.`}</p>\n    <p>{`Note the similarity between this syntax and that of reading from a map.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = \"hello\"\n\n    s := i.(string)\n    fmt.Println(s)\n\n    s, ok := i.(string)\n    fmt.Println(s, ok)\n\n    f, ok := i.(float64)\n    fmt.Println(f, ok)\n\n    f = i.(float64) // panic\n    fmt.Println(f)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-switches\"\n    }}>{`Type switches`}</h2>\n    <p>{`A type switch is a construct that permits several type assertions in series.`}</p>\n    <p>{`A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`switch v := i.(type) {\ncase T:\n    // here v has type T\ncase S:\n    // here v has type S\ndefault:\n    // no match; here v has the same type as i\n}\n`}</code></pre>\n    <p>{`The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type.`}</p>\n    <p>{`This switch statement tests whether the interface value i holds a value of type T or S. In each of the T and S cases, the variable v will be of type T or S respectively and hold the value held by i. In the default case (where there is no match), the variable v is of the same interface type and value as i.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Twice %v is %v\\\\n\", v, v*2)\n    case string:\n        fmt.Printf(\"%q is %v bytes long\\\\n\", v, len(v))\n    default:\n        fmt.Printf(\"I don't know about type %T!\\\\n\", v)\n    }\n}\n\nfunc main() {\n    do(21)\n    do(\"hello\")\n    do(true)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`Twice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}