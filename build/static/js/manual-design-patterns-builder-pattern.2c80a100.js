(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{"./manual/Design-Patterns/Builder-Pattern.md":function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return o});var i=n("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),a=(n("./node_modules/react/index.js"),n("./node_modules/@mdx-js/react/dist/index.es.js")),r={},s="wrapper";function o(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)(s,Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"builder-pattern"},"Builder Pattern"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"Builder Pattern")," enables us to create different instance representations using the same construction code."),Object(a.b)("p",null,"In this scenario, we will use the classic trope of building a pizza to illustate how to implement this pattern."),Object(a.b)("p",null,"The pattern works by using the following:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"A ",Object(a.b)("inlineCode",{parentName:"li"},"Product")," which represents the complex object under construction. In this case, the product is the ",Object(a.b)("inlineCode",{parentName:"li"},"Pizza")," class which denotes our pizza instances. We wil name this our ",Object(a.b)("inlineCode",{parentName:"li"},"PizzaProduct"),"."),Object(a.b)("li",{parentName:"ul"},"A ",Object(a.b)("inlineCode",{parentName:"li"},"Builder")," that specifies the abstract class for creating the ",Object(a.b)("inlineCode",{parentName:"li"},"Product")," parts (in our case the ",Object(a.b)("inlineCode",{parentName:"li"},"Pizza"),"). In this case, it will be our abstract class ",Object(a.b)("inlineCode",{parentName:"li"},"PizzaBuilder"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"Concrete Builders")," where each builder is responsible to instantiate different representations of the product. In this case, the concrete builders will be our classes that construct different types of pizza denoted as ",Object(a.b)("inlineCode",{parentName:"li"},"NConcreteBuilder")," where the ",Object(a.b)("inlineCode",{parentName:"li"},"N")," represents the name of the kind of pizza. All we will do in this example is create a Hawaiin pizza and a Meat Lovers pizza, so the concrete builders will be called ",Object(a.b)("inlineCode",{parentName:"li"},"HawaiinConcreteBuilder")," and ",Object(a.b)("inlineCode",{parentName:"li"},"MeatLoversConcreteBuilder")," in this example."),Object(a.b)("li",{parentName:"ul"},"A ",Object(a.b)("inlineCode",{parentName:"li"},"Director")," that constructs the object using the ",Object(a.b)("inlineCode",{parentName:"li"},"Builder")," interface. In this case, we will have the ",Object(a.b)("inlineCode",{parentName:"li"},"ChefDirector")," class fulfil this role. The ",Object(a.b)("inlineCode",{parentName:"li"},"ChefDirector")," will create a chef that is used to create the different types of pizza.")),Object(a.b)("h2",{id:"builder-design-pattern-in-action"},"Builder Design Pattern In Action"),Object(a.b)("p",null,"First, let's build our ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaProduct"),". To do so, we will create an interface to ensure our product will include all the pizza essentials and then implement that to a ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaProduct"),"."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaProduct")," itself will create the pizza instances, but will ultimately be abstracted away and flexibly built thanks to our ",Object(a.b)("inlineCode",{parentName:"p"},"Director")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Concrete Builders"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// each pizza requires a base, sauce and topping property\n// also ensure a taste method is implemented\ninterface Pizza {\n    base: string;\n    sauce: string;\n    topping: string;\n    taste(): void;\n}\n\nclass PizzaProduct implements Pizza {\n    private _base: string;\n    private _topping: string;\n    private _sauce: string;\n\n    constructor() {\n        // initialise all values to empty strings\n        // our direct will use the concrete builders\n        // to set all these values durin\n        this._base = '';\n        this._topping = '';\n        this._sauce = '';\n    }\n\n    set base(baseValue: string) {\n        this._base = baseValue;\n    }\n\n    set topping(toppingValue: string) {\n        this._topping = toppingValue;\n    }\n\n    set sauce(sauceValue: string) {\n        this._sauce = sauceValue;\n    }\n\n    taste(): void {\n        console.log(`Base: ${this._base}, Topping: ${this._topping}, Sauce: ${this._sauce}.`);\n    }\n}\n")),Object(a.b)("h2",{id:"writing-our-abstract-builder"},"Writing Our Abstract Builder"),Object(a.b)("p",null,"Next, we need to define our ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaBuilder"),". This builder will be an abstract class that defines the required methods and set the base for our concrete builders to extend from."),Object(a.b)("p",null,"Note: an abstract class cannot have an instance created. This is incredibly important. The instances created in the program will be done by our concrete builders later."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'abstract class PizzaBuilder {\n    // this relation to the PizzaProduct is what abstracts the PizzaProduct\n    // from the code run from the program\n    protected _pizza: PizzaProduct;\n\n    // we set these functions to abstract because we want\n    // the concrete builders that extend the PizzaBuilder\n    // to implement these functions\n    abstract buildBase(): void;\n    abstract buildSauce(): void;\n    abstract buildTopping(): void;\n\n    constructor() {\n        // added for the sake of simplicty instead of a makePizza function\n        // we will just instantiate an "empty" pizza when a builder\n        // instance is initialised\n        this._pizza = new PizzaProduct();\n    }\n\n    get pizza() {\n        return this._pizza;\n    }\n}\n')),Object(a.b)("h2",{id:"writing-our-concrete-builders"},"Writing Our Concrete Builders"),Object(a.b)("p",null,"Now that the abstract builder has been created, we now create the ",Object(a.b)("inlineCode",{parentName:"p"},"concrete builders"),". Remember, the role of each ",Object(a.b)("inlineCode",{parentName:"p"},"concrete builder")," is the build out different versions of our ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaProduct"),"."),Object(a.b)("p",null,"Note: since we are extended from the abstract class, we do not need to override the constructor method. The base constructor method provided in the super class ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaBuilder")," will handle our instantiation of the private ",Object(a.b)("inlineCode",{parentName:"p"},"_pizza")," property as well as the getter, so the code for these concrete builders should be straight forward implementations of the ",Object(a.b)("inlineCode",{parentName:"p"},"abstract classes")," required."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class HawaiinConcreteBuilder extends PizzaBuilder {\n  buildBase(): void {\n    this._pizza.base = 'thick crust';\n  }\n\n  buildSauce(): void {\n    this._pizza.sauce = 'tomato';\n  }\n\n  buildTopping(): void {\n    this._pizza.topping = 'ham and pineapple';\n  }\n}\n\nclass MeatLoversConcreteBuilder extends PizzaBuilder {\n  buildBase(): void {\n    this._pizza.base = 'thin crust';\n  }\n\n  buildSauce(): void {\n    this._pizza.sauce = 'tomato';\n  }\n\n  buildTopping(): void {\n    this._pizza.topping = 'a lot of meat';\n  }\n}\n")),Object(a.b)("h2",{id:"writing-our-director"},"Writing Our Director"),Object(a.b)("p",null,"Finally, we can build our Chef Director. The role of the director is to take any builder that conforms to our abstract builder class ",Object(a.b)("inlineCode",{parentName:"p"},"PizzaBuilder")," and make the pizzas and taste the pizzas."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class ChefDirector {\n    private pizzaBuilder?: PizzaBuilder;\n\n    makePizza(pizzaBuilder: PizzaBuilder): void {\n        this.pizzaBuilder = pizzaBuilder;\n        this.pizzaBuilder.buildBase();\n        this.pizzaBuilder.buildSauce();\n        this.pizzaBuilder.buildTopping();\n    }\n\n    tastePizza(): void {\n        try {\n            if (!this.pizzaBuilder) {\n                throw new Error('No pizza builder property defined');\n            }\n\n            this.pizzaBuilder.pizza.taste();\n        } catch(e) {\n            console.error(e);\n        }\n    }\n}\n")),Object(a.b)("h2",{id:"putting-it-all-together"},"Putting It All Together"),Object(a.b)("p",null,"Now that all our required code has been written, we can happily write a quite script to test that an instance of our ",Object(a.b)("inlineCode",{parentName:"p"},"ChefDirector"),' can make both a "Hawaiin" and "Meat Lovers" pizza!'),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"// the director will be used to create and taste pizzas\nconst chefDirector = new ChefDirector();\n\n// the concrete builders will now be used to define\n// what type of pizza the chef will make and taste\nconst hawaiinBuilder = new HawaiinConcreteBuilder();\nconst meatLoversBuilder = new MeatLoversConcreteBuilder();\n\n// First, let's test our Hawaiin Pizza\nchefDirector.makePizza(hawaiinBuilder);\nchefDirector.tastePizza();\n\n// Secondly, let's test our Meat Lovers\nchefDirector.makePizza(meatLoversBuilder);\nchefDirector.tastePizza();\n")),Object(a.b)("p",null,"If we now check our console, we can see our results:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-md"}),"Base: thick crust, Topping: ham and pineapple, Sauce: tomato.\nBase: thin crust, Topping: a lot of meat, Sauce: tomato.\n")))}o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Design-Patterns/Builder-Pattern.md"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-design-patterns-builder-pattern.101a1afd2417ec7a4a77.js.map