(window.webpackJsonp=window.webpackJsonp||[]).push([[478],{"./manual/Swift/Swift-3-Extensions.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return o});var i=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),s=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),r={},a="wrapper";function o(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(s.b)(a,Object.assign({},r,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("h1",{id:"swift-3-extensions"},"Swift 3 Extensions"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object.assign({parentName:"li"},{href:"#swift-3-extensions"}),"Swift 3 Extensions"),Object(s.b)("ul",{parentName:"li"},Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object.assign({parentName:"li"},{href:"#extensions"}),"Extensions"),Object(s.b)("ul",{parentName:"li"},Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object.assign({parentName:"li"},{href:"#-----computed-properties"}),"---- Computed Properties")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object.assign({parentName:"li"},{href:"#-----mutating-instance-methods"}),"---- Mutating Instance Methods")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object.assign({parentName:"li"},{href:"#-----subscripts"}),"---- Subscripts")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object.assign({parentName:"li"},{href:"#-----nested-types"}),"---- Nested Types"))))))),Object(s.b)("hr",null),Object(s.b)("h2",{id:"extensions"},"Extensions"),Object(s.b)("p",null,"Extensions add new functionality to an existing class, structure, enumeration, or protocol type."),Object(s.b)("p",null,"This includes the ability to extend types for which you do not have access to the original source code (known as retroactive modeling). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions do not have names.)"),Object(s.b)("p",null,"Extensions in Swift can:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Add computed instance properties and computed type properties"),Object(s.b)("li",{parentName:"ul"},"Define instance methods and type methods"),Object(s.b)("li",{parentName:"ul"},"Provide new initializers"),Object(s.b)("li",{parentName:"ul"},"Define subscripts"),Object(s.b)("li",{parentName:"ul"},"Define and use new nested types"),Object(s.b)("li",{parentName:"ul"},"Make an existing type conform to a protocol")),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),"extension SomeType: SomeProtocol, AnotherProtocol {\n    // implementation of protocol requirements goes here\n}\n")),Object(s.b)("h2",{id:"computed-properties"},"Computed Properties"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),"struct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nlet defaultRect = Rect()\nlet memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n                      size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n")),Object(s.b)("p",null,"Extensions can add new instance methods and type methods to existing types. The following example adds a new instance method called repetitions to the Int type:"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),'extension Int {\n    func repetitions(task: () -> Void) {\n        for _ in 0..<self {\n            task()\n        }\n    }\n}\n\n3.repetitions {\n    print("Hello!")\n}\n// Hello!\n// Hello!\n// Hello!\n')),Object(s.b)("h2",{id:"mutating-instance-methods"},"Mutating Instance Methods"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),"extension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt is now 9\n")),Object(s.b)("h2",{id:"subscripts"},"Subscripts"),Object(s.b)("p",null,"Extensions can add new subscripts to an existing type. This example adds an integer subscript to Swift\u2019s built-in Int type. This subscript ","[n]"," returns the decimal digit n places in from the right of the number:"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),"123456789[0] returns 9\n123456789[1] returns 8\n")),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),"extension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n        for _ in 0..<digitIndex {\n            decimalBase *= 10\n        }\n        return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n\n746381295[9]\n// returns 0, as if you had requested:\n0746381295[9]\n")),Object(s.b)("h2",{id:"nested-types"},"Nested Types"),Object(s.b)("p",null,"Extensions can add new nested types to existing classes, structures, and enumerations:"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{}),'extension Int {\n    enum Kind {\n        case negative, zero, positive\n    }\n    var kind: Kind {\n        switch self {\n        case 0:\n            return .zero\n        case let x where x > 0:\n            return .positive\n        default:\n            return .negative\n        }\n    }\n}\n\n// The nested enumeration can now be used with any Int value:\n\nfunc printIntegerKinds(_ numbers: [Int]) {\n    for number in numbers {\n        switch number.kind {\n        case .negative:\n            print("- ", terminator: "")\n        case .zero:\n            print("0 ", terminator: "")\n        case .positive:\n            print("+ ", terminator: "")\n        }\n    }\n    print("")\n}\nprintIntegerKinds([3, 19, -27, 0, -6, 0, 7])\n// Prints "+ + - 0 - 0 + "\n')))}o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Swift/Swift-3-Extensions.md"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-swift-swift-3-extensions.101a1afd2417ec7a4a77.js.map