(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{"./manual/Elixir/Elixir-School.md":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return o});var t=a("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=(a("./node_modules/react/index.js"),a("./node_modules/@mdx-js/react/dist/index.es.js")),l={},i="wrapper";function o(e){var n=e.components,a=Object(t.a)(e,["components"]);return Object(r.b)(i,Object.assign({},l,a,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"elixir-school"},"Elixir School"),Object(r.b)("p",null,"References and notes come from the ",Object(r.b)("a",Object.assign({parentName:"p"},{href:"https://elixirschool.com/en/"}),"Elixir School page"),"."),Object(r.b)("h2",{id:"basic-types"},"Basic Types"),Object(r.b)("p",null,"These just include unusual ones that are important to know:"),Object(r.b)("h3",{id:"atoms"},"Atoms"),Object(r.b)("p",null,"A constant whose name is value - synonymous with Ruby Symbols:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),":foo == :bar # returns false\n")),Object(r.b)("p",null,"Booleans ",Object(r.b)("inlineCode",{parentName:"p"},"true")," and ",Object(r.b)("inlineCode",{parentName:"p"},"false")," are also the atoms ",Object(r.b)("inlineCode",{parentName:"p"},":true")," and ",Object(r.b)("inlineCode",{parentName:"p"},":false"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),"true |> is_atom # true\n:true |> is_boolean # true\n:true === true # true\n")),Object(r.b)("p",null,"The names of modules are also atoms:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),"is_atom(MyApp.MyModule) # true\n")),Object(r.b)("p",null,"Atoms are also used to reference modules from Erlang libraries, including built in ones."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),":crypto.strong_rand_bytes 3 # <<23, 104, 108>>\n")),Object(r.b)("h2",{id:"conditionals"},"Conditionals"),Object(r.b)("p",null,"Elixir provides the ||, &&, and ! boolean operators. There are three additional operators whose first argument must be a boolean (true or false):"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"iex> true and 42\n42\niex> false or true\ntrue\niex> not false\ntrue\niex> 42 and true\n** (ArgumentError) argument error: 42\niex> not 42\n** (ArgumentError) argument error\n")),Object(r.b)("p",null,"Note: Elixir\u2019s and and or actually map to ",Object(r.b)("inlineCode",{parentName:"p"},"andalso")," and ",Object(r.b)("inlineCode",{parentName:"p"},"orelse")," in Erlang."),Object(r.b)("h2",{id:"comparisons"},"Comparisons"),Object(r.b)("p",null,"Elixir comes with all the comparison operators we\u2019re used to: ==, !=, ===, !==, <=, >=, <, and >."),Object(r.b)("p",null,"For strict comparison of integers and floats, use ===:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"iex> 2 == 2.0\ntrue\niex> 2 === 2.0\nfalse\n")),Object(r.b)("h2",{id:"interpolation"},"Interpolation"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),'iex> name = "Sean"\niex> "Hello #{name}"\n"Hello Sean"\n')),Object(r.b)("h2",{id:"concatenation"},"Concatenation"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),'iex> name = "Sean"\niex> "Hello " <> name\n"Hello Sean"\n')),Object(r.b)("h2",{id:"pattern-matching"},"Pattern Matching"),Object(r.b)("h3",{id:"match-operator"},"Match Operator"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),'# Assignment\niex> x = 1\n1\n# Pattern matching\niex> 1 = x\n1\niex> 2 = x\n** (MatchError) no match of right hand side value: 1\n\n# Lists\niex> list = [1, 2, 3]\niex> [1, 2, 3] = list\n[1, 2, 3]\niex> [] = list\n** (MatchError) no match of right hand side value: [1, 2, 3]\n\niex> [1 | tail] = list\n[1, 2, 3]\niex> tail\n[2, 3]\niex> [2 | _] = list\n** (MatchError) no match of right hand side value: [1, 2, 3]\n\n# Tuples\niex> {:ok, value} = {:ok, "Successful!"}\n{:ok, "Successful!"}\niex> value\n"Successful!"\niex> {:ok, value} = {:error}\n** (MatchError) no match of right hand side value: {:error}\n')),Object(r.b)("h3",{id:"pin-operator"},"Pin Operator"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"iex> x = 1\n1\niex> ^x = 2\n** (MatchError) no match of right hand side value: 2\niex> {x, ^x} = {2, 1}\n{2, 1}\niex> x\n2\n")),Object(r.b)("p",null,"An example of pinning in a function clause:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),'iex> greeting = "Hello"\n"Hello"\niex> greet = fn\n...>   (^greeting, name) -> "Hi #{name}"\n...>   (greeting, name) -> "#{greeting}, #{name}"\n...> end\n#Function<12.54118792/2 in :erl_eval.expr/5>\niex> greet.("Hello", "Sean")\n"Hi Sean"\niex> greet.("Mornin\'", "Sean")\n"Mornin\', Sean"\niex> greeting\n"Hello"\n')))}o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Elixir/Elixir-School.md"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-elixir-elixir-school.101a1afd2417ec7a4a77.js.map