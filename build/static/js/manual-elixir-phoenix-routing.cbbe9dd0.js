(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{"./manual/Elixir/Phoenix-Routing.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return r});var o=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),a=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),i={},l="wrapper";function r(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(a.b)(l,Object.assign({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"phoenix-routing"},"Phoenix Routing"),Object(a.b)("h2",{id:"useful-links"},"Useful Links"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://hexdocs.pm/phoenix/1.4.0/routing.html"}),"https://hexdocs.pm/phoenix/1.4.0/routing.html"))),Object(a.b)("h2",{id:"tldr"},"tl;dr"),Object(a.b)("h3",{id:"examing-routes"},"Examing Routes"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"mix compile # if needed\nmix phx.routes\n")),Object(a.b)("h3",{id:"pipelines"},"Pipelines"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),'defmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  # ...\n\n  scope "/" do\n    pipe_through [:authenticate_user, :ensure_admin]\n    forward "/jobs", BackgroundJob.Plug\n  end\nend\n')),Object(a.b)("p",null,"This means that the plugs in the ",Object(a.b)("inlineCode",{parentName:"p"},"authenticate_user")," and ",Object(a.b)("inlineCode",{parentName:"p"},"ensure_admin")," pipelines will be called before the ",Object(a.b)("inlineCode",{parentName:"p"},"BackgroundJob.Plug")," allowing them to send an appropriate response and call ",Object(a.b)("inlineCode",{parentName:"p"},"halt()"),"."),Object(a.b)("h3",{id:"routing"},"Routing"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),'defmodule HelloWeb.Router do\n  use HelloWeb, :router\n\n  pipeline :browser do\n    plug :accepts, ["html"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, ["json"]\n  end\n\n  scope "/", HelloWeb do\n    pipe_through :browser\n\n    get "/", PageController, :index\n  end\n\n  # Other scopes may use custom stacks.\n  # scope "/api", HelloWeb do\n  #   pipe_through :api\n  # end\nend\n')),Object(a.b)("p",null,"For ",Object(a.b)("inlineCode",{parentName:"p"},'get "/", PageController, :index')," - ",Object(a.b)("inlineCode",{parentName:"p"},"get")," is a Phoenix macro which expands out to define one clause of the match/5 function. It corresponds to the HTTP verb GET. Similar macros exist for other HTTP verbs including POST, PUT, PATCH, DELETE, OPTIONS, CONNECT, TRACE and HEAD."),Object(a.b)("p",null,"The first argument to these macros is the path. Here, it is the root of the application, /. The next two arguments are the controller and action we want to have handle this request. These macros may also take other options, which we will see throughout the rest of this guide."),Object(a.b)("p",null,"If this were the only route in our router module, the clause of the match/5 function would look like this after the macro is expanded:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-elixir"}),'def match(:get, "/", PageController, :index, [])\n')))}r&&r===Object(r)&&Object.isExtensible(r)&&Object.defineProperty(r,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Elixir/Phoenix-Routing.md"}}),r.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-elixir-phoenix-routing.101a1afd2417ec7a4a77.js.map