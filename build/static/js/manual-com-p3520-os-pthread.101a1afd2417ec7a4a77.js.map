{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/COMP3520-OS/Pthread.md"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_dennis_okeeffe_Project_Imposter_developer_notes_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"oXAWMA,EAAc,GAGdC,EAAY,UACH,SAASC,EAATC,GAGZ,IAFDC,EAECD,EAFDC,WACGC,EACFC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,gBACD,OAAOG,OAAAE,EAAA,EAAAF,CAACL,EAADK,OAAAG,OAAA,GAAeT,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYM,QAAQ,cAC5EJ,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,YADR,YAGAL,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,gBADR,gBAGAL,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,yDACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,8FAEFN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,qBACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,YACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,wBAEFN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,uBADR,wBAGAL,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,0FACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,iFAEFN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,mBACHN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,yEAEFN,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,IAA3B,+mBAULN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,sBACHN,OAAAE,EAAA,EAAAF,CAAA,qEACAA,OAAAE,EAAA,EAAAF,CAAA,+HACAA,OAAAE,EAAA,EAAAF,CAAA,0GACAA,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,uBACHN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,uDACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,uEACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,iEAEFN,OAAAE,EAAA,EAAAF,CAAA,qBAAgBA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,yBAChBN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,sCACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,8IAEFN,OAAAE,EAAA,EAAAF,CAAA,qBAAgBA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,kBAAhB,8GACAN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,YACHN,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,4tBA8BLP,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,gCADR,gCAGAL,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,oBAAH,qFACAN,OAAAE,EAAA,EAAAF,CAAA,0HACAA,OAAAE,EAAA,EAAAF,CAAA,kEACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,4pBAyCLP,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,kCADR,kCAGAL,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,aACHN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,kCACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,oCACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,kDACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,mDAEFN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,sEACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,OAA4BN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,kBAA5B,wFACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,qIAA0JN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,mBAC1JN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,+FACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,4DAEFN,OAAAE,EAAA,EAAAF,CAAA,4FAAuFA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,oBAAvF,qBACAN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,8CAAmEN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,uBAAnE,UACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,yCAA8DN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,wBAC9DN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,0CAA+DN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,oCAC/DN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,+DAAoFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,4BAEtFN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,YACHN,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,6oBA0BLP,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,yBADR,yBAGAL,OAAAE,EAAA,EAAAF,CAAA,gKACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,aADR,cAGAL,OAAAE,EAAA,EAAAF,CAAA,uIACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,mCADR,mCAGAL,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,YADR,YAGAL,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,mCAAH,KACFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,gCADE,KAEFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,gCAFE,KAGFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,oCACEN,OAAAE,EAAA,EAAAF,CAAA,+CAA0CA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,mBAA1C,sDACAN,OAAAE,EAAA,EAAAF,CAAA,0FAC8BA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,uDAD9B,8BAEuBN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,wBAFvB,kEAE0JN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,QAF1J,wDAGAN,OAAAE,EAAA,EAAAF,CAAA,6CACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,8BADR,+BAGAL,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,cADR,YAGAL,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,6BAAH,KACFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,+BADE,KAEFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,iCACEN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAKN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,6BAApB,kCACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAKN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,+BAApB,yHAEAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAKN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,gCAApB,sJAGFN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,cACHN,OAAAE,EAAA,EAAAF,CAAA,yEACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,qUAmBLP,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,cACHN,OAAAE,EAAA,EAAAF,CAAA,gBAAWA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,qBAAX,gDACAN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,+HACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,8GACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,oEAEFN,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,ojCA4CLP,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,wBADR,wBAGAL,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,+GACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,6GACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,kFAAuGN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,yBAAvG,MAEFN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,iCACHN,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,iRAcLP,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,YADR,YAGAL,OAAAE,EAAA,EAAAF,CAAA,wDACAA,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,iHACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,6CACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,wEAEFN,OAAAE,EAAA,EAAAF,CAAA,cAASA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,WAAT,kHACAN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,4DACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,4DACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,gEAEFN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,oCACHN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,sEACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,6FACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,mCAAwDN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,sBAAxD,kBAEFN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,UAAQM,WAAW,KAAnB,wBACHN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,0FACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,yGACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,2dAKAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,gCAAqDN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,UAArD,KAA8GN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,WAA9G,KAAwKN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,QAAxK,QAAkON,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,UAAlO,wCACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,4DACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,sDAA2EN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,gBAE7EN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,qCADR,sCAGAL,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,cADR,YAGAL,OAAAE,EAAA,EAAAF,CAAA,6IAIAA,OAAAE,EAAA,EAAAF,CAAA,2DAAsDA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,kBAAtD,sDACAN,OAAAE,EAAA,EAAAF,CAAA,+DAGAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,+CADR,+CAGAL,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,yBAAH,4HAAiMN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,SAAjM,eACAN,OAAAE,EAAA,EAAAF,CAAA,2BAAsBA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,SAAtB,iBAAyFN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,uBAAzF,yBACAN,OAAAE,EAAA,EAAAF,CAAA,SAAGA,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,KAAvB,4BAAH,0EACAN,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,6KAEmDN,OAAAE,EAAA,EAAAF,CAAA,cAAYM,WAAW,MAAvB,uBAFnD,kDAIFN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,+CADR,+CAGAL,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,eADZ,4hDAoDTX,EAAWY,gBAAiB","file":"static/js/manual-com-p3520-os-pthread.483bce07.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"pthreads\"\n    }}>{`Pthreads`}</h1>\n    <h2 {...{\n      \"id\": \"pthreads-api\"\n    }}>{`Pthreads API`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Defined in the ANSI/IEEE Posix 1003.1 - 1995 standard`}</li>\n      <li parentName=\"ul\">{`Subroutines comprise the Pthreads API can be informally grouped into three major classes:`}</li>\n    </ul>\n    <ol>\n      <li parentName=\"ol\">{`Thread management`}</li>\n      <li parentName=\"ol\">{`Mutexes `}</li>\n      <li parentName=\"ol\">{`Condition variables`}</li>\n    </ol>\n    <h1 {...{\n      \"id\": \"1-thread-management\"\n    }}>{`1: Thread Management`}</h1>\n    <ul>\n      <li parentName=\"ul\">{`first class of functions work directly on threads - creating, detatching, joining etc `}</li>\n      <li parentName=\"ul\">{`also include funcs to set/query thread attributes (joinable, scheduling etc)`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Create Threads`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`initially, single default thread - others must be explicitly created`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`pthread_create(thread, attr, startRoutine, arg)\n// thread - unique identifier for the new thread (pthread_t)\n// attr - attr object used to set thread attributes (pthread_attr) - you can specify a thread attributes object, or NULL for the default values\n// startRoutine - C routine that the thread will execute \n// arg - single arg that may be passed to startRoutine - it must be passed by reference (pointer to struct) and NULL may be used if no arg is to be passed\n\n/*\n    If successful, the pthread_create() function shall return zero; otherwise, an error number shall be returned to indicate the error\n */\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Thread Attributes`}</strong></p>\n    <p>{`By default, a thread is created with certain attributes.`}</p>\n    <p>{`pthread_attr_init(attr) and pthread_attr_destroy(attr) are used to initialize/destroy the thread attribute object.`}</p>\n    <p>{`Other routines are then used to query/set specific attributes in the thread attribute object.`}</p>\n    <p><strong parentName=\"p\">{`Terminating Thread`}</strong></p>\n    <ol>\n      <li parentName=\"ol\">{`Thread makes call to the pthread_exit() subroutine `}</li>\n      <li parentName=\"ol\">{`Thread is cancelled by another thread via pthread_cancel() routine `}</li>\n      <li parentName=\"ol\">{`Entire process is terminated due to call to exit subroutine `}</li>\n    </ol>\n    <p>{`Routine: `}<inlineCode parentName=\"p\">{`pthread_exit(status)`}</inlineCode></p>\n    <ul>\n      <li parentName=\"ul\">{`used to explicitly exit the thread`}</li>\n      <li parentName=\"ul\">{`programmer may optionalyl specify a termination status, which is stored as a void pointer for any thread that may join the calling thread`}</li>\n    </ul>\n    <p>{`Cleanup: `}<inlineCode parentName=\"p\">{`pthread_exit()`}</inlineCode>{` does not close files; any files opened inside the thread will remain open after the thread is terminated.`}</p>\n    <p><strong parentName=\"p\">{`Example`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define NUM_THREADS 5\n\nvoid *PrintHello(void *threadid) {\n    int *tid;\n    tid = (int *)threadid;\n    printf(\"Hello World! It's me, thread #%d!\\\\n\", *tid);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t threads[NUM_THREADS];\n    int rc, t, tids[NUM_THREADS];\n    for (t=0; t< NUM_THREADS; t++) {\n        printf(\"In main: creating thread %d\\\\n\", t);\n        tids[t] = t;\n        rc = pthread_create(&threads[t], NULL, PrintHello, (void *)&tids[t]);\n\n        if (rc) {\n            printf(\"ERROR; return code from pthread_create() is %d\\\\n\", rc);\n            exit(-1);\n        }\n    }\n    pthread_exit(NULL); \n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"passing-arguments-to-threads\"\n    }}>{`Passing Arguments to Threads`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_create()`}</inlineCode>{` routine permits the programmer to pass one argument to the thread start routine.`}</p>\n    <p>{`For cases where multiple args must be passed, we can create a struct and use the reference pointer as an arg.`}</p>\n    <p>{`All args passed by reference must be cast to (void *)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`struct two_args {\n    int arg1;\n    int arg2;   \n};\n\nvoid *needs_2_args(void *ap) {\n    struct two_args *argp;\n    int a1, a2;\n\n    argp = (struct two_args *) ap;\n\n    // do stuff here\n    \n    a1 = argp->arg1;\n    a2 = argp->arg2;\n    \n    // do stuff here \n\n    free(argp);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t t;\n    struct two_args *ap;\n    int rc;\n\n    // do stuff here \n\n    ap = (struct two_args *)malloc(sizeof(struct two_args));\n    ap->arg1 = 1;\n    ap->arg2 = 2;\n    rc = pthread_create(&t, NULL, needs_2_args, (void *) ap);\n\n    // do stuff here \n\n    pthread_exit(NULL);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"joining-and-detatching-threads\"\n    }}>{`Joining and Detatching Threads`}</h2>\n    <p><strong parentName=\"p\">{`Routines`}</strong></p>\n    <ol>\n      <li parentName=\"ol\">{`pthread_join(threadid, status)`}</li>\n      <li parentName=\"ol\">{`pthread_detach(threadit, status)`}</li>\n      <li parentName=\"ol\">{`pthread_attr_setdatachstate(attr, detachstate)`}</li>\n      <li parentName=\"ol\">{`pthread_attr_getdetachstate(attr, detachstate)`}</li>\n    </ol>\n    <ul>\n      <li parentName=\"ul\">{`\"joining\" is one way to accomplish synchronization between threads`}</li>\n      <li parentName=\"ul\">{`the `}<inlineCode parentName=\"li\">{`pthread_join()`}</inlineCode>{` subroutine blocks the calling thread until the specified threadid thread terminates`}</li>\n      <li parentName=\"ul\">{`The programmer is able to obtain the target thread's termination return status if it was specified in the target thread's call to `}<inlineCode parentName=\"li\">{`pthread_exit()`}</inlineCode></li>\n      <li parentName=\"ul\">{`When a thread if created, one of its attributes defines whether it is joinable or detached.`}</li>\n      <li parentName=\"ul\">{`Only threads that are create as joinable can be joined.`}</li>\n    </ul>\n    <p>{`To explicitly create a thread as joinable or detached, the attr argument in the `}<inlineCode parentName=\"p\">{`pthread_create()`}</inlineCode>{` routine is used:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Declare a pthread attribute ariable of the `}<inlineCode parentName=\"li\">{`pthread_attr_t data`}</inlineCode>{` type `}</li>\n      <li parentName=\"ol\">{`Initialize the attribute ariable with `}<inlineCode parentName=\"li\">{`pthread_attr_init()`}</inlineCode></li>\n      <li parentName=\"ol\">{`Set the attribute detached status with `}<inlineCode parentName=\"li\">{`pthread_attr_setdetachedstate()`}</inlineCode></li>\n      <li parentName=\"ol\">{`When done, ree library resources used by the attribute with `}<inlineCode parentName=\"li\">{`pthread_attr_destroy()`}</inlineCode></li>\n    </ol>\n    <p><strong parentName=\"p\">{`Example`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`void *BusyWork(void *null) {\n    // do stuff \n    pthread_exit((void *) 0);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_attr_t attr;\n    int rc, t;\n    void *status;\n\n    /* init and set thread detached attribute */\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    /* free attribute and wait for the other threads */\n    pthread_attr_destory(&attr);\n    for (t=0; t< NUM_THREADS; t++) {\n        rc = pthread_join(thread[t], &status);\n        // do stuff \n        printf(\"Completed join with thred %d status = %ld\\\\n\", t, (long)status);\n    }\n    pthread_exit(NULL);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"syncronisation-issues\"\n    }}>{`Syncronisation Issues`}</h2>\n    <p>{`When multiple threads attempt to manipulate the same data item, the results can often be incoherent if proper care is not take ie. race conditions.`}</p>\n    <h1 {...{\n      \"id\": \"2-mutexes\"\n    }}>{`2: Mutexes`}</h1>\n    <p>{`The second class of functions deal with synchronization - called a \"mutex\", which is an abbreviation for mutual exclusion.`}</p>\n    <h2 {...{\n      \"id\": \"creating-and-destroying-mutexes\"\n    }}>{`Creating and Destroying Mutexes`}</h2>\n    <h2 {...{\n      \"id\": \"routines\"\n    }}>{`Routines`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_mutex_init(mutex, attr)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutex_destroy(mutex)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutexattr_init(attr)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutexattr_destroy(attr)`}</inlineCode></p>\n    <p>{`A mutex must be declared with type `}<inlineCode parentName=\"p\">{`pthread_mutex_t`}</inlineCode>{`, and must be initialized before they can be used.`}</p>\n    <p>{`There are two ways to init a mutex variable:\n1. Statically, when declared eg `}<inlineCode parentName=\"p\">{`pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER`}</inlineCode>{`\n2. Dynamically, with the `}<inlineCode parentName=\"p\">{`pthread_mutex_init()`}</inlineCode>{` routine. This method permits setting mutex object attributes, `}<inlineCode parentName=\"p\">{`attr`}</inlineCode>{` (which my be specified as NULL to accept defaults).`}</p>\n    <p>{`The mutex is initially unlocked.`}</p>\n    <h2 {...{\n      \"id\": \"locking--unlocking-mutexes\"\n    }}>{`Locking & Unlocking Mutexes`}</h2>\n    <h2 {...{\n      \"id\": \"routines-1\"\n    }}>{`Routines`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_mutex_lock(mutex)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutex_unlock(mutex)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutex_trylock(mutex)`}</inlineCode></p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`pthread_mutex_lock(mutex)`}</inlineCode>{` will lock the specified mutex`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`pthread_mutex_unlock(mutex)`}</inlineCode>{` will unlock a mutex if called by the owning thread\n- throws an error if already unlocked or owned by another thread`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`pthread_mutex_trylock(mutex)`}</inlineCode>{` will attempt to lock a mutex, however if the mutex is already locked it will return a \"EBUSY\" error code.\n- May be useful to prevent deadlocks!`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Example 1`}</strong></p>\n    <p>{`We can now write our previously incorrect code segment as...`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_mutex_t min_value_lock;\n\nmain() {\n    ...\n    pthread_mutex_init(&min_value_lock, NULL);\n    ...\n}\n\nvoid *find_min(void *list_ptr) {\n    ...\n    pthread_mutex_lock(&min_value_lock);\n    if (my_cost < best_cost) {\n        best_cost = my_cost;\n    }   \n    pthread_mutex_unlock(&min_value_lock);\n}\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Example 2`}</strong></p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`producer-consumer`}</inlineCode>{` scenario imposes the following constraints:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`The producer thread must not overwrite the shared buffer when the previous task has no been picked up by a consumer thread.`}</li>\n      <li parentName=\"ol\">{`The consumer threads must not pick up tasks until there is something present in the shared data structure.`}</li>\n      <li parentName=\"ol\">{`Individual consumer threads should pick up tasks one at a time.`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_mutex_t task_queue_lock;\nint task_available;\n\nmain() {\n    task_available = 0;\n    pthread_mutex_init(&task_queue_lock, NULL);\n}\n\nvoid *producer(void *producer_thread_data) {\n    ...\n    while (!done()) {\n        inserted = 0;\n        create_task(&my_task);\n        while (inserted == 0) {\n            pthread_mutex_lock(&task_queue_lock);\n            if (task_available == 0) {\n                insert_into_queue(my_task);\n                task_available = 1;\n                inserted = 1;\n            }\n            pthread_mutex_unlock(&task_queue_lock);\n        }\n    }\n}\n\nvoid *consumer(void *consumer_thread_data) {\n    ...\n    while (!done()) {\n        extracted = 0;\n        while (extracted == 0) {\n            pthread_mutex_lock(&task_queue_lock);\n            if (task_available == 1) {\n                extract_from_queue(&my_task);\n                task_available = 0;\n                extracted = 1;\n            }\n            pthread_mutex_unlock(&task_queue_lock);\n        }\n        process_task(my_task);\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"overheads-of-locking\"\n    }}>{`Overheads of Locking`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Locks represent serialization points since critical sections must be executed by threads one after another.`}</li>\n      <li parentName=\"ul\">{`Encapsulating large segments of the program within locks can lead to significant performance degradation.`}</li>\n      <li parentName=\"ul\">{`It is often possible to reduce the idling overhead associated with locks using `}<inlineCode parentName=\"li\">{`pthread_mutex_trylock`}</inlineCode>{`.`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Alleviating Locking Overhead`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_mutex_t tryLock_lock = PTHREAD_MUTEX_INITIALIZER;\n\nlock_status = pthread_mutex_trylock(&tryLock_lock)\nif (lock_status == EBUSY) {\n    /* do something else */\n    ...\n} else {\n    /* do one thing */\n    ...\n    pthread_mutex_unlock(&tryLock_lock);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"monitors\"\n    }}>{`Monitors`}</h2>\n    <p>{`Mutexes provide powerful sync tools, but...`}</p>\n    <ul>\n      <li parentName=\"ul\">{`lock() and unlock() are scatteed among several threads, therefore it is difficult to understand their effects`}</li>\n      <li parentName=\"ul\">{`usage must be correct in all the threads `}</li>\n      <li parentName=\"ul\">{`one bad thread (or one programming error) can kill the whole system`}</li>\n    </ul>\n    <p>{`A `}<inlineCode parentName=\"p\">{`monitor`}</inlineCode>{` is a high-level abstraction that may provide a convenient and effective mechanism for thread synchronization.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`local data variables are accessible only by the monitor `}</li>\n      <li parentName=\"ul\">{`thread enters monitor by invoking one of its procedures `}</li>\n      <li parentName=\"ul\">{`only one thread may be executing in a the monitor at a time`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Monitor and Condition Variables`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`Monitor does not need to code certain sync constraints explicitly.`}</li>\n      <li parentName=\"ul\">{`However, it is not sufficiently powerful for modeling some other synchronization schemes.`}</li>\n      <li parentName=\"ul\">{`An additional sync mechanism ie `}<inlineCode parentName=\"li\">{`condition variable`}</inlineCode>{` is required.`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Condition Variables`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`The third class of functions address communications between threads that share a mutex`}</li>\n      <li parentName=\"ul\">{`A condition variable allows a thread to block itself until specified data reaches a predefined state.`}</li>\n      <li parentName=\"ul\">{`A condition variable indicates an event and has no value\n- One cannot store a value into nor retrieve a value from a condition variable.\n- If a thread must wait for an event to occur, that tread waits on the corresponding condition variable.\n- A condition variable has a queue for those threads that are waiting the corresponding event to occur to wait on.\n- If another thread causes the event to occur, that thread simply signal the corresponding condition variable.`}</li>\n      <li parentName=\"ul\">{`This class includes funcs to `}<inlineCode parentName=\"li\">{`create`}</inlineCode>{`, `}<inlineCode parentName=\"li\">{`destroy`}</inlineCode>{`, `}<inlineCode parentName=\"li\">{`wait`}</inlineCode>{` and `}<inlineCode parentName=\"li\">{`signal`}</inlineCode>{` based on specified variable values.`}</li>\n      <li parentName=\"ul\">{`Funcs to set/quey cond variable attrs are also included.`}</li>\n      <li parentName=\"ul\">{`Cond variable is always used in conjunction with a `}<inlineCode parentName=\"li\">{`mutex lock`}</inlineCode></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"create--destroying-cond-variables\"\n    }}>{`Create & Destroying Cond Variables`}</h2>\n    <h2 {...{\n      \"id\": \"routines-2\"\n    }}>{`Routines`}</h2>\n    <p>{`pthread_cond_init(condition, attr)\npthread_cond_destroy(condition)\npthread_condattr_init(attr)\npthread_condattr_destroy(attr)`}</p>\n    <p>{`Condition variables must be declared with type `}<inlineCode parentName=\"p\">{`pthread_cont_t`}</inlineCode>{`, and must be initialized before they can be used.`}</p>\n    <p>{`2 Ways to declare:\n1. Statically\n2. Dynamically `}</p>\n    <h2 {...{\n      \"id\": \"waiting-and-signaling-on-condition-variable\"\n    }}>{`Waiting and Signaling on Condition Variable`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_cond_signal()`}</inlineCode>{` is used to signal (or wake up) another thread which is waiting on the condition variable and should be called after the `}<inlineCode parentName=\"p\">{`mutex`}</inlineCode>{` is locked.`}</p>\n    <p>{`It must unlock `}<inlineCode parentName=\"p\">{`mutex`}</inlineCode>{` in order for `}<inlineCode parentName=\"p\">{`pthread_cond_wait()`}</inlineCode>{` routine to complete.`}</p>\n    <p><inlineCode parentName=\"p\">{`pthread_cond_broadcast()`}</inlineCode>{` routine unlocks all of the threads blocked on the condition variable.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Proper locking and unlocked of mutex is essential for these routines\n- Failing to lock may cause it NOT to block\n- Failing to unlock the mutex may not allow a matching `}<inlineCode parentName=\"li\">{`pthread_cond_wait()`}</inlineCode>{` routine to complete (it will remain blocked)`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"producer-consumer-using-condition-variables\"\n    }}>{`Producer-Consumer Using Condition Variables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_cond_t cond_queue_empty, cond_queue_full;\npthread_mutex_t task_queue_cond_lock;\nint task_available;\n// other data structures here \n\nmain() {\n    // declarations and initializations \n    task_available = 0;\n    pthread_cond_init(&cond_queue_empty, NULL);\n    pthread_cond_init(&cond_queue_full, NULL);\n    pthread_mutex_init(&task_queue_cond_lock, NULL);\n    // create and join producer and consumer threads\n}\n\nvoid *producer(void *producer_thread_data) {\n    while(!done()) {\n        create_task();\n        pthread_mutex_lock(&task_queue_cond_lock);\n        \n        while (task_available == 1) {\n            pthread_cond_wait(&cond_queue_empty,\n                &task_queue_cond_lock);\n        }\n\n        insert_into_queue();\n        task_available = 1;\n        pthread_cond_signal(&cond_queue_full);\n        pthread_mutex_unlock(&task_queue_cond_lock);\n    }\n}\n\nvoid *consumer(void *consumer_thread_data) {\n    while(!done()) {\n        pthread_mutex_lock(&task_queue_cond_lock);\n        while (task_available == 0) {\n            pthread_cond_wait(&cond_queue_full,\n                &task_queue_cond_lock);\n        }\n\n        my_task = extract_from_queue();\n        task_available = 0;\n        pthread_cond_signal(&cond_queue_empty);\n        pthread_mutex_unlock(&task_queue_cond_lock);\n        process_task(my_task);\n    }\n}\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}