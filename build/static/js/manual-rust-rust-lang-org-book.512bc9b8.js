(window.webpackJsonp=window.webpackJsonp||[]).push([[440],{"./manual/Rust/Rust-Lang-Org-Book.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return l});var a=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),i={},s="wrapper";function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(s,Object.assign({},i,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"rust-lang-book"},"Rust Lang Book"),Object(r.b)("p",null,"Resources for this can be found from ",Object(r.b)("a",Object.assign({parentName:"p"},{href:"https://doc.rust-lang.org/book/foreword.html"}),"here"),"."),Object(r.b)("h2",{id:"hello-world"},"Hello World"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'// main.rs\nfn main() {\n    println!("Hello, world!");\n}\n')),Object(r.b)("p",null,"Note: ",Object(r.b)("inlineCode",{parentName:"p"},"println!")," calls a Rust macro. If it called a function instead, it would be entered as println (without the !). For now, you just need to know that using a ! means that you\u2019re calling a macro instead of a normal function."),Object(r.b)("h2",{id:"hello-cargo"},"Hello Cargo"),Object(r.b)("p",null,"Cargo is Rust\u2019s build system and package manager. Most Rustaceans use this tool to manage their Rust projects because Cargo handles a lot of tasks for you, such as building your code, downloading the libraries your code depends on, and building those libraries. (We call libraries your code needs dependencies.)"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"$ cargo new hello_cargo\n$ cd hello_cargo\n")),Object(r.b)("p",null,"The first command creates a new directory called hello_cargo. We\u2019ve named our project hello_cargo, and Cargo creates its files in a directory of the same name."),Object(r.b)("p",null,"Go into the hello_cargo directory and list the files. You\u2019ll see that Cargo has generated two files and one directory for us: a Cargo.toml file and a src directory with a main.rs file inside. It has also initialized a new Git repository along with a .gitignore file."),Object(r.b)("p",null,"This will be the ",Object(r.b)("inlineCode",{parentName:"p"},"cargo.toml")," file."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'[package]\nname = "hello_cargo"\nversion = "0.1.0"\nauthors = ["Your Name <you@example.com>"]\nedition = "2018"\n\n[dependencies]\n')),Object(r.b)("h2",{id:"building-and-running-from-a-cargo-project"},"Building and running from a cargo project"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"$ cargo build\n# This command creates an executable file in target/debug/hello_cargo (or target\\debug\\hello_cargo.exe on Windows) rather than in your current directory. You can run the executable with this command:\n$ ./target/debug/hello_cargo\n> Hello, world!\n# We can also run with cargo run\n$ cargo run\n# Cargo also provides a command called cargo check. This command quickly checks your code to make sure it compiles but doesn\u2019t produce an executable\n$ cargo check\n")),Object(r.b)("h2",{id:"building-for-release"},"Building for release"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"$ cargo build --release\n")),Object(r.b)("p",null,"This command will create an executable in target/release instead of target/debug. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you\u2019ll give to a user that won\u2019t be rebuilt repeatedly and that will run as fast as possible. If you\u2019re benchmarking your code\u2019s running time, be sure to run ",Object(r.b)("inlineCode",{parentName:"p"},"cargo build --release")," and benchmark with the executable in target/release."),Object(r.b)("h2",{id:"file-layout"},"File layout"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-shell"}),"cargo new guessing_game\n")),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'// guessing_game/src/main.rs\nuse std::io;\n\nfn main() {\n    println!("Guess the number!");\n\n    println!("Please input your guess.");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect("Failed to read line");\n\n    println!("You guessed: {}", guess);\n}\n')),Object(r.b)("p",null,"This code contains a lot of information, so let\u2019s go over it line by line. To obtain user input and then print the result as output, we need to bring the io (input/output) library into scope. The io library comes from the standard library (which is known as std):"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),"use std::io;\n")),Object(r.b)("p",null,"By default, Rust brings only a few types into the scope of every program in the prelude. If a type you want to use isn\u2019t in the prelude, you have to bring that type into scope explicitly with a use statement. Using the ",Object(r.b)("inlineCode",{parentName:"p"},"std::io")," library provides you with a number of useful features, including the ability to accept user input."),Object(r.b)("p",null,"The following example shows how to use ",Object(r.b)("inlineCode",{parentName:"p"},"mut")," before the variable name to make a variable mutable:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),"let foo = 5; // immutable\nlet mut bar = 5; // mutable\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"::")," syntax in the ",Object(r.b)("inlineCode",{parentName:"p"},"::new")," line indicates that new is an associated function of the ",Object(r.b)("inlineCode",{parentName:"p"},"String")," type. An associated function is implemented on a type, in this case String, rather than on a particular instance of a String. Some languages call this a static method."),Object(r.b)("p",null,"This new function creates a new, empty string. You\u2019ll find a new function on many types, because it\u2019s a common name for a function that makes a new value of some kind."),Object(r.b)("p",null,"To summarize, the ",Object(r.b)("inlineCode",{parentName:"p"},"let mut guess = String::new();")," line has created a mutable variable that is currently bound to a new, empty instance of a String."),Object(r.b)("p",null,"Recall that we included the input/output functionality from the standard library with use ",Object(r.b)("inlineCode",{parentName:"p"},"std::io"),"; on the first line of the program. Now we\u2019ll call an associated function, ",Object(r.b)("inlineCode",{parentName:"p"},"stdin"),", on ",Object(r.b)("inlineCode",{parentName:"p"},"io"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'io::stdin().read_line(&mut guess)\n    .expect("Failed to read line");\n')),Object(r.b)("p",null,"If we hadn\u2019t listed the ",Object(r.b)("inlineCode",{parentName:"p"},"use std::io")," line at the beginning of the program, we could have written this function call as ",Object(r.b)("inlineCode",{parentName:"p"},"std::io::stdin"),". The stdin function returns an instance of ",Object(r.b)("inlineCode",{parentName:"p"},"std::io::Stdin"),", which is a type that represents a handle to the standard input for your terminal."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"&")," indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust\u2019s major advantages is how safe and easy it is to use references."),Object(r.b)("p",null,"As mentioned earlier, ",Object(r.b)("inlineCode",{parentName:"p"},"read_line")," puts what the user types into the string we\u2019re passing it, but it also returns a value\u2014in this case, an ",Object(r.b)("inlineCode",{parentName:"p"},"io::Result"),". Rust has a number of types named ",Object(r.b)("inlineCode",{parentName:"p"},"Result")," in its standard library: a generic ",Object(r.b)("inlineCode",{parentName:"p"},"Result")," as well as specific versions for submodules, such as ",Object(r.b)("inlineCode",{parentName:"p"},"io::Result"),"."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Result")," types are enumerations, often referred to as ",Object(r.b)("inlineCode",{parentName:"p"},"enums"),". An enumeration is a type that can have a fixed set of values, and those values are called the enum\u2019s variants."),Object(r.b)("p",null,"For Result, the variants are ",Object(r.b)("inlineCode",{parentName:"p"},"Ok")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Err"),". The ",Object(r.b)("inlineCode",{parentName:"p"},"Ok")," variant indicates the operation was successful, and inside ",Object(r.b)("inlineCode",{parentName:"p"},"Ok")," is the successfully generated value. The ",Object(r.b)("inlineCode",{parentName:"p"},"Err")," variant means the operation failed, and ",Object(r.b)("inlineCode",{parentName:"p"},"Err")," contains information about how or why the operation failed."),Object(r.b)("h2",{id:"printing-values-with-the-println-placeholders"},"Printing values with the println placeholders"),Object(r.b)("p",null,"The set of curly brackets, ",Object(r.b)("inlineCode",{parentName:"p"},"{}"),", is a placeholder: think of ",Object(r.b)("inlineCode",{parentName:"p"},"{}")," as little crab pincers that hold a value in place. You can print more than one value using curly brackets: the first set of curly brackets holds the first value listed after the format string, the second set holds the second value, and so on. Printing multiple values in one call to println! would look like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'fn main() {\n    let x = 5;\n    let y = 10;\n\n    println!("x = {} and y = {}", x, y);\n}\n')),Object(r.b)("p",null,"This code would print x = 5 and y = 10."),Object(r.b)("h2",{id:"generating-a-random-number"},"Generating a random number"),Object(r.b)("p",null,"In this case, we would have to update our ",Object(r.b)("inlineCode",{parentName:"p"},"Cargo.toml")," file to include the ",Object(r.b)("inlineCode",{parentName:"p"},"rand")," crate"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-toml"}),'[dependencies]\nrand = "0.4.0"\n')),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"cargo build")," to install the dependency, but running ",Object(r.b)("inlineCode",{parentName:"p"},"cargo update")," would also update the version for the latest minor version."),Object(r.b)("p",null,"In use, we can now random generate a number:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'use std::io;\nuse rand::Rng;\n\nfn main() {\n    println!("Guess the number!");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!("The secret number is: {}", secret_number);\n\n    println!("Please input your guess.");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect("Failed to read line");\n\n    println!("You guessed: {}", guess);\n}\n')),Object(r.b)("h2",{id:"comparing-a-guess-to-the-secret-number"},"Comparing a guess to the secret number"),Object(r.b)("p",null,"We can now use another standard library to help give more information on the accuracy of the guess:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'use std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n\n    // --snip--\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect("Failed to read line");\n\n    let guess: u32 = guess.trim().parse()\n        .expect("Please type a number!");\n\n    println!("You guessed: {}", guess);\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less => println!("Too small!"),\n        Ordering::Greater => println!("Too big!"),\n        Ordering::Equal => println!("You win!"),\n    }\n}\n')),Object(r.b)("p",null,"Note here that we are using some standard string methods to trim, parse and expect a number type for the ",Object(r.b)("inlineCode",{parentName:"p"},"guess")," variable."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"parse")," method on strings parses a string into some kind of number. Because this method can parse a variety of number types, we need to tell Rust the exact number type we want by using ",Object(r.b)("inlineCode",{parentName:"p"},"let guess: u32"),". The colon (:) after guess tells Rust we\u2019ll annotate the variable\u2019s type. Rust has a few built-in number types; the u32 seen here is an unsigned, 32-bit integer. It\u2019s a good default choice for a small positive number. You\u2019ll learn about other number types in Chapter 3. Additionally, the ",Object(r.b)("inlineCode",{parentName:"p"},"u32")," annotation in this example program and the comparison with ",Object(r.b)("inlineCode",{parentName:"p"},"secret_number")," means that Rust will infer that ",Object(r.b)("inlineCode",{parentName:"p"},"secret_number")," should be a ",Object(r.b)("inlineCode",{parentName:"p"},"u32")," as well. So now the comparison will be between two values of the same type!"),Object(r.b)("p",null,"The call to parse could easily cause an error. If, for example, the string contained ",Object(r.b)("inlineCode",{parentName:"p"},"A\ud83d\udc4d%"),', there would be no way to convert that to a number. Because it might fail, the parse method returns a Result type, much as the read_line method does (discussed earlier in "Handling Potential Failure with the Result Type"). We\u2019ll treat this Result the same way by using the expect method again. If parse returns an Err Result variant because it couldn\u2019t create a number from the string, the expect call will crash the game and print the message we give it. If parse can successfully convert the string to a number, it will return the Ok variant of Result, and expect will return the number that we want from the Ok value.'),Object(r.b)("h2",{id:"allowing-multiple-guesses-with-looping"},"Allowing Multiple Guesses with Looping"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'// --snip--\n\n    println!("The secret number is: {}", secret_number);\n\n    loop {\n        println!("Please input your guess.");\n\n        // --snip--\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!("Too small!"),\n            Ordering::Greater => println!("Too big!"),\n            Ordering::Equal => println!("You win!"),\n        }\n    }\n}\n')),Object(r.b)("p",null,"This is suboptimal as the only way to exit at the moment is to pass a string that cannot be passed to cause an error."),Object(r.b)("p",null,"What we can do instead is update this is break the loop at particular parts:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'// --snip--\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!("Too small!"),\n            Ordering::Greater => println!("Too big!"),\n            Ordering::Equal => {\n                println!("You win!");\n                break;\n            }\n        }\n    }\n}\n')),Object(r.b)("p",null,"We could also now update the ",Object(r.b)("inlineCode",{parentName:"p"},"parse")," method to handle and continue on errors now that we are looping:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'// --snip--\n\nio::stdin().read_line(&mut guess)\n    .expect("Failed to read line");\n\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n\nprintln!("You guessed: {}", guess);\n\n// --snip--\n')),Object(r.b)("h2",{id:"the-final-code"},"The final code"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-rust"}),'use std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!("Guess the number!");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    loop {\n        println!("Please input your guess.");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect("Failed to read line");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!("You guessed: {}", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!("Too small!"),\n            Ordering::Greater => println!("Too big!"),\n            Ordering::Equal => {\n                println!("You win!");\n                break;\n            }\n        }\n    }\n}\n')))}l&&l===Object(l)&&Object.isExtensible(l)&&Object.defineProperty(l,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Rust/Rust-Lang-Org-Book.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-rust-rust-lang-org-book.101a1afd2417ec7a4a77.js.map