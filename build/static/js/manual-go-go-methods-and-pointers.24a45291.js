(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{"./manual/Go/Go-Methods-And-Pointers.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return i});var a=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),r=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),o={},c="wrapper";function i(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(c,Object.assign({},o,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"go-tour-methods--pointer-indirection"},"Go Tour Methods & Pointer Indirection"),Object(r.b)("p",null,"Take the following code:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-golang"}),'package main\n\nimport "fmt"\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    v.Scale(2)\n    ScaleFunc(&v, 10)\n\n    p := &Vertex{4, 3}\n    p.Scale(3)\n    ScaleFunc(p, 8)\n\n    fmt.Println(v, p)\n}\n')),Object(r.b)("p",null,"Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK\n")),Object(r.b)("p",null,"While methods with pointer receivers take either a value or a pointer as the receiver when they are called:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n")),Object(r.b)("p",null,"For the statement ",Object(r.b)("inlineCode",{parentName:"p"},"v.Scale(5)"),", even though v is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement ",Object(r.b)("inlineCode",{parentName:"p"},"v.Scale(5)")," as ",Object(r.b)("inlineCode",{parentName:"p"},"(&v).Scale(5)")," since the Scale method has a pointer receiver."),Object(r.b)("h2",{id:"reverse-direction"},"Reverse direction"),Object(r.b)("p",null,"The equivalent thing happens in the reverse direction."),Object(r.b)("p",null,"Take the following code:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-golang"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(v.Abs())\n    fmt.Println(AbsFunc(v))\n\n    p := &Vertex{4, 3}\n    fmt.Println(p.Abs())\n    fmt.Println(AbsFunc(*p))\n}\n')),Object(r.b)("p",null,"Functions that take a value argument must take a value of that specific type:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!\n")),Object(r.b)("p",null,"While methods with value receivers take either a value or a pointer as the receiver when they are called:"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n")),Object(r.b)("p",null,"In this case, the method call ",Object(r.b)("inlineCode",{parentName:"p"},"p.Abs()")," is interpreted as ",Object(r.b)("inlineCode",{parentName:"p"},"(\\*p).Abs()"),"."),Object(r.b)("h1",{id:"choosing-a-value-or-pointer-receiver"},"Choosing a value or pointer receiver"),Object(r.b)("p",null,"There are two reasons to use a pointer receiver."),Object(r.b)("p",null,"The first is so that ",Object(r.b)("strong",{parentName:"p"},"the method can modify the value that its receiver points to"),"."),Object(r.b)("p",null,"The second is ",Object(r.b)("strong",{parentName:"p"},"to avoid copying the value on each method call"),". This can be more efficient if the receiver is a large struct, for example."),Object(r.b)("p",null,"In this example, both ",Object(r.b)("inlineCode",{parentName:"p"},"Scale")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Abs")," are with receiver type ",Object(r.b)("inlineCode",{parentName:"p"},"*Vertex"),", even though the Abs method needn't modify its receiver."),Object(r.b)("p",null,"In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We'll see why over the next few pages.)"))}i&&i===Object(i)&&Object.isExtensible(i)&&Object.defineProperty(i,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Go/Go-Methods-And-Pointers.md"}}),i.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-go-go-methods-and-pointers.101a1afd2417ec7a4a77.js.map