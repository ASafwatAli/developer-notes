{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Go/Go-Tour-Channels.md"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_dennis_okeeffe_Project_Imposter_developer_notes_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"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","file":"static/js/manual-go-go-tour-channels.095934ee.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"go-tour-channels\"\n    }}>{`Go Tour Channels`}</h1>\n    <p>{`Channels are a typed conduit through which you can send and receive values with the channel operator, <-.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch <- v    // Send v to channel ch.\nv := <-ch  // Receive from ch, and\n           // assign value to v.\n`}</code></pre>\n    <p>{`(The data flows in the direction of the arrow.)`}</p>\n    <p>{`Like maps and slices, channels must be created before use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int)\n`}</code></pre>\n    <p>{`By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.`}</p>\n    <p>{`The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.`}</p>\n    <h2 {...{\n      \"id\": \"basic-example\"\n    }}>{`Basic Example`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n    fmt.Println(\"%v\", s)\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum // send sum to c\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c // receive from c\n\n    fmt.Println(x, y, x+y)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`%v [-9 4 0]\n%v [7 2 8]\n-5 17 12\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"buffered-channels\"\n    }}>{`Buffered Channels`}</h2>\n    <p>{`Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int, 100)\n`}</code></pre>\n    <p>{`Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.`}</p>\n    <p>{`If you overflow the buffer, you'll be hit with a `}<inlineCode parentName=\"p\">{`deadlock`}</inlineCode>{` error.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan int, 2)\n    ch <- 1\n    ch <- 2\n    fmt.Println(<-ch)\n    fmt.Println(<-ch)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"range-and-close\"\n    }}>{`Range and Close`}</h2>\n    <p>{`A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`v, ok := <-ch\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`ok`}</inlineCode>{` is false if there are no more values to receive and the channel is closed.`}</p>\n    <p>{`The loop for `}<inlineCode parentName=\"p\">{`i := range c`}</inlineCode>{` receives values from the channel repeatedly until it is closed.`}</p>\n    <p>{`Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.`}</p>\n    <p>{`Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n    x, y := 0, 1\n    for i := 0; i < n; i++ {\n        c <- x\n        x, y = y, x+y\n    }\n    close(c)\n}\n\nfunc main() {\n    c := make(chan int, 10)\n    go fibonacci(cap(c), c)\n    for i := range c {\n        fmt.Println(i)\n    }\n}\n`}</code></pre>\n    <p>{`This prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"select\"\n    }}>{`Select`}</h2>\n    <p>{`The select statement lets a goroutine wait on multiple communication operations.`}</p>\n    <p>{`A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n        case c <- x:\n            x, y = y, x+y\n        case <-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}\n`}</code></pre>\n    <p>{`After looping through in the IIFE `}<inlineCode parentName=\"p\">{`go func`}</inlineCode>{`, it will send a 0 to the `}<inlineCode parentName=\"p\">{`quit`}</inlineCode>{` channel and `}<inlineCode parentName=\"p\">{`select`}</inlineCode>{` will handle by printing \"quit\" and returning from the infinite `}<inlineCode parentName=\"p\">{`for`}</inlineCode>{` loop.`}</p>\n    <h2 {...{\n      \"id\": \"default-selection\"\n    }}>{`Default Selection`}</h2>\n    <p>{`The default case in a select is run if no other case is ready.`}</p>\n    <p>{`Use a default case to try a send or receive without blocking:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`select {\ncase i := <-c:\n    // use i\ndefault:\n    // receiving from c would block\n}\n`}</code></pre>\n    <p>{`Example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    tick := time.Tick(100 * time.Millisecond)\n    boom := time.After(500 * time.Millisecond)\n    for {\n        select {\n        case <-tick:\n            fmt.Println(\"tick.\")\n        case <-boom:\n            fmt.Println(\"BOOM!\")\n            return\n        default:\n            fmt.Println(\"    .\")\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"example-equivalent-binary-trees\"\n    }}>{`Example: Equivalent Binary Trees`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n  \"golang.org/x/tour/tree\"\n  \"fmt\"\n)\n\n// Walk walks the tree t sending all values\n// from the tree to the channel ch.\nfunc Walk(t *tree.Tree, ch chan int) {\n    defer close(ch) // <- closes the channel when this function returns\n  var walk func(t *tree.Tree)\n  walk = func(t *tree.Tree) {\n      if t == nil {\n          return\n      }\n      walk(t.Left)\n      ch <- t.Value\n      walk(t.Right)\n  }\n  walk(t)\n}\n\n// Same determines whether the trees\n// t1 and t2 contain the same values.\nfunc Same(t1, t2 *tree.Tree) bool {\n    done := make (chan bool)\n    defer close(done)\n\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go Walk(t1, ch1)\n    go Walk(t2, ch2)\n\n    go func() {\n        for i := range ch1 {\n            j := <-ch2\n            fmt.Println(\"i: %v\", i)\n            fmt.Println(\"j: %v\", j)\n\n            if i != j {\n                done <- false\n            }\n        }\n        done <- true\n    }()\n    return <-done\n}\n\nfunc main() {\n    ch := make(chan int)\n    go Walk(tree.New(1), ch)\n\n    for i := 1; i <= 10; i++ {\n        fmt.Println(<-ch)\n    }\n\n    t1 := tree.New(1)\n    t2 := tree.New(2)\n\n    res1 := Same(t1, t1)\n    fmt.Println(\"Res 1: %v\", res1)\n\n    res2 := Same(t1, t2)\n    fmt.Println(\"Res 2: %v\", res2)\n}\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}