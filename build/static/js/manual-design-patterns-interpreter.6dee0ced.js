(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{"./manual/Design-Patterns/Interpreter.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return o});var r=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),a=(t("./node_modules/react/index.js"),t("./node_modules/@mdx-js/react/dist/index.es.js")),s={},i="wrapper";function o(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)(i,Object.assign({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"interpreter-design-pattern"},"Interpreter Design Pattern"),Object(a.b)("p",null,"Purpose: Behavioural\nType: Class"),Object(a.b)("p",null,"The Interpreter Design Pattern specifies how to evaluate sentences in a string."),Object(a.b)("p",null,"The idea is to have a class for each symbol. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (intrepret) the sentence for a client."),Object(a.b)("h2",{id:"participants"},"Participants"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"AbstractExpression (declares interpret method common to all nodes)"),Object(a.b)("li",{parentName:"ul"},"TerminalExpression (interpret terminal symbols in the grammar)"),Object(a.b)("li",{parentName:"ul"},"NonTerminalExpression (maintains instance variables of type AbstractExpression for nonterminal symbols in grammar)"),Object(a.b)("li",{parentName:"ul"},"Context (info global to interpreter)"),Object(a.b)("li",{parentName:"ul"},"Client (builds abstract syntax tree representing a particular sentence in the language that the grammar defines)")),Object(a.b)("h2",{id:"example"},"Example"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-typescript"}),"class Context {\n  private _input;\n\n  constructor(input) {\n    this._input = input;\n  }\n\n  public set input(value) {\n    this._input = value;\n  }\n}\n\ninterface Expression {\n  interpret(context: Context): void;\n}\n\nclass TerminalExpression implements Expression {\n  interpret(context: Context): void {\n    // process comma\n    console.log('interpret terminal');\n  }\n}\n\nclass NoneTerminalExpression implements Expression {\n  interpret(context: Context): void {\n    // process variable\n    console.log('interpret nonterminal');\n  }\n}\n\n(function main() {\n  const context: Context = new Context('1 bird can fly');\n  const list = [];\n  list.push(new TerminalExpression());\n  list.push(new NoneTerminalExpression());\n\n  list.map((exp: Expression) => {\n    exp.interpret(context);\n  });\n})();\n")),Object(a.b)("h2",{id:"resources"},"Resources"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://ruslanspivak.com/lsbasi-part7/"}),"AST in action")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://www.baeldung.com/java-interpreter-pattern"}),"Java Interpreter for SQL"))))}o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/Design-Patterns/Interpreter.md"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-design-patterns-interpreter.101a1afd2417ec7a4a77.js.map