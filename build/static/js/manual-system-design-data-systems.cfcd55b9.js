(window.webpackJsonp=window.webpackJsonp||[]).push([[483],{"./manual/System-Design/Data-Systems.md":function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return r});var l=a("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),s=(a("./node_modules/react/index.js"),a("./node_modules/@mdx-js/react/dist/index.es.js")),i={},n="wrapper";function r(e){var t=e.components,a=Object(l.a)(e,["components"]);return Object(s.b)(n,Object.assign({},i,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h1",{id:"data-systems"},"Data Systems"),Object(s.b)("h2",{id:"basics"},"Basics"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The aim is to keep them: Reliable, Scalable and Maintainable"),Object(s.b)("li",{parentName:"ul"},"Data Systems knowledge includes understanding caches, search indexes, stream/batch processing")),Object(s.b)("h3",{id:"reliability"},"Reliability"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Keeping data correctness, completeness across systems, performant and resilient."),Object(s.b)("li",{parentName:"ul"},"Fault vs Failure: Fault is a system failing to adhere to a design spec whereas failure means a system failure and requires failover backup procedures."),Object(s.b)("li",{parentName:"ul"},"It's better to measure the latency in percentiles.")),Object(s.b)("h3",{id:"scalability"},"Scalability"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"For many backends, the response time is dependent on the slowest server response."),Object(s.b)("li",{parentName:"ul"},"Elastic vs manual scaling: one is automated.")),Object(s.b)("p",null,"The architecture for each large scale project is highly specific. It depends on factors such as:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"Volume of reads"),Object(s.b)("li",{parentName:"ol"},"Volume of writes"),Object(s.b)("li",{parentName:"ol"},"Type of data to stor"),Object(s.b)("li",{parentName:"ol"},"Data complexity"),Object(s.b)("li",{parentName:"ol"},"Response time"),Object(s.b)("li",{parentName:"ol"},"Access patterns")),Object(s.b)("p",null,"Example: You could expect 100,000 req/s @ 1kB in size vs 3 req/s @ 2GB in size which equates to the same data throughput but very different requirements."),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Load parameters identify which requests are common vs which ones are rare.")),Object(s.b)("h3",{id:"maintainability"},"Maintainability"),Object(s.b)("p",null,"Remember these three principles:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"Operability"),Object(s.b)("li",{parentName:"ol"},"Simplicity (- think abstractions like SQL)"),Object(s.b)("li",{parentName:"ol"},"Evolvability")),Object(s.b)("h2",{id:"data-models"},"Data Models"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Relational"),Object(s.b)("li",{parentName:"ul"},"Document"),Object(s.b)("li",{parentName:"ul"},"Graph (this is essentially a subtype of relational)")),Object(s.b)("h3",{id:"pros-of-the-document-model"},"Pros of the Document Model"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Schema flexibility"),Object(s.b)("li",{parentName:"ul"},"Better performance due to locality"),Object(s.b)("li",{parentName:"ul"},"Apps are generally closer to the data structure")),Object(s.b)("h2",{id:"storage--retrieval"},"Storage + Retrieval"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Big difference in storage engines that are optimized for transactional vs analytical (think OLTP/OLAP)"),Object(s.b)("li",{parentName:"ul"},"Indexes help find keys but generally slow down writes"),Object(s.b)("li",{parentName:"ul"},"In-memory tress: examples red-black trees, AVL trees. We can make the storage engines to use these styles of trees."),Object(s.b)("li",{parentName:"ul"},"LSM Trees can be slow when looking up keys that don't exist",Object(s.b)("ul",{parentName:"li"},Object(s.b)("li",{parentName:"ul"},'Can be countered by "Bloom Filters" -> can tell if the key exists.')))),Object(s.b)("h3",{id:"b-trees"},"B-Trees"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Most common index used by databases."),Object(s.b)("li",{parentName:"ul"},'While log-structured indexes work in variable-size segments and written sequentially, B-Trees have fixed sized "blocks" or "pages" - this design corresponds to reflecting the underlying hardware.'),Object(s.b)("li",{parentName:"ul"},'B-Tree variant "fractal trees" borrow log-structured ideas to reduce disk seeks.')),Object(s.b)("h3",{id:"b-trees-vs-lsm-trees"},"B-Trees vs LSM-Trees"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"B-Tree more mature"),Object(s.b)("li",{parentName:"ul"},"LSM faster for writes"),Object(s.b)("li",{parentName:"ul"},"B faster for reads"),Object(s.b)("li",{parentName:"ul"},"B-Tree must write everything twice (write-ahead log and potential multi-writes to tree pages)"),Object(s.b)("li",{parentName:"ul"},'Log structured indexes also rewrite data multiple times. This is known as "write amplification" and is a concern for SSDs.'),Object(s.b)("li",{parentName:"ul"},"LSM trees compress files better")),Object(s.b)("h3",{id:"the-downsides-of-lsm-trees"},"The downsides of LSM-Trees"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Compaction process can sometimes interfere with ongoing reads/writes.")),Object(s.b)("h3",{id:"other-notes"},"Other notes"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Secondary index normally not unique (consider the use of ",Object(s.b)("inlineCode",{parentName:"li"},"user_id"),")"),Object(s.b)("li",{parentName:"ul"},"R-Trees normally used for optimised geospatial query efficiency."),Object(s.b)("li",{parentName:"ul"},"LSM-Trees themselves do not handle updating. They essentially can only append and remove the stale data. B-Trees can update in place.")),Object(s.b)("h3",{id:"olap-vs-oltp"},"OLAP vs OLTP"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},'A transaction needn\'t adhere to all principles of ACID. "Transaction" processing mean low latency read/writes.'),Object(s.b)("li",{parentName:"ul"},"Commonly used with relational databases."),Object(s.b)("li",{parentName:"ul"},"Performance can be improved using vectorized processing (SIMD - single instruction multi data)",Object(s.b)("ul",{parentName:"li"},Object(s.b)("li",{parentName:"ul"},"Column compression can also make use of the L1 cache."),Object(s.b)("li",{parentName:"ul"},"Update-in-place like what B-Trees use are not possible with column compression.")))))}r&&r===Object(r)&&Object.isExtensible(r)&&Object.defineProperty(r,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/System-Design/Data-Systems.md"}}),r.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-system-design-data-systems.101a1afd2417ec7a4a77.js.map