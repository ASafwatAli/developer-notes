(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{"./manual/COMP3306-AI/3-A*-Algorithm.md":function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return o});var n=a("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),i=(a("./node_modules/react/index.js"),a("./node_modules/@mdx-js/react/dist/index.es.js")),l={},b="wrapper";function o(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(i.b)(b,Object.assign({},l,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"week-3---a-algorithm"},"Week 3 - A","*"," Algorithm"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object.assign({parentName:"li"},{href:"#week-3---a-algorithm"}),"Week 3 - A","*"," Algorithm"),"\n- ",Object(i.b)("a",Object.assign({parentName:"li"},{href:"#a-search"}),"A","*"," Search"),"\n- ",Object(i.b)("a",Object.assign({parentName:"li"},{href:"#admissible-heauristic"}),"Admissible Heauristic"),"\n- ",Object(i.b)("a",Object.assign({parentName:"li"},{href:"#optimality-of-a---proof"}),"Optimality of A","*"," - Proof"),"\n- ",Object(i.b)("a",Object.assign({parentName:"li"},{href:"#dominance"}),"Dominance"))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Aims")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A","*"," search algorithm"),Object(i.b)("li",{parentName:"ul"},"How to invent admissible heuristics")),Object(i.b)("h2",{id:"a-search"},"A","*"," Search"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"UCS minimizes the cost so far ",Object(i.b)("inlineCode",{parentName:"li"},"g(n)")),Object(i.b)("li",{parentName:"ul"},"GS minimizes the estimated cost to the goal ",Object(i.b)("inlineCode",{parentName:"li"},"h(n)")),Object(i.b)("li",{parentName:"ul"},"A","*"," combining UCS and GS"),Object(i.b)("li",{parentName:"ul"},"Evaluation function: ",Object(i.b)("inlineCode",{parentName:"li"},"f(n)=g(n)+h(n)")," - ",Object(i.b)("inlineCode",{parentName:"li"},"g(n) = cost so far to reach n")," - ",Object(i.b)("inlineCode",{parentName:"li"},"h(n) = est. cost from n to goal")," - ",Object(i.b)("inlineCode",{parentName:"li"},"f(n) = est. total cost of path through n to the goal"))),Object(i.b)("p",null,"The idea is that we take into account both the cost and estimated cost and combine them to decide which nodes to add to the fringe queue!"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"BFS and UCS Special Case")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"BFS is a special case of A","*"," when f(n)=depth(n)"),Object(i.b)("li",{parentName:"ul"},"BFS is also a special case of UCS when g(n)=depth(n)"),Object(i.b)("li",{parentName:"ul"},"UCS is a special case of A","*"," when h(n)=0")),Object(i.b)("h2",{id:"admissible-heauristic"},"Admissible Heauristic"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Heuristic ",Object(i.b)("inlineCode",{parentName:"li"},"h(n)")," is admissible if for every node n: - ",Object(i.b)("inlineCode",{parentName:"li"},"h(n) <= h*(n)")," where ",Object(i.b)("inlineCode",{parentName:"li"},"h*(n)")," is the true cost to reach a goal from ",Object(i.b)("inlineCode",{parentName:"li"},"n")," - The estimate to reach the goal is smaller or equal to the true cost to reach the goal"),Object(i.b)("li",{parentName:"ul"},"Admissible heuristics are ",Object(i.b)("inlineCode",{parentName:"li"},"optimistic")," - they think that the cost of solving the problem is less than it actually is. - heuristic never overestimates actual cost -> it is admissible")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Theorem")),Object(i.b)("p",null,"If ",Object(i.b)("inlineCode",{parentName:"p"},"h")," is an ",Object(i.b)("inlineCode",{parentName:"p"},"admissible heuristic")," than A","*"," is complete and optimal."),Object(i.b)("p",null,"How to check?"),Object(i.b)("p",null,"See if the estimated cost for a node is <= the actual cost from that node to the goal node."),Object(i.b)("h2",{id:"optimality-of-a---proof"},"Optimality of A","*"," - Proof"),Object(i.b)("p",null,"Compare f(G2) and f(G)"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"f(G2)=g(G2)+h(G2) (by definition) = g(G2) as h(G2)=0, G2 is a goal"),Object(i.b)("li",{parentName:"ol"},"f(G)=g(G)+h(G) (by definition) = g(G) as h(G)=0, G is a goal"),Object(i.b)("li",{parentName:"ol"},"g(G2)>g(G) as G2 is suboptimal"),Object(i.b)("li",{parentName:"ol"},"=> f(G2)>f(G) by substituting 1) and 2) into 3)"),Object(i.b)("li",{parentName:"ol"},"f(n)=g(n)+h(n) (by definition)"),Object(i.b)("li",{parentName:"ol"},"h(n) <= h",Object(i.b)("em",{parentName:"li"},"(n) where h"),"(n) is the true cost from n to G (as h is admissible)"),Object(i.b)("li",{parentName:"ol"},"=> f(n)<=g(n) + h","*","(n) (5 & 6)"),Object(i.b)("li",{parentName:"ol"},"= g(G) path cost from S to G via n"),Object(i.b)("li",{parentName:"ol"},"g(G) = f(G) as f(G)=g(G)+h(G)=g(G)+0 as h(G)=0, G is a goal"),Object(i.b)("li",{parentName:"ol"},"=> f(n)<=f(G) (7,8,9)",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Thus f(G)<f(G2) (4) & f(n)<=f(G) (10)"))),Object(i.b)("li",{parentName:"ol"},"f(n)<=f(G)<f(G2) (10, 4)"),Object(i.b)("li",{parentName:"ol"},"f(n)<f(G2) => n will be expanded not G2; A","*"," will not select G2 for expansion")),Object(i.b)("h2",{id:"dominance"},"Dominance"),Object(i.b)("p",null,"Two admissibleheuristics h(1) and h(2)"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"h[2]")," dominates ",Object(i.b)("inlineCode",{parentName:"li"},"h[1]")," if for all nodes ",Object(i.b)("inlineCode",{parentName:"li"},"n")," we have ",Object(i.b)("inlineCode",{parentName:"li"},"h[2](n) >= h[1](n)"))))}o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"manual/COMP3306-AI/3-A*-Algorithm.md"}}),o.isMDXComponent=!0}}]);
//# sourceMappingURL=manual-com-p3306-ai-3-a-algorithm.101a1afd2417ec7a4a77.js.map