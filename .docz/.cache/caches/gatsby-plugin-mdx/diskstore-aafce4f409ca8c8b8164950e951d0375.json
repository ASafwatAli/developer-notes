{"expireTime":9007200839169080000,"key":"gatsby-plugin-mdx-entire-payload-5a1592cc89f83207407744cc72f61fd9-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Haskell From First Principles","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":32,"offset":198},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":32,"offset":198},"indent":[]}},{"type":"import","value":"import 'katex/dist/katex.min.css';\nimport { BlockMath } from 'react-katex';","position":{"start":{"line":10,"column":1,"offset":200},"end":{"line":11,"column":41,"offset":275},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":13,"column":4,"offset":280},"end":{"line":13,"column":13,"offset":289},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":277},"end":{"line":13,"column":13,"offset":289},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf","children":[{"type":"text","value":"A Tutorial Intro to Lambda Calculus","position":{"start":{"line":15,"column":5,"offset":295},"end":{"line":15,"column":40,"offset":330},"indent":[]}}],"position":{"start":{"line":15,"column":4,"offset":294},"end":{"line":15,"column":98,"offset":388},"indent":[]}}],"position":{"start":{"line":15,"column":4,"offset":294},"end":{"line":15,"column":98,"offset":388},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":291},"end":{"line":15,"column":98,"offset":388},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":291},"end":{"line":15,"column":98,"offset":388},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"What is a function","position":{"start":{"line":17,"column":4,"offset":393},"end":{"line":17,"column":22,"offset":411},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":390},"end":{"line":17,"column":22,"offset":411},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"A set of possible inputs and a set of possible outputs","position":{"start":{"line":19,"column":3,"offset":415},"end":{"line":19,"column":57,"offset":469},"indent":[]}}],"position":{"start":{"line":19,"column":3,"offset":415},"end":{"line":19,"column":57,"offset":469},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":413},"end":{"line":19,"column":57,"offset":469},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"f(1) = A\" />\n<BlockMath math=\"f(2) = B\" />\n<BlockMath math=\"f(3) = C\" />","position":{"start":{"line":21,"column":1,"offset":471},"end":{"line":23,"column":30,"offset":560},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The input set (domain) is ","position":{"start":{"line":25,"column":1,"offset":562},"end":{"line":25,"column":27,"offset":588},"indent":[]}},{"type":"inlineCode","value":"{1,2,3}","position":{"start":{"line":25,"column":27,"offset":588},"end":{"line":25,"column":36,"offset":597},"indent":[]}},{"type":"text","value":" and the output set (codomain) is ","position":{"start":{"line":25,"column":36,"offset":597},"end":{"line":25,"column":70,"offset":631},"indent":[]}},{"type":"inlineCode","value":"{A,B,C}","position":{"start":{"line":25,"column":70,"offset":631},"end":{"line":25,"column":79,"offset":640},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":25,"column":79,"offset":640},"end":{"line":25,"column":80,"offset":641},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":562},"end":{"line":25,"column":80,"offset":641},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In our function, an input of ","position":{"start":{"line":27,"column":1,"offset":643},"end":{"line":27,"column":30,"offset":672},"indent":[]}},{"type":"inlineCode","value":"1","position":{"start":{"line":27,"column":30,"offset":672},"end":{"line":27,"column":33,"offset":675},"indent":[]}},{"type":"text","value":" will ALWAYS return ","position":{"start":{"line":27,"column":33,"offset":675},"end":{"line":27,"column":53,"offset":695},"indent":[]}},{"type":"inlineCode","value":"A","position":{"start":{"line":27,"column":53,"offset":695},"end":{"line":27,"column":56,"offset":698},"indent":[]}},{"type":"text","value":", no exceptions.","position":{"start":{"line":27,"column":56,"offset":698},"end":{"line":27,"column":72,"offset":714},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":643},"end":{"line":27,"column":72,"offset":714},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Lambda termd","position":{"start":{"line":29,"column":4,"offset":719},"end":{"line":29,"column":16,"offset":731},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":716},"end":{"line":29,"column":16,"offset":731},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Lambda calculus has three basic components:","position":{"start":{"line":31,"column":1,"offset":733},"end":{"line":31,"column":44,"offset":776},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":733},"end":{"line":31,"column":44,"offset":776},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Expressions","position":{"start":{"line":33,"column":4,"offset":781},"end":{"line":33,"column":15,"offset":792},"indent":[]}}],"position":{"start":{"line":33,"column":4,"offset":781},"end":{"line":33,"column":15,"offset":792},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":778},"end":{"line":33,"column":15,"offset":792},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Variables","position":{"start":{"line":34,"column":4,"offset":796},"end":{"line":34,"column":13,"offset":805},"indent":[]}}],"position":{"start":{"line":34,"column":4,"offset":796},"end":{"line":34,"column":13,"offset":805},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":793},"end":{"line":34,"column":13,"offset":805},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Abstractions","position":{"start":{"line":35,"column":4,"offset":809},"end":{"line":35,"column":16,"offset":821},"indent":[]}}],"position":{"start":{"line":35,"column":4,"offset":809},"end":{"line":35,"column":16,"offset":821},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":806},"end":{"line":35,"column":16,"offset":821},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":778},"end":{"line":35,"column":16,"offset":821},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The word ","position":{"start":{"line":37,"column":1,"offset":823},"end":{"line":37,"column":10,"offset":832},"indent":[]}},{"type":"inlineCode","value":"expression","position":{"start":{"line":37,"column":10,"offset":832},"end":{"line":37,"column":22,"offset":844},"indent":[]}},{"type":"text","value":" refers to a superset of those things. It can be a variable name, an abstraction or a combination of those things.","position":{"start":{"line":37,"column":22,"offset":844},"end":{"line":37,"column":136,"offset":958},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":823},"end":{"line":37,"column":136,"offset":958},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"An ","position":{"start":{"line":39,"column":1,"offset":960},"end":{"line":39,"column":4,"offset":963},"indent":[]}},{"type":"inlineCode","value":"abstraction","position":{"start":{"line":39,"column":4,"offset":963},"end":{"line":39,"column":17,"offset":976},"indent":[]}},{"type":"text","value":" is a function. It is a lambda term that has a head (a lambda) and a body and is applied to an argument. An ","position":{"start":{"line":39,"column":17,"offset":976},"end":{"line":39,"column":125,"offset":1084},"indent":[]}},{"type":"inlineCode","value":"argument","position":{"start":{"line":39,"column":125,"offset":1084},"end":{"line":39,"column":135,"offset":1094},"indent":[]}},{"type":"text","value":" is an input value.","position":{"start":{"line":39,"column":135,"offset":1094},"end":{"line":39,"column":154,"offset":1113},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":960},"end":{"line":39,"column":154,"offset":1113},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Abstractions consist of the ","position":{"start":{"line":41,"column":1,"offset":1115},"end":{"line":41,"column":29,"offset":1143},"indent":[]}},{"type":"inlineCode","value":"head","position":{"start":{"line":41,"column":29,"offset":1143},"end":{"line":41,"column":35,"offset":1149},"indent":[]}},{"type":"text","value":" and the ","position":{"start":{"line":41,"column":35,"offset":1149},"end":{"line":41,"column":44,"offset":1158},"indent":[]}},{"type":"inlineCode","value":"body","position":{"start":{"line":41,"column":44,"offset":1158},"end":{"line":41,"column":50,"offset":1164},"indent":[]}},{"type":"text","value":". The head of the function is a lambda followed by a variable name. The body of the function is another expression.","position":{"start":{"line":41,"column":50,"offset":1164},"end":{"line":41,"column":165,"offset":1279},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":1115},"end":{"line":41,"column":165,"offset":1279},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A simple function might look like this:","position":{"start":{"line":43,"column":1,"offset":1281},"end":{"line":43,"column":40,"offset":1320},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":1281},"end":{"line":43,"column":40,"offset":1320},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.x\" />","position":{"start":{"line":45,"column":1,"offset":1322},"end":{"line":45,"column":33,"offset":1354},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The variable named in the head is the ","position":{"start":{"line":47,"column":1,"offset":1356},"end":{"line":47,"column":39,"offset":1394},"indent":[]}},{"type":"inlineCode","value":"parameter","position":{"start":{"line":47,"column":39,"offset":1394},"end":{"line":47,"column":50,"offset":1405},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":47,"column":50,"offset":1405},"end":{"line":47,"column":55,"offset":1410},"indent":[]}},{"type":"inlineCode","value":"binds","position":{"start":{"line":47,"column":55,"offset":1410},"end":{"line":47,"column":62,"offset":1417},"indent":[]}},{"type":"text","value":" all instances of that same variable in the body of the function. In laymen terms, when we apply this function to an argument, each ","position":{"start":{"line":47,"column":62,"offset":1417},"end":{"line":47,"column":194,"offset":1549},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":47,"column":194,"offset":1549},"end":{"line":47,"column":197,"offset":1552},"indent":[]}},{"type":"text","value":" in the body of the function will have the value of that argument.","position":{"start":{"line":47,"column":197,"offset":1552},"end":{"line":47,"column":263,"offset":1618},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":1356},"end":{"line":47,"column":263,"offset":1618},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the above, we were reference functions called ","position":{"start":{"line":49,"column":1,"offset":1620},"end":{"line":49,"column":50,"offset":1669},"indent":[]}},{"type":"inlineCode","value":"f","position":{"start":{"line":49,"column":50,"offset":1669},"end":{"line":49,"column":53,"offset":1672},"indent":[]}},{"type":"text","value":", but in the previous section the lambda astraction has no name and is an ","position":{"start":{"line":49,"column":53,"offset":1672},"end":{"line":49,"column":127,"offset":1746},"indent":[]}},{"type":"inlineCode","value":"anonymous function","position":{"start":{"line":49,"column":127,"offset":1746},"end":{"line":49,"column":147,"offset":1766},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":49,"column":147,"offset":1766},"end":{"line":49,"column":148,"offset":1767},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":1620},"end":{"line":49,"column":148,"offset":1767},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A named function can be called by name by another function, a lambda cannot.","position":{"start":{"line":51,"column":1,"offset":1769},"end":{"line":51,"column":77,"offset":1845},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":1769},"end":{"line":51,"column":77,"offset":1845},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Breakdown of the lambda","position":{"start":{"line":53,"column":5,"offset":1851},"end":{"line":53,"column":28,"offset":1874},"indent":[]}}],"position":{"start":{"line":53,"column":1,"offset":1847},"end":{"line":53,"column":28,"offset":1874},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The extent of the lambda:","position":{"start":{"line":55,"column":1,"offset":1876},"end":{"line":55,"column":26,"offset":1901},"indent":[]}}],"position":{"start":{"line":55,"column":1,"offset":1876},"end":{"line":55,"column":26,"offset":1901},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.\" />","position":{"start":{"line":57,"column":1,"offset":1903},"end":{"line":57,"column":32,"offset":1934},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first ","position":{"start":{"line":59,"column":1,"offset":1936},"end":{"line":59,"column":11,"offset":1946},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":59,"column":11,"offset":1946},"end":{"line":59,"column":14,"offset":1949},"indent":[]}},{"type":"text","value":" is the single parameter of the function. This binds an variables:","position":{"start":{"line":59,"column":14,"offset":1949},"end":{"line":59,"column":80,"offset":2015},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":1936},"end":{"line":59,"column":80,"offset":2015},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The second ","position":{"start":{"line":61,"column":1,"offset":2017},"end":{"line":61,"column":12,"offset":2028},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":61,"column":12,"offset":2028},"end":{"line":61,"column":15,"offset":2031},"indent":[]}},{"type":"text","value":" is part of the body, the expression the lambda returns when applied. This is a bound variable.","position":{"start":{"line":61,"column":15,"offset":2031},"end":{"line":61,"column":110,"offset":2126},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":2017},"end":{"line":61,"column":110,"offset":2126},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":63,"column":1,"offset":2128},"end":{"line":63,"column":5,"offset":2132},"indent":[]}},{"type":"inlineCode","value":".","position":{"start":{"line":63,"column":5,"offset":2132},"end":{"line":63,"column":8,"offset":2135},"indent":[]}},{"type":"text","value":" separates the parameters of the lambda from the function body.","position":{"start":{"line":63,"column":8,"offset":2135},"end":{"line":63,"column":71,"offset":2198},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":2128},"end":{"line":63,"column":71,"offset":2198},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Alpha Equivalence","position":{"start":{"line":65,"column":4,"offset":2203},"end":{"line":65,"column":21,"offset":2220},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":2200},"end":{"line":65,"column":21,"offset":2220},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.x\" />","position":{"start":{"line":67,"column":1,"offset":2222},"end":{"line":67,"column":33,"offset":2254},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the above expression, the variable ","position":{"start":{"line":69,"column":1,"offset":2256},"end":{"line":69,"column":39,"offset":2294},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":69,"column":39,"offset":2294},"end":{"line":69,"column":42,"offset":2297},"indent":[]}},{"type":"text","value":" is not semantically meaningful except in its role in that single expression. Because of this, there's a form of equivalence between lambda terms called ","position":{"start":{"line":69,"column":42,"offset":2297},"end":{"line":69,"column":195,"offset":2450},"indent":[]}},{"type":"inlineCode","value":"alpha equivalence","position":{"start":{"line":69,"column":195,"offset":2450},"end":{"line":69,"column":214,"offset":2469},"indent":[]}},{"type":"text","value":". This is a way of saying:","position":{"start":{"line":69,"column":214,"offset":2469},"end":{"line":69,"column":240,"offset":2495},"indent":[]}}],"position":{"start":{"line":69,"column":1,"offset":2256},"end":{"line":69,"column":240,"offset":2495},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.x = \\lambda d.d = \\lambda z.z\" />","position":{"start":{"line":71,"column":1,"offset":2497},"end":{"line":71,"column":61,"offset":2557},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Beta reduction","position":{"start":{"line":73,"column":4,"offset":2562},"end":{"line":73,"column":18,"offset":2576},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":2559},"end":{"line":73,"column":18,"offset":2576},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When we apply a function to an argument, we substitute the input expression for all instances of the bound variables within the body of the abstraction. You also eliminate the head of the abstraction, since its only purpose was to bind the variable. This is called ","position":{"start":{"line":75,"column":1,"offset":2578},"end":{"line":75,"column":266,"offset":2843},"indent":[]}},{"type":"inlineCode","value":"beta reduction","position":{"start":{"line":75,"column":266,"offset":2843},"end":{"line":75,"column":282,"offset":2859},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":75,"column":282,"offset":2859},"end":{"line":75,"column":283,"offset":2860},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":2578},"end":{"line":75,"column":283,"offset":2860},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can do one using a number. We apply the function above to ","position":{"start":{"line":77,"column":1,"offset":2862},"end":{"line":77,"column":62,"offset":2923},"indent":[]}},{"type":"inlineCode","value":"2","position":{"start":{"line":77,"column":62,"offset":2923},"end":{"line":77,"column":65,"offset":2926},"indent":[]}},{"type":"text","value":", substitude ","position":{"start":{"line":77,"column":65,"offset":2926},"end":{"line":77,"column":78,"offset":2939},"indent":[]}},{"type":"inlineCode","value":"2","position":{"start":{"line":77,"column":78,"offset":2939},"end":{"line":77,"column":81,"offset":2942},"indent":[]}},{"type":"text","value":" for each bound variable in the body of the function and eliminate the head:","position":{"start":{"line":77,"column":81,"offset":2942},"end":{"line":77,"column":157,"offset":3018},"indent":[]}}],"position":{"start":{"line":77,"column":1,"offset":2862},"end":{"line":77,"column":157,"offset":3018},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"( \\lambda x.x ) 2 = 2\" />","position":{"start":{"line":79,"column":1,"offset":3020},"end":{"line":79,"column":43,"offset":3062},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The only bound variable is a single ","position":{"start":{"line":81,"column":1,"offset":3064},"end":{"line":81,"column":37,"offset":3100},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":81,"column":37,"offset":3100},"end":{"line":81,"column":40,"offset":3103},"indent":[]}},{"type":"text","value":", so applying this function to 2 returns 2. This function is the ","position":{"start":{"line":81,"column":40,"offset":3103},"end":{"line":81,"column":105,"offset":3168},"indent":[]}},{"type":"inlineCode","value":"identity","position":{"start":{"line":81,"column":105,"offset":3168},"end":{"line":81,"column":115,"offset":3178},"indent":[]}},{"type":"text","value":" function.","position":{"start":{"line":81,"column":115,"offset":3178},"end":{"line":81,"column":125,"offset":3188},"indent":[]}}],"position":{"start":{"line":81,"column":1,"offset":3064},"end":{"line":81,"column":125,"offset":3188},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Free variables","position":{"start":{"line":83,"column":4,"offset":3193},"end":{"line":83,"column":18,"offset":3207},"indent":[]}}],"position":{"start":{"line":83,"column":1,"offset":3190},"end":{"line":83,"column":18,"offset":3207},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.xy\" />","position":{"start":{"line":85,"column":1,"offset":3209},"end":{"line":85,"column":34,"offset":3242},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this example, ","position":{"start":{"line":87,"column":1,"offset":3244},"end":{"line":87,"column":18,"offset":3261},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":87,"column":18,"offset":3261},"end":{"line":87,"column":21,"offset":3264},"indent":[]}},{"type":"text","value":" is a bound variable, ","position":{"start":{"line":87,"column":21,"offset":3264},"end":{"line":87,"column":43,"offset":3286},"indent":[]}},{"type":"inlineCode","value":"y","position":{"start":{"line":87,"column":43,"offset":3286},"end":{"line":87,"column":46,"offset":3289},"indent":[]}},{"type":"text","value":" is a free variable.","position":{"start":{"line":87,"column":46,"offset":3289},"end":{"line":87,"column":66,"offset":3309},"indent":[]}}],"position":{"start":{"line":87,"column":1,"offset":3244},"end":{"line":87,"column":66,"offset":3309},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Multiple arguments","position":{"start":{"line":89,"column":4,"offset":3314},"end":{"line":89,"column":22,"offset":3332},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":3311},"end":{"line":89,"column":22,"offset":3332},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Each lambda can only bind one parameter and can only accept one argument. Functions that require multiple arguments have multiple, nested heads. When you apply it once and eliminate the first (leftmost) head, the next is applied and so on. It is know as ","position":{"start":{"line":91,"column":3,"offset":3336},"end":{"line":91,"column":257,"offset":3590},"indent":[]}},{"type":"inlineCode","value":"currying","position":{"start":{"line":91,"column":257,"offset":3590},"end":{"line":91,"column":267,"offset":3600},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":91,"column":267,"offset":3600},"end":{"line":91,"column":268,"offset":3601},"indent":[]}}],"position":{"start":{"line":91,"column":3,"offset":3336},"end":{"line":91,"column":268,"offset":3601},"indent":[]}}],"position":{"start":{"line":91,"column":1,"offset":3334},"end":{"line":91,"column":268,"offset":3601},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Evaluation is simplication","position":{"start":{"line":93,"column":4,"offset":3606},"end":{"line":93,"column":30,"offset":3632},"indent":[]}}],"position":{"start":{"line":93,"column":1,"offset":3603},"end":{"line":93,"column":30,"offset":3632},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are multiple normal forms in lambda calculus, but here when we refer to normal form we mean ","position":{"start":{"line":95,"column":1,"offset":3634},"end":{"line":95,"column":99,"offset":3732},"indent":[]}},{"type":"inlineCode","value":"beta normal form","position":{"start":{"line":95,"column":99,"offset":3732},"end":{"line":95,"column":117,"offset":3750},"indent":[]}},{"type":"text","value":". This corresponds to a fully evaluated expression (or a fully executed program). For example, do you say ","position":{"start":{"line":95,"column":117,"offset":3750},"end":{"line":95,"column":223,"offset":3856},"indent":[]}},{"type":"inlineCode","value":"2000/1000","position":{"start":{"line":95,"column":223,"offset":3856},"end":{"line":95,"column":234,"offset":3867},"indent":[]}},{"type":"text","value":" or do you say 2? You say 2. The normal form of the evaluated expression is therefore 2.","position":{"start":{"line":95,"column":234,"offset":3867},"end":{"line":95,"column":322,"offset":3955},"indent":[]}}],"position":{"start":{"line":95,"column":1,"offset":3634},"end":{"line":95,"column":322,"offset":3955},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Note: if we had function ","position":{"start":{"line":97,"column":1,"offset":3957},"end":{"line":97,"column":26,"offset":3982},"indent":[]}},{"type":"inlineCode","value":"(x,y) => x/y","position":{"start":{"line":97,"column":26,"offset":3982},"end":{"line":97,"column":40,"offset":3996},"indent":[]}},{"type":"text","value":" and apply ","position":{"start":{"line":97,"column":40,"offset":3996},"end":{"line":97,"column":51,"offset":4007},"indent":[]}},{"type":"inlineCode","value":"x = 2000","position":{"start":{"line":97,"column":51,"offset":4007},"end":{"line":97,"column":61,"offset":4017},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":97,"column":61,"offset":4017},"end":{"line":97,"column":66,"offset":4022},"indent":[]}},{"type":"inlineCode","value":"y = 1000","position":{"start":{"line":97,"column":66,"offset":4022},"end":{"line":97,"column":76,"offset":4032},"indent":[]}},{"type":"text","value":", we call the the body with all arguments applied ","position":{"start":{"line":97,"column":76,"offset":4032},"end":{"line":97,"column":126,"offset":4082},"indent":[]}},{"type":"inlineCode","value":"saturated","position":{"start":{"line":97,"column":126,"offset":4082},"end":{"line":97,"column":137,"offset":4093},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":97,"column":137,"offset":4093},"end":{"line":97,"column":138,"offset":4094},"indent":[]}}],"position":{"start":{"line":97,"column":1,"offset":3957},"end":{"line":97,"column":138,"offset":4094},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Combinators","position":{"start":{"line":99,"column":4,"offset":4099},"end":{"line":99,"column":15,"offset":4110},"indent":[]}}],"position":{"start":{"line":99,"column":1,"offset":4096},"end":{"line":99,"column":15,"offset":4110},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A ","position":{"start":{"line":101,"column":1,"offset":4112},"end":{"line":101,"column":3,"offset":4114},"indent":[]}},{"type":"inlineCode","value":"combinator","position":{"start":{"line":101,"column":3,"offset":4114},"end":{"line":101,"column":15,"offset":4126},"indent":[]}},{"type":"text","value":" is a lambda term with no free variables. Combinators, as the name suggests, serve only to ","position":{"start":{"line":101,"column":15,"offset":4126},"end":{"line":101,"column":106,"offset":4217},"indent":[]}},{"type":"inlineCode","value":"combine","position":{"start":{"line":101,"column":106,"offset":4217},"end":{"line":101,"column":115,"offset":4226},"indent":[]}},{"type":"text","value":" the arguments that they are given.","position":{"start":{"line":101,"column":115,"offset":4226},"end":{"line":101,"column":150,"offset":4261},"indent":[]}}],"position":{"start":{"line":101,"column":1,"offset":4112},"end":{"line":101,"column":150,"offset":4261},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Divergence","position":{"start":{"line":103,"column":4,"offset":4266},"end":{"line":103,"column":14,"offset":4276},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":4263},"end":{"line":103,"column":14,"offset":4276},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Not all reducible lambda terms reduce neatly to a beta normal form. Reducing the following repeats itself:","position":{"start":{"line":105,"column":1,"offset":4278},"end":{"line":105,"column":107,"offset":4384},"indent":[]}}],"position":{"start":{"line":105,"column":1,"offset":4278},"end":{"line":105,"column":107,"offset":4384},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" />\n<BlockMath math=\"(x := \\lambda x.xx|xx)\" />\n<BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" />","position":{"start":{"line":107,"column":1,"offset":4386},"end":{"line":109,"column":50,"offset":4529},"indent":[1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":112,"column":1,"offset":4532},"end":{"line":112,"column":31,"offset":4562},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":112,"column":31,"offset":4562}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nimport 'katex/dist/katex.min.css';\nimport { BlockMath } from 'react-katex';\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"haskell-from-first-principles\"\n    }}>{`Haskell From First Principles`}</h1>\n\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf\"\n        }}>{`A Tutorial Intro to Lambda Calculus`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"what-is-a-function\"\n    }}>{`What is a function`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`A set of possible inputs and a set of possible outputs`}</p>\n    </blockquote>\n    <BlockMath math=\"f(1) = A\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"f(2) = B\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"f(3) = C\" mdxType=\"BlockMath\" />\n    <p>{`The input set (domain) is `}<inlineCode parentName=\"p\">{`{1,2,3}`}</inlineCode>{` and the output set (codomain) is `}<inlineCode parentName=\"p\">{`{A,B,C}`}</inlineCode>{`.`}</p>\n    <p>{`In our function, an input of `}<inlineCode parentName=\"p\">{`1`}</inlineCode>{` will ALWAYS return `}<inlineCode parentName=\"p\">{`A`}</inlineCode>{`, no exceptions.`}</p>\n    <h2 {...{\n      \"id\": \"lambda-termd\"\n    }}>{`Lambda termd`}</h2>\n    <p>{`Lambda calculus has three basic components:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Expressions`}</li>\n      <li parentName=\"ol\">{`Variables`}</li>\n      <li parentName=\"ol\">{`Abstractions`}</li>\n    </ol>\n    <p>{`The word `}<inlineCode parentName=\"p\">{`expression`}</inlineCode>{` refers to a superset of those things. It can be a variable name, an abstraction or a combination of those things.`}</p>\n    <p>{`An `}<inlineCode parentName=\"p\">{`abstraction`}</inlineCode>{` is a function. It is a lambda term that has a head (a lambda) and a body and is applied to an argument. An `}<inlineCode parentName=\"p\">{`argument`}</inlineCode>{` is an input value.`}</p>\n    <p>{`Abstractions consist of the `}<inlineCode parentName=\"p\">{`head`}</inlineCode>{` and the `}<inlineCode parentName=\"p\">{`body`}</inlineCode>{`. The head of the function is a lambda followed by a variable name. The body of the function is another expression.`}</p>\n    <p>{`A simple function might look like this:`}</p>\n    <BlockMath math=\"\\lambda x.x\" mdxType=\"BlockMath\" />\n    <p>{`The variable named in the head is the `}<inlineCode parentName=\"p\">{`parameter`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`binds`}</inlineCode>{` all instances of that same variable in the body of the function. In laymen terms, when we apply this function to an argument, each `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` in the body of the function will have the value of that argument.`}</p>\n    <p>{`In the above, we were reference functions called `}<inlineCode parentName=\"p\">{`f`}</inlineCode>{`, but in the previous section the lambda astraction has no name and is an `}<inlineCode parentName=\"p\">{`anonymous function`}</inlineCode>{`.`}</p>\n    <p>{`A named function can be called by name by another function, a lambda cannot.`}</p>\n    <h3 {...{\n      \"id\": \"breakdown-of-the-lambda\"\n    }}>{`Breakdown of the lambda`}</h3>\n    <p>{`The extent of the lambda:`}</p>\n    <BlockMath math=\"\\lambda x.\" mdxType=\"BlockMath\" />\n    <p>{`The first `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is the single parameter of the function. This binds an variables:`}</p>\n    <p>{`The second `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is part of the body, the expression the lambda returns when applied. This is a bound variable.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`.`}</inlineCode>{` separates the parameters of the lambda from the function body.`}</p>\n    <h2 {...{\n      \"id\": \"alpha-equivalence\"\n    }}>{`Alpha Equivalence`}</h2>\n    <BlockMath math=\"\\lambda x.x\" mdxType=\"BlockMath\" />\n    <p>{`In the above expression, the variable `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is not semantically meaningful except in its role in that single expression. Because of this, there's a form of equivalence between lambda terms called `}<inlineCode parentName=\"p\">{`alpha equivalence`}</inlineCode>{`. This is a way of saying:`}</p>\n    <BlockMath math=\"\\lambda x.x = \\lambda d.d = \\lambda z.z\" mdxType=\"BlockMath\" />\n    <h2 {...{\n      \"id\": \"beta-reduction\"\n    }}>{`Beta reduction`}</h2>\n    <p>{`When we apply a function to an argument, we substitute the input expression for all instances of the bound variables within the body of the abstraction. You also eliminate the head of the abstraction, since its only purpose was to bind the variable. This is called `}<inlineCode parentName=\"p\">{`beta reduction`}</inlineCode>{`.`}</p>\n    <p>{`We can do one using a number. We apply the function above to `}<inlineCode parentName=\"p\">{`2`}</inlineCode>{`, substitude `}<inlineCode parentName=\"p\">{`2`}</inlineCode>{` for each bound variable in the body of the function and eliminate the head:`}</p>\n    <BlockMath math=\"( \\lambda x.x ) 2 = 2\" mdxType=\"BlockMath\" />\n    <p>{`The only bound variable is a single `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{`, so applying this function to 2 returns 2. This function is the `}<inlineCode parentName=\"p\">{`identity`}</inlineCode>{` function.`}</p>\n    <h2 {...{\n      \"id\": \"free-variables\"\n    }}>{`Free variables`}</h2>\n    <BlockMath math=\"\\lambda x.xy\" mdxType=\"BlockMath\" />\n    <p>{`In this example, `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is a bound variable, `}<inlineCode parentName=\"p\">{`y`}</inlineCode>{` is a free variable.`}</p>\n    <h2 {...{\n      \"id\": \"multiple-arguments\"\n    }}>{`Multiple arguments`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Each lambda can only bind one parameter and can only accept one argument. Functions that require multiple arguments have multiple, nested heads. When you apply it once and eliminate the first (leftmost) head, the next is applied and so on. It is know as `}<inlineCode parentName=\"p\">{`currying`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"evaluation-is-simplication\"\n    }}>{`Evaluation is simplication`}</h2>\n    <p>{`There are multiple normal forms in lambda calculus, but here when we refer to normal form we mean `}<inlineCode parentName=\"p\">{`beta normal form`}</inlineCode>{`. This corresponds to a fully evaluated expression (or a fully executed program). For example, do you say `}<inlineCode parentName=\"p\">{`2000/1000`}</inlineCode>{` or do you say 2? You say 2. The normal form of the evaluated expression is therefore 2.`}</p>\n    <p>{`Note: if we had function `}<inlineCode parentName=\"p\">{`(x,y) => x/y`}</inlineCode>{` and apply `}<inlineCode parentName=\"p\">{`x = 2000`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`y = 1000`}</inlineCode>{`, we call the the body with all arguments applied `}<inlineCode parentName=\"p\">{`saturated`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"combinators\"\n    }}>{`Combinators`}</h2>\n    <p>{`A `}<inlineCode parentName=\"p\">{`combinator`}</inlineCode>{` is a lambda term with no free variables. Combinators, as the name suggests, serve only to `}<inlineCode parentName=\"p\">{`combine`}</inlineCode>{` the arguments that they are given.`}</p>\n    <h2 {...{\n      \"id\": \"divergence\"\n    }}>{`Divergence`}</h2>\n    <p>{`Not all reducible lambda terms reduce neatly to a beta normal form. Reducing the following repeats itself:`}</p>\n    <BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"(x := \\lambda x.xx|xx)\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" mdxType=\"BlockMath\" />\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}