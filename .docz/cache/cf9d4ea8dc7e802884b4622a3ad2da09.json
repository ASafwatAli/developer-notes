{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Python-Collections.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Python-Collections.md","mtime":1579078174020},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJpbnRyby10by1weXRob24tY29sbGVjdGlvbnMifSwiSW50cm8gdG8gUHl0aG9uIENvbGxlY3Rpb25zIiksbWR4KCJwIixudWxsLCJBcHBlbmRpbmcgYW5kIGFkZGluZyB0byBsaXN0cy4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtcHl0aG9uIn0pLCIjIyMgYV9saXN0PVsxLDIsM11cbiMjIyBhX2xpc3RcbmFfbGlzdC5hcHBlbmQoWzQsNV0pICMgWzEsMiwzLFs0LDVdXVxub3VyX2xpc3QgPSBsaXN0KHJhbmdlKDEwKSlcbiMjIyBvdXJfbGlzdFxuWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldXG4jIyMgb3VyX2xpc3QgKyBbMTAsMTEsMTJdXG5bMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiMjIyBvdXJfbGlzdFxuWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldXG4jIyMgb3VyX2xpc3Q9b3VyX2xpc3QrWzEwLDExLDEyXVxuIyMjIG91cl9saXN0XG5bMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiIpKSxtZHgoInAiLG51bGwsIkZvciBzcGxpdHRpbmcgc3RyaW5ncyB0aGVtc2VsdmVzIHdlIGNhbiB1c2UgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInN0ci5zcGxpdChzdHI9XCJcIiwgbnVtPXN0cmluZy5jb3VudChzdHIpKSIpKSxtZHgoImgyIix7ImlkIjoiZXh0ZW5kaW5nLWNvbGxlY3Rpb25zIn0sIkV4dGVuZGluZyBDb2xsZWN0aW9ucyIpLG1keCgicCIsbnVsbCwiTm9ybWFsbHkgY2xlYW5lciBmb3IgbGFyZ2VyIGxpc3RzIHRoYW4gdGhlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCIrIiksIiBzeW1ib2wuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLXB5dGhvbiJ9KSwiPj4+IG91cl9saXN0XG5bMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbj4+PiBvdXJfbGlzdC5leHRlbmQocmFuZ2UoMTMsIDIwKSlcbj4+PiBvdXJfbGlzdFxuWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5XVxuIikpLG1keCgicCIsbnVsbCwiSG93IGRvIGFkZCBuZXcgaXRlbXMgaW5zaWRlIHRoZSBsaXN0PyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1weXRob24ifSksIj4+PiBhbHBoYT0gbGlzdCgnYWNkZicpXG4+Pj4gYWxwaGFcblsnYScsICdjJywgJ2QnLCAnZiddXG4+Pj4gYWxwaGEuaW5zZXJ0KDEsJ2InKVxuPj4+IGFscGhhXG5bJ2EnLCAnYicsICdjJywgJ2QnLCAnZiddXG4+Pj4gYWxwaGEuaW5zZXJ0KDQsJ2UnKVxuPj4+IGFscGhhXG5bJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ11cbiIpKSxtZHgoImgyIix7ImlkIjoic2hvcHBpbmctbGlzdCJ9LCJTaG9wcGluZyBMaXN0IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgbm90ZSAtIHlvdSBzaG91bGQgdXNlIGVudW1lcmF0ZSBvbmNlIHlvdSBnZXQgdGhlcmVcbj4+PiBkZWYgc2hvd19oZWxwKCk6XG4gICAgIHByaW50KFwiXFxuRG9pbmcgYSBwcmludF9cIilcblxuPj4+IGRlZiBzaG93X2xpc3QoKTpcbiAgICAgY291bnQ9MVxuICAgICBmb3IgaXRlbSBpbiBzaG9wcGluZ19saXN0OlxuICAgICAgICAgICAgIHByaW50KFwie306IHt9XCIuZm9ybWF0KGNvdW50LCBpdGVtKSlcbiAgICAgICAgICAgICBjb3VudCs9MVxuIikpLG1keCgicCIsbnVsbCwiT3RoZXIgaGVscGZ1bCB1c2UgY2FzZXMuLi4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwid2hpbGUgVHJ1ZTpcbiAgICAjZG8gc3R1ZmZcbiAgICBuZXdfc3R1ZmYgPSBpbnB1dChcIj4gXCIpXG5cbiAgICBpZiBuZXdfc3R1ZmYgPT0gXCJET05FXCI6XG4gICAgICAgIHByaW50KCdEb25lJylcbiAgICAgICAgYnJlYWtcbiAgICBlbGlmXG4gICAgICAgICNkbyBvdGhlciBzdHVmZlxuICAgICAgICBicmVha1xuICAgIGVsc2VcbiAgICAgICAgLi4uXG4iKSksbWR4KCJoMiIseyJpZCI6InJlbW92aW5nLWl0ZW1zLWZyb20tYS1saXN0In0sIlJlbW92aW5nIEl0ZW1zIGZyb20gYSBMaXN0IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImFfbGlzdD1saXN0KCdhYnpkZScpXG5hX2xpc3QuaW5kZXgoJ3onKVxuZGVsIGFfbGlzdFsyXVxuXG5hX3N0cmluZyA9IFwiSGVsbG9cIlxuIyB0aGlzIHdpbGwgZGVsZXRlIHRoZSBzdHJpbmcgLSBhbHRob3VnaCB0aGUgZGVsIGNhbid0IGJlIHVzZWQgdG8gZGVsZXRlIHdpdGhpbiB0aGUgc3RyaW5nXG4jIHN0cmluZ3MgdGhlbXNlbHZlcyBhcmUgaW1tdXRhYmxlXG5kZWwgYV9zdHJpbmdcblxuIyByZW1vdmUgZm9yIHRoZSBsaXN0XG5teV9saXN0ID0gWzEsMiwzLDFdXG4jIHJlbW92ZSBPTkxZIHJlbW92ZXMgdGhlIGZpcnN0IGluc3RhbmNlIGZyb20gdGhlIGxpc3Rcbm15X2xpc3QucmVtb3ZlKDEpXG5teV9saXN0XG4jIFsyLDMsMV1cbiIpKSxtZHgoImgyIix7ImlkIjoicmVtb3Zpbmctdm93ZWxzLWZyb20tYS1saXN0LW9mLXdvcmRzLWFuZC1jYXBpdGFsaXNpbmctdGhlbSJ9LCJSZW1vdmluZyB2b3dlbHMgZnJvbSBhIGxpc3Qgb2Ygd29yZHMgYW5kIGNhcGl0YWxpc2luZyB0aGVtIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm5hbWVzID0gW1wiRGVubmlzXCIsIFwiQmlsbHlcIiwgXCJUcm9qYW5cIiwgXCJIb3JzZVwiXVxudm93ZWxzID0gbGlzdCgnYWVpb3UnKVxub3V0cHV0ID0gW11cblxuZm9yIG5hbWUgaW4gbmFtZXM6XG4gICAgbmFtZV9saXN0ID0gbGlzdChuYW1lLmxvd2VyKCkpXG5cbiAgICBmb3Igdm93ZWwgaW4gdm93ZWxzOlxuICAgICAgICB3aGlsZSBUcnVlOlxuICAgICAgICAgICAgdHJ5OlxuICAgICAgICAgICAgICAgIHN0YXRlX2xpc3QucmVtb3ZlKHZvd2VsKVxuICAgICAgICAgICAgZXhjZXB0OlxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgb3V0cHV0LmFwcGVuZCgnJy5qb2luKG5hbWVfbGlzdCkuY2FwaXRhbGl6ZSgpKVxuXG5wcmludChvdXRwdXQpXG4iKSksbWR4KCJoMiIseyJpZCI6InBvcC1hbi1pdGVtLWZyb20tdGhlLWxpc3QifSwiUG9wIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCIpLG1keCgicCIsbnVsbCwicG9wKCkgcmVtb3ZlcyBhbiBpdGVtIGJ5IGluZGV4IGJ1dCBnaXZlcyB1cyB0aGUgaXRlbS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwibmFtZXMgPSBbXCJEZW5uaXNcIiwgXCJCaWxseVwiLCBcIlRyb2phblwiLCBcIkhvcnNlXCJdXG5maXJzdCA9IG5hbWVzLnBvcCgpIC8vIGdpdmVzIHRoZSBmaXJzdCBuYW1lXG5hbm90aGVyID0gbmFtZXMucG9wKDIpIC8vIGdpdmVzIGluZGV4IDNcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLy8gUXVpeiBDaGFsbGVuZ2VcblxuLy8gMS4gTW92ZSB0aGUgJzEnIHRvIHRoZSBmcm9udCBvZiB0aGUgbGlzdFxuXG50aGVfbGlzdCA9IFtcImFcIiwgMiwgMywgMSwgRmFsc2UsIFsxLCAyLCAzXV1cblxuIyBZb3VyIGNvZGUgZ29lcyBiZWxvdyBoZXJlXG50aGVfbGlzdC5pbnNlcnQoMCwgdGhlX2xpc3QucG9wKDMpKVxuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJzbGljZXMifSwiU2xpY2VzIiksbWR4KCJwIixudWxsLCJTbGljZXMgbWVhbiB3ZSBjYW4gZ2V0IGJhY2sgbW9yZSB0aGFuIG9uZSBpdGVtIGZyb20gYSBsaXN0LiBXZSBjYWxsIHRoaXMgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInNsaWNpbmciKSwiLiIpLG1keCgicCIsbnVsbCwiU29tZXRoaW5nIGltcG9ydGFudCB0byBub3QgaXMgdGhlIHVzZWFiaWxpdHkgb2YgaGF2ZSB0aGUgIiwiWzpdIiwiIGNhbGwgZm9yIGEgY29weSBvZiB0aGUgbGlzdCEiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwibXlfc3RyaW5nPVwiSGVsbG8gdGhlcmUhXCJcbm15X3N0cmluZ1swOjVdXG5cbm15X2xpc3Q9bGlzdChyYW5nZSgxLDYpKVxubXlfbGlzdFswOjJdIC8vIHNhbWUgYXMgbXlfbGlzdFs6Ml1cbm15X2xpc3RbMjpsZW4obXlfbGlzdCldXG5cbm15X2xpc3RbMTpdXG5teV9saXN0WzpdIC8vIGdldHMgYmFjayBhIGNvcHkgb2YgdGhlIGxpc3RcblxubXlfbmV3X2xpc3QgPSBbNCwyLDEsMyw1XVxubXlfbmV3X2xpc3Quc29ydCgpXG5teV9uZXdfbGlzdFxuIikpLG1keCgiaDIiLHsiaWQiOiJzbGljaW5nLXdpdGgtYS1zdGVwIn0sIlNsaWNpbmcgd2l0aCBhIFN0ZXAiKSxtZHgoInAiLG51bGwsIkhvdyBjYW4gd2Ugc2xpY2UgdGhhdCBtb3ZlIGJhY2t3YXJkIG9yIHRoYXQgc2tpcCBpdGVtcz8iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwibXlfbGlzdD1saXN0KHJhbmdlKDIwKSlcblxuIyBsZXQncyBnZXQgdGhlIGV2ZW4gbnVtYmVyc1xubXlfbGlzdFs6OjJdXG5cIlRlc3RpbmdcIls6OjJdXG5cbiMgcmV2ZXJzaW5nXG5cIlNsYXBcIls6Oi0xXVxuXG4jIGdldHRpbmcgdGhlIG1pZGRsZSBzbGljZSAtIG11c3Qgc3dhcCBwb3NpdGlvbnMhXG5teV9saXN0Wzg6MjotMV1cblxuIyBuZWdhdGl2ZSBpbmRleGVzIHdpbGwgYWxzbyBnaXZlIHlvdSB0aGUgcG9zaXRpb25zIGZyb20gdGhlIGVuZFxubXlfbGlzdFstMV1cblxuIyBleGFtcGxlIG9mIGdyYWJiaW5nIHRoZSBmaXJzdCBmb3VyIGl0ZXJhYmxlcyB0aHJvdWdoIGEgUHl0aG9uIGZ1bmN0aW9uXG5kZWYgZmlyc3RfNChpdGVyKTpcbiAgICByZXR1cm4gaXRlcls6NF1cbiIpKSxtZHgoImgyIix7ImlkIjoiZGVsZXRpbmctb3ItcmVwbGFjaW5nLXNsaWNlcyJ9LCJEZWxldGluZyBvciBSZXBsYWNpbmcgU2xpY2VzIiksbWR4KCJwIixudWxsLCJXZSBjYW4gZGVsZXRlIGFuZCByZXBsYWNlIHdpdGggbGlzdHMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm15X2xpc3QgPSBbMSwyLCAnYScsICdiJywgNSw2LCdmJywnZyddXG5cbiMgd2hhdCBpZiBJIGp1c3Qgd2FudCBsZXR0ZXJzP1xubXlfbGlzdFs0OjddID0gWydlJywnZiddXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJDb2RlIENoYWxsZW5nZSIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiZGVmIHNpbGx5Y2FzZShjKTpcbiAgICByZXR1cm4gY1s6cm91bmQobGVuKGMpIC8gMildLmxvd2VyKCkgKyBjW3JvdW5kKGxlbihjKSAvIDIpOl0udXBwZXIoKVxuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJkaWN0aW9uYXJpZXMifSwiRGljdGlvbmFyaWVzIiksbWR4KCJwIixudWxsLCJLZXktVmFsdWUgb3JnYW5pc2F0aW9uLiBUaGV5IHRoZW1zZWx2ZXMgZG8gbm90IGhhdmUgYW4gb3JkZXIuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm15X2RpY3QgPSB7J25hbWUnOiAnRGVubmlzJywgJ2pvYic6ICdTb2Z0d2FyZSBFbmdpbmVlcid9XG5cbiMgdG8gYWNjZXNzIGl0LCB5b3UgbmVlZCB0byB1c2UgdGhlIGtleSBuYW1lXG5teV9kaWN0WyduYW1lJ11cbiIpKSxtZHgoInAiLG51bGwsIkRpY3Rpb25hcmllcyBjYW4gY29udGFpbiBhbnl0aGluZyAtIGV2ZW4geW91ciBvd24gY3VzdG9tIGNsYXNzZXMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm5hbWVkX2RpY3QgPSB7ICduYW1lJyA6IHsgJ2ZpcnN0JyA6ICdEZW5uaXMnLCAnbGFzdCc6ICdPS2VlZmZlJ30gfVxubmFtZWRfZGljdFsnbmFtZSddWydmaXJzdCddXG5cbiMgdHVwbGUgZ2FtZSBkaWN0XG5nYW1lX2RpY3QgPSB7KDEsMikgOiBUcnVlfVxuZ2FtZV9kaWN0WygxLDIpXVxuIikpLG1keCgicCIsbnVsbCwiQ2hhbGxlbmdlOiBDaGVjayBpZiBhIGRpY3Qga2V5IGlzIGluIHRoZSBsaXN0IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImRlZiBtZW1iZXJzKGRpY3QsIGtleXMpOlxuICAgIGNvdW50ZXIgPSAwXG4gICAgZm9yIGtleSBpbiBkaWN0OlxuICAgICAgICBpZiBrZXkgaW4ga2V5czpcbiAgICAgICAgICAgIGNvdW50ZXIgPSBjb3VudGVyICsgMVxuICAgIHJldHVybiBjb3VudGVyXG4iKSksbWR4KCJoMiIseyJpZCI6Im1hbmFnaW5nLWtleXMifSwiTWFuYWdpbmcgS2V5cyIpLG1keCgicCIsbnVsbCwiV2UgY2FuICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJkZWwiKSwiIGtleXMgZXRjIHNpbWlsYXIgdG8gdGhlIHdheSB3ZSBkbyBpdCBmb3Iga2V5cy4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPj4+IG15X2RpY3RbJ3Rlc3QnXSA9ICd2YWx1ZSdcbj4+PiBteV9kaWN0XG57J3Rlc3QnOiAndmFsdWUnLCAnam9iJzogJ1NvZnR3YXJlIEVuZ2luZWVyJywgJ25hbWUnOiAnRGVubmlzJ31cbj4+PiBkZWwgbXlfZGljdFsndGVzdCddXG4+Pj4gbXlfZGljdFxueydqb2InOiAnU29mdHdhcmUgRW5naW5lZXInLCAnbmFtZSc6ICdEZW5uaXMnfVxuXG4jIHdlIGNhbiB1c2UgdXBkYXRlIGZvciBtdWx0aXBsZSBrZXlzIGV0Y1xuPj4+IG15X2RpY3QudXBkYXRlKHsnam9iJzogJ0RldmVsb3BlcicsICdhZ2UnOiAyNCwgJ3N0YXRlJzogJ05ldyBTb3V0aCBXYWxlcyd9KVxuPj4+IG15X2RpY3Rcbnsnam9iJzogJ0RldmVsb3BlcicsICduYW1lJzogJ0Rlbm5pcycsICdhZ2UnOiAyNCwgJ3N0YXRlJzogJ05ldyBTb3V0aCBXYWxlcyd9XG4iKSksbWR4KCJwIixudWxsLCJDaGFsbGVuZ2U6IENyZWF0ZSBhIGZ1bmN0aW9uIG5hbWVkIHdvcmRfY291bnQoKSB0aGF0IHRha2VzIGEgc3RyaW5nLiBSZXR1cm4gYSBkaWN0aW9uYXJ5IHdpdGggZWFjaCB3b3JkIGluIHRoZSBzdHJpbmcgYXMgdGhlIGtleSBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBpdCBhcHBlYXJzIGFzIHRoZSB2YWx1ZS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiZGVmIHdvcmRfY291bnQoc2VudGVuY2UpOlxuICAgIG5ld19kaWN0ID0ge31cbiAgICB3b3JkX2xpc3QgPSBzZW50ZW5jZS5zcGxpdCgpXG4gICAgY291bnQgPSAwXG5cbiAgICBmb3Igb3JpZ2luYWxfd29yZCBpbiB3b3JkX2xpc3Q6XG4gICAgICAgIGlmIG9yaWdpbmFsX3dvcmQgbm90IGluIG5ld19kaWN0OlxuICAgICAgICAgICAgY291bnQgPSAwXG4gICAgICAgICAgICBmb3IgY29tcGFyaXNvbl93b3JkIGluIHdvcmRfbGlzdDpcbiAgICAgICAgICAgICAgICBpZiBvcmlnaW5hbF93b3JkID09IGNvbXBhcmlzb25fd29yZDpcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgICAgICAgICAgICBuZXdfZGljdC51cGRhdGUoe29yaWdpbmFsX3dvcmQ6IGNvdW50fSlcbiAgICByZXR1cm4gbmV3X2RpY3RcbiIpKSxtZHgoImgyIix7ImlkIjoidW5wYWNraW5nLWRpY3Rpb25hcmllcyJ9LCJVbnBhY2tpbmcgRGljdGlvbmFyaWVzIiksbWR4KCJwIixudWxsLCJZb3UgY2FuIGdpdmUgcGxhY2Vob2xkZXJzIGEgbmFtZSBhbmQgdXNlIGRpY3Rpb25hcmllcyB0byBtYWtlIGl0IGEgbGl0dGxlIGVhc2llci4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPj4+IG15X3N0cmluZyA9IFwiSGkgbXkgbmFtZSBpcyB7bmFtZX0gYW5kIEkgbGl2ZSBpbiB7c3RhdGV9XCJcbj4+PiBteV9zdHJpbmdcbidIaSBteSBuYW1lIGlzIHtuYW1lfSBhbmQgSSBsaXZlIGluIHtzdGF0ZX0nXG4+Pj4gbXlfc3RyaW5nLmZvcm1hdCgnRGVubmlzJywgJ1N5ZG5leScpXG5UcmFjZWJhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6XG4gIEZpbGUgXCI8c3RkaW4+XCIsIGxpbmUgMSwgaW4gPG1vZHVsZT5cbktleUVycm9yOiAnbmFtZSdcbj4+PiBteV9zdHJpbmcuZm9ybWF0KCduYW1lJz0nRGVubmlzJywgc3RhdGU9J1N5ZG5leScpXG4gIEZpbGUgXCI8c3RkaW4+XCIsIGxpbmUgMVxuU3ludGF4RXJyb3I6IGtleXdvcmQgY2FuJ3QgYmUgYW4gZXhwcmVzc2lvblxuPj4+IG15X3N0cmluZy5mb3JtYXQobmFtZT0nRGVubmlzJywgc3RhdGU9J1N5ZG5leScpXG4nSGkgbXkgbmFtZSBpcyBEZW5uaXMgYW5kIEkgbGl2ZSBpbiBTeWRuZXknXG5cbiMgaG93IGRvIHdlIG1ha2UgdGhpcyBwcm9ncmFtbWF0aWM/XG4+Pj4gdGVzdF9kaWN0ID0geyduYW1lJzonRGVubmlzJywgJ3N0YXRlJzonU3lkbmV5J31cbj4+PiBteV9zdHJpbmcuZm9ybWF0KCoqdGVzdF9kaWN0KVxuJ0hpIG15IG5hbWUgaXMgRGVubmlzIGFuZCBJIGxpdmUgaW4gU3lkbmV5J1xuIikpLG1keCgicCIsbnVsbCwiQ29kZSBDaGFsbGVuZ2U6IENyZWF0ZSBhIGZ1bmN0aW9uIG5hbWVkIHN0cmluZ19mYWN0b3J5IHRoYXQgYWNjZXB0cyBhIGxpc3Qgb2YgZGljdGlvbmFyaWVzIGFuZCBhIHN0cmluZy4gUmV0dXJuIGEgbmV3IGxpc3QgYnVpbHQgYnkgdXNpbmcgLmZvcm1hdCgpIG9uIHRoZSBzdHJpbmcsIGZpbGxlZCBpbiBieSBlYWNoIG9mIHRoZSBkaWN0aW9uYXJpZXMgaW4gdGhlIGxpc3QuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImRpY3RzID0gW1xuICAgIHsnbmFtZSc6ICdNaWNoZWxhbmdlbG8nLFxuICAgICAnZm9vZCc6ICdQSVpaQSd9LFxuICAgIHsnbmFtZSc6ICdHYXJmaWVsZCcsXG4gICAgICdmb29kJzogJ2xhc2FuZ2EnfSxcbiAgICB7J25hbWUnOiAnV2FsdGVyJyxcbiAgICAgJ2Zvb2QnOiAncGFuY2FrZXMnfSxcbiAgICB7J25hbWUnOiAnR2FsYWN0dXMnLFxuICAgICAnZm9vZCc6ICd3b3JsZHMnfVxuXVxuXG5zdHJpbmcgPSBcIkhpLCBJJ20ge25hbWV9IGFuZCBJIGxvdmUgdG8gZWF0IHtmb29kfSFcIlxuXG5kZWYgc3RyaW5nX2ZhY3RvcnkobGlzdF9vZl9kaWN0LCBzdHIpOlxuICAgIG5ld19saXN0ID0gW11cbiAgICBmb3IgaW5kX2xpc3QgaW4gbGlzdF9vZl9kaWN0OlxuICAgICAgICBuZXdfbGlzdC5hcHBlbmQoc3RyLmZvcm1hdCgqKmluZF9saXN0KSlcbiAgICByZXR1cm4gbmV3X2xpc3RcbiIpKSxtZHgoImgyIix7ImlkIjoiZGljdGlvbmFyeS1pdGVyYXRpb24ifSwiRGljdGlvbmFyeSBJdGVyYXRpb24iKSxtZHgoInAiLG51bGwsIkFnYWluLCBEaWN0aW9uYXJpZXMgaW4gUHl0aG9uIGRvIG5vdCBoYXZlIGEgc2V0IG9yZGVyLCBidXQgd2UgY2FuIHN0aWxsIGl0ZXJhdGUgb3ZlciB0aGVtLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCI+Pj4gbXlfZGljdFxueydqb2InOiAnRGV2ZWxvcGVyJywgJ25hbWUnOiAnRGVubmlzJywgJ2FnZSc6IDI0LCAnc3RhdGUnOiAnTmV3IFNvdXRoIFdhbGVzJ31cbj4+PiBmb3IgdGhpbmcgaW4gbXlfZGljdDpcbi4uLiAgICAgcHJpbnQodGhpbmcpXG4uLi5cbmpvYlxubmFtZVxuYWdlXG5zdGF0ZVxuXG4+Pj4gZm9yIGtleSBpbiBteV9kaWN0OlxuLi4uICAgICBwcmludChteV9kaWN0W2tleV0pXG4uLi5cbkRldmVsb3BlclxuRGVubmlzXG4yNFxuTmV3IFNvdXRoIFdhbGVzXG5cbj4+PiBmb3IgdmFsdWUgaW4gbXlfZGljdC52YWx1ZXMoKTpcbi4uLiAgICAgcHJpbnQodmFsdWUpXG4uLi5cbkRldmVsb3BlclxuRGVubmlzXG4yNFxuTmV3IFNvdXRoIFdhbGVzXG4iKSksbWR4KCJwIixudWxsLCJDcmVhdGUgYSBmdW5jdGlvbiBuYW1lZCBtb3N0LWNsYXNzZXMgdGhhdCB0YWtlcyBhIGRpY3Rpb25hcnkgb2YgdGVhY2hlcnMuIEVhY2gga2V5IGlzIGEgdGVhY2hlcidzIG5hbWUgYW5kIHRoZWlyIHZhbHVlIGlzIGEgbGlzdCBvZiBjbGFzc2VzIHRoZXkndmUgdGF1Z2h0LiBtb3N0LWNsYXNzZXMgc2hvdWxkIHJldHVybiB0aGUgdGVhY2hlciB3aXRoIHRoZSBtb3N0IGNsYXNzZXMuIiksbWR4KCJwIixudWxsLCJOZXh0LCBjcmVhdGUgYSBmdW5jdGlvbiBuYW1lZCBudW1fdGVhY2hlcnMgdGhhdCB0YWtlcyB0aGUgc2FtZSBkaWN0aW9uYXJ5IG9mIHRlYWNoZXJzIGFuZCBjbGFzc2VzLiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZWFjaGVycy4iKSxtZHgoInAiLG51bGwsIk5vdywgY3JlYXRlIGEgZnVuY3Rpb24gbmFtZWQgc3RhdHMgdGhhdCB0YWtlcyB0aGUgdGVhY2hlciBkaWN0aW9uYXJ5LiBSZXR1cm4gYSBsaXN0IG9mIGxpc3RzIGluIHRoZSBmb3JtYXQgIiwiWyIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCI8dGVhY2hlciBuYW1lPiIpLCIsICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCI8bnVtYmVyIG9mIGNsYXNzZXM+IiksIl0iLCIuIEZvciBleGFtcGxlLCBvbmUgaXRlbSBpbiB0aGUgbGlzdCB3b3VsZCBiZSAiLCJbJ0RhdmUgTWNGYXJsYW5kJywgMV0iLCIuIiksbWR4KCJwIixudWxsLCJHcmVhdCB3b3JrISBGaW5hbGx5LCB3cml0ZSBhIGZ1bmN0aW9uIG5hbWVkIGNvdXJzZXMgdGhhdCB0YWtlcyB0aGUgdGVhY2hlcnMgZGljdGlvbmFyeS4gSXQgc2hvdWxkIHJldHVybiBhIHNpbmdsZSBsaXN0IG9mIGFsbCBvZiB0aGUgY291cnNlcyBvZmZlcmVkIGJ5IGFsbCBvZiB0aGUgdGVhY2hlcnMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImRlZiBtb3N0X2NsYXNzZXModGVhY2hlcnMpOlxuICAgIGhpZ2hlc3RfdmFsdWUgPSAwXG4gICAgdGVhY2hlcl9uYW1lID0gXCJcIlxuICAgIGZvciB0ZWFjaGVyIGluIHRlYWNoZXJzOlxuICAgICAgICBpZiBsZW4odGVhY2hlcnNbdGVhY2hlcl0pID4gaGlnaGVzdF92YWx1ZTpcbiAgICAgICAgICAgIGhpZ2hlc3RfdmFsdWUgPSBsZW4odGVhY2hlcnNbdGVhY2hlcl0pXG4gICAgICAgICAgICB0ZWFjaGVyX25hbWUgPSB0ZWFjaGVyXG4gICAgcmV0dXJuIHRlYWNoZXJfbmFtZVxuXG5kZWYgbnVtX3RlYWNoZXJzKHRlYWNoZXJzKTpcbiAgICByZXR1cm4gbGVuKHRlYWNoZXJzKVxuXG5kZWYgc3RhdHModGVhY2hlcnMpOlxuICAgIHJldHVybl9saXN0ID0gW11cbiAgICBmb3IgdGVhY2hlciBpbiB0ZWFjaGVyczpcbiAgICAgICAgcmV0dXJuX2xpc3QuYXBwZW5kKFt0ZWFjaGVyLCBsZW4odGVhY2hlcnNbdGVhY2hlcl0pXSlcbiAgICByZXR1cm4gcmV0dXJuX2xpc3RcblxuZGVmIGNvdXJzZXModGVhY2hlcnMpOlxuICAgIHNpbmdsZV9jb3Vyc2VzID0gW11cbiAgICBmb3IgY291cnNlcyBpbiB0ZWFjaGVycy52YWx1ZXMoKTpcbiAgICAgICAgZm9yIGNvdXJzZSBpbiBjb3Vyc2VzOlxuICAgICAgICAgICAgaWYgY291cnNlIG5vdCBpbiBzaW5nbGVfY291cnNlczpcbiAgICAgICAgICAgICAgICBzaW5nbGVfY291cnNlcy5hcHBlbmQoY291cnNlKVxuICAgIHJldHVybiBzaW5nbGVfY291cnNlc1xuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJ0dXBsZXMifSwiVHVwbGVzIiksbWR4KCJwIixudWxsLCJMaXN0cyB0aGVtc2VsdmVzIGNhbiBiZSBtdXRhdGVkLCBidXQgc29tZXRpbWVzIHdlIHdhbnQgdGhlIGNvbGxlY3Rpb25zIHRvIHN0YXkgdGhlIHNhbWUuIFRoYXQncyB3aGVyZSB0dXBsZXMgY29tZSBpbi4gVGhleSB0aGVtc2VsdmVzIGFyZSBpbW11dGFibGUuIiksbWR4KCJwIixudWxsLCJUdXBsZXMgZG8gbm90IHN1cHBvcnQgaXRlbSBhc3NpZ25tZW50LiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCI+Pj4gdHVwbGVUZXN0ID0gKDEsMiwzKVxuPj4+IHR1cGxlVGVzdFxuKDEsIDIsIDMpXG4+Pj4gbXlfc2Vjb25kX3R1cGxlID0gMSwyLDNcbj4+PiBteV9zZWNvbmRfdHVwbGVcbigxLCAyLCAzKVxuPj4+IG15X3RoaXJkX3R1cGxlID0gdHVwbGUoWzEsMiwzXSlcbj4+PiBteV90aGlyZF90dXBsZVxuKDEsIDIsIDMpXG4+Pj4gZGlyKHR1cGxlKVxuWydfX2FkZF9fJywgJ19fY2xhc3NfXycsICdfX2NvbnRhaW5zX18nLCAnX19kZWxhdHRyX18nLCAnX19kb2NfXycsICdfX2VxX18nLCAnX19mb3JtYXRfXycsICdfX2dlX18nLCAnX19nZXRhdHRyaWJ1dGVfXycsICdfX2dldGl0ZW1fXycsICdfX2dldG5ld2FyZ3NfXycsICdfX2dldHNsaWNlX18nLCAnX19ndF9fJywgJ19faGFzaF9fJywgJ19faW5pdF9fJywgJ19faXRlcl9fJywgJ19fbGVfXycsICdfX2xlbl9fJywgJ19fbHRfXycsICdfX211bF9fJywgJ19fbmVfXycsICdfX25ld19fJywgJ19fcmVkdWNlX18nLCAnX19yZWR1Y2VfZXhfXycsICdfX3JlcHJfXycsICdfX3JtdWxfXycsICdfX3NldGF0dHJfXycsICdfX3NpemVvZl9fJywgJ19fc3RyX18nLCAnX19zdWJjbGFzc2hvb2tfXycsICdjb3VudCcsICdpbmRleCddXG4iKSksbWR4KCJoMiIseyJpZCI6InR1cGxlLXBhY2tpbmctYW5kLXVucGFja2luZyJ9LCJUdXBsZSBQYWNraW5nIGFuZCBVbnBhY2tpbmciKSxtZHgoInAiLG51bGwsIkhlcmUgd2UgY3JlYXRlIGEgdHVwbGUgdGhhdCBoYXMgdmFsdWVkIGFzc2lnbmVkIGJ5IGFub3RoZXIgdHVwbGUuIEl0J3MgcmVmZXJyZWQgdG8gYXMgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInNpbXVsYXRuZW91cyBhc3NpZ25tZW50IiksIi4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPj4+IGEsYiA9IDEsMlxuPj4+IGFcbjFcbj4+PiBiXG4yXG5cbiMgdW5wYWNraW5nXG4+Pj4gYyA9ICgzLDQpXG4+Pj4gKGQsZSkgPSBjXG4+Pj4gZFxuM1xuPj4+IGVcbjRcblxuIyBwYWNraW5nXG4+Pj4gZiA9IGQsZVxuPj4+IGZcbigzLCA0KVxuPj4+IGYgPT0gY1xuVHJ1ZVxuXG4jIHN3YXBwaW5nIHRoZSB2YWx1ZVxuPj4+IGRlbCBhXG4+Pj4gZGVsIGJcbj4+PiBhID0gMVxuPj4+IGIgPSAyXG4+Pj4gYSxiID0gYixhXG4+Pj4gYVxuMlxuPj4+IGJcbjFcblxuIyBmdW5jdGlvbiBleGFtcGxlXG4+Pj4gZGVmIG15X2Z1bmMoKTpcbi4uLiAgICAgcmV0dXJuIDEsMiwzXG4uLi5cbj4+PiBteV9mdW5jKClcbigxLCAyLCAzKVxuPj4+IGEsYixjID0gbXlfZnVuYygpXG4+Pj4gYVxuMVxuPj4+IGJcbjJcbj4+PiBjXG4zXG4iKSksbWR4KCJwIixudWxsLCJDaGFsbGVuZ2U6IENyZWF0ZSBhIGZ1bmN0aW9uIG5hbWVkIHN0cmluZ2Nhc2VzIHRoYXQgdGFrZXMgYSBzdHJpbmcgYW5kIHJldHVybnMgYSB0dXBsZSBvZiBmb3VyIHZlcnNpb25zIG9mIHRoZSBzdHJpbmc6IHVwcGVyY2FzZWQsIGxvd2VyY2FzZWQsIHRpdGxlY2FzZWQgKHdoZXJlIGV2ZXJ5IHdvcmQncyBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWQpLCBhbmQgYSByZXZlcnNlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImRlZiBzdHJpbmdjYXNlcyhzdHIpOlxuICAgIHVwcGVyY2FzZWQgPSBzdHIudXBwZXIoKVxuICAgIGxvd2VyY2FzZWQgPSBzdHIubG93ZXIoKVxuICAgIHRpdGxlY2FzZWQgPSBzdHIudGl0bGUoKVxuICAgIHJldmVyc2UgPSBzdHJbOjotMV1cbiAgICByZXR1cm4gdXBwZXJjYXNlZCwgbG93ZXJjYXNlZCwgdGl0bGVjYXNlZCwgcmV2ZXJzZVxuIikpLG1keCgiaDIiLHsiaWQiOiJ0dXBsZXMtd2l0aC1mdW5jdGlvbnMifSwiVHVwbGVzIHdpdGggZnVuY3Rpb25zIiksbWR4KCJwIixudWxsLCJXZSBjYW4gdXNlIGVudW1lcmF0ZSBmb3Igc29tZSBwYWNraW5nIGV0Yy4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPj4+IGFscGhhID0gbGlzdCgnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonKVxuPj4+IGFscGhhXG5bJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneiddXG4+Pj4gZGlyKGVudW1lcmF0ZSlcblsnX19jbGFzc19fJywgJ19fZGVsYXR0cl9fJywgJ19fZG9jX18nLCAnX19mb3JtYXRfXycsICdfX2dldGF0dHJpYnV0ZV9fJywgJ19faGFzaF9fJywgJ19faW5pdF9fJywgJ19faXRlcl9fJywgJ19fbmV3X18nLCAnX19yZWR1Y2VfXycsICdfX3JlZHVjZV9leF9fJywgJ19fcmVwcl9fJywgJ19fc2V0YXR0cl9fJywgJ19fc2l6ZW9mX18nLCAnX19zdHJfXycsICdfX3N1YmNsYXNzaG9va19fJywgJ25leHQnXVxuIyBwcmludHMgdGhlIGhlbHBcbj4+PiBoZWxwKGVudW1lcmF0ZSlcbj4+PiBmb3IgKGluZGV4LCBsZXR0ZXIpIGluIGVudW1lcmF0ZShhbHBoYSk6XG4uLi4gICAgIHByaW50KCd7fToge30nKS5mb3JtYXQoaW5kZXgsbGV0dGVyKVxuLi4uXG4wOiBhXG4xOiBiXG4yOiBjXG4zOiBkXG40OiBlXG41OiBmXG42OiBnXG43OiBoXG44OiBpXG45OiBqXG4xMDoga1xuMTE6IGxcbjEyOiBtXG4xMzogblxuMTQ6IG9cbjE1OiBwXG4xNjogcVxuMTc6IHJcbjE4OiBzXG4xOTogdFxuMjA6IHVcbjIxOiB2XG4yMjogd1xuMjM6IHhcbjI0OiB5XG4yNTogelxuXG4+Pj4gZm9yIHN0ZXAgaW4gZW51bWVyYXRlKGFscGhhKTpcbi4uLiAgICAgcHJpbnQoJ3t9OiB7fScuZm9ybWF0KCpzdGVwKSlcbi4uLlxuMDogYVxuMTogYlxuMjogY1xuMzogZFxuNDogZVxuNTogZlxuNjogZ1xuNzogaFxuODogaVxuOTogalxuMTA6IGtcbjExOiBsXG4xMjogbVxuMTM6IG5cbjE0OiBvXG4xNTogcFxuMTY6IHFcbjE3OiByXG4xODogc1xuMTk6IHRcbjIwOiB1XG4yMTogdlxuMjI6IHdcbjIzOiB4XG4yNDogeVxuMjU6IHpcbiIpKSxtZHgoInAiLG51bGwsIldlIGNhbiBhbHNvIHVucGFjayBkaWN0aW9uYXJpZXMgaW4gYSBzaW1pbGFyIG1hdHRlcjoiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPj4+IG15X2RpY3Rcbnsnam9iJzogJ0RldmVsb3BlcicsICduYW1lJzogJ0Rlbm5pcycsICdhZ2UnOiAyNCwgJ3N0YXRlJzogJ05ldyBTb3V0aCBXYWxlcyd9XG4+Pj4gZm9yIGtleSwgdmFsdWUgaW4gbXlfZGljdC5pdGVtcygpOlxuLi4uICAgICBwcmludCgne306IHt9Jy5mb3JtYXQoa2V5LnRpdGxlKCksIHZhbHVlKSlcbi4uLlxuSm9iOiBEZXZlbG9wZXJcbk5hbWU6IERlbm5pc1xuQWdlOiAyNFxuU3RhdGU6IE5ldyBTb3V0aCBXYWxlc1xuIikpLG1keCgicCIsbnVsbCwiQ3JlYXRlIGEgZnVuY3Rpb24gbmFtZWQgY29tYm8oKSB0aGF0IHRha2VzIHR3byBpdGVyYWJsZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIHR1cGxlcy4gRWFjaCB0dXBsZSBzaG91bGQgaG9sZCB0aGUgZmlyc3QgaXRlbSBpbiBlYWNoIGxpc3QsIHRoZW4gdGhlIHNlY29uZCBzZXQsIHRoZW4gdGhlIHRoaXJkLCBhbmQgc28gb24uIEFzc3VtZSB0aGUgaXRlcmFibGVzIHdpbGwgYmUgdGhlIHNhbWUgbGVuZ3RoLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJkZWYgY29tYm8oaXRlcjEsIGl0ZXIyKTpcbiAgICByZXQgPSBbXVxuICAgIGxlbmd0aCA9IGxlbihpdGVyMSlcbiAgICBjb3VudGVyID0gMFxuICAgIHdoaWxlIGNvdW50ZXIgPCBsZW5ndGg6XG4gICAgICAgIHJldC5hcHBlbmQoKGl0ZXIxW2NvdW50ZXJdLGl0ZXIyW2NvdW50ZXJdKSlcbiAgICAgICAgY291bnRlciArPSAxXG4gICAgcmV0dXJuIHJldFxuXG4jIGJldHRlciBhbHRlcm5hdGl2ZXNcblxuZGVmIGNvbWJvKGl0ZXJhYmxlXzEsIGl0ZXJhYmxlXzIpOlxuICBsaXN0X29mX3R1cGxlcyA9IFtdXG4gIGZvciBpbmRleCBpbiByYW5nZShsZW4oaXRlcmFibGVfMSkpOlxuICAgIGxpc3Rfb2ZfdHVwbGVzLmFwcGVuZCgoaXRlcmFibGVfMVtpbmRleF0sIGl0ZXJhYmxlXzJbaW5kZXhdKSlcblxuICByZXR1cm4gbGlzdF9vZl90dXBsZXNcblxuZGVmIGNvbWJvKGl0ZXJhYmxlXzEsIGl0ZXJhYmxlXzIpOlxuICBsaXN0X29mX3R1cGxlcyA9IFtdXG4gIGZvciBpbmRleCwgaXRlbTIgaW4gZW51bWVyYXRlKGl0ZXJhYmxlXzIpOlxuICAgIGxpc3Rfb2ZfdHVwbGVzLmFwcGVuZCggKGl0ZXJhYmxlXzFbaW5kZXhdLCBpdGVtMikgKVxuXG4gIHJldHVybiBsaXN0X29mX3R1cGxlc1xuXG5kZWYgY29tYm8oaXRlcmFibGVfMSwgaXRlcmFibGVfMik6XG4gIHJldHVybiBsaXN0KHppcChpdGVyYWJsZV8xLCBpdGVyYWJsZV8yKSlcblxuZGVmIGNvbWJvKGl0ZXIxLCBpdGVyMik6XG4gIGNvbWJvX2xpc3QgPSBbXVxuICBmb3IgaW5kZXgsIHZhbHVlIGluIGVudW1lcmF0ZShpdGVyMSk6XG4gICAgdHVwbGUgPSB2YWx1ZSwgaXRlcjJbaW5kZXhdXG4gICAgY29tYm9fbGlzdC5hcHBlbmQodHVwbGUpXG4gIHJldHVybiBjb21ib19saXN0XG4iKSkpO31pZih0eXBlb2YgTURYQ29udGVudCE9PSd1bmRlZmluZWQnJiZNRFhDb250ZW50JiZNRFhDb250ZW50PT09T2JqZWN0KE1EWENvbnRlbnQpJiZPYmplY3QuaXNFeHRlbnNpYmxlKE1EWENvbnRlbnQpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoTURYQ29udGVudCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiTURYQ29udGVudCIsZmlsZW5hbWU6Im1hbnVhbC9QeXRob24vUHl0aG9uLUNvbGxlY3Rpb25zLm1kIn19KTt9TURYQ29udGVudC5pc01EWENvbXBvbmVudD10cnVlOw=="},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Python-Collections.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"intro-to-python-collections\"\n    }}>{`Intro to Python Collections`}</h2>\n    <p>{`Appending and adding to lists.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`### a_list=[1,2,3]\n### a_list\na_list.append([4,5]) # [1,2,3,[4,5]]\nour_list = list(range(10))\n### our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n### our_list + [10,11,12]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n### our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n### our_list=our_list+[10,11,12]\n### our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n`}</code></pre>\n    <p>{`For splitting strings themselves we can use `}<inlineCode parentName=\"p\">{`str.split(str=\"\", num=string.count(str))`}</inlineCode></p>\n    <h2 {...{\n      \"id\": \"extending-collections\"\n    }}>{`Extending Collections`}</h2>\n    <p>{`Normally cleaner for larger lists than the `}<inlineCode parentName=\"p\">{`+`}</inlineCode>{` symbol.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`>>> our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n>>> our_list.extend(range(13, 20))\n>>> our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n`}</code></pre>\n    <p>{`How do add new items inside the list?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`>>> alpha= list('acdf')\n>>> alpha\n['a', 'c', 'd', 'f']\n>>> alpha.insert(1,'b')\n>>> alpha\n['a', 'b', 'c', 'd', 'f']\n>>> alpha.insert(4,'e')\n>>> alpha\n['a', 'b', 'c', 'd', 'e', 'f']\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"shopping-list\"\n    }}>{`Shopping List`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`# note - you should use enumerate once you get there\n>>> def show_help():\n     print(\"\\\\nDoing a print_\")\n\n>>> def show_list():\n     count=1\n     for item in shopping_list:\n             print(\"{}: {}\".format(count, item))\n             count+=1\n`}</code></pre>\n    <p>{`Other helpful use cases...`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`while True:\n    #do stuff\n    new_stuff = input(\"> \")\n\n    if new_stuff == \"DONE\":\n        print('Done')\n        break\n    elif\n        #do other stuff\n        break\n    else\n        ...\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"removing-items-from-a-list\"\n    }}>{`Removing Items from a List`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`a_list=list('abzde')\na_list.index('z')\ndel a_list[2]\n\na_string = \"Hello\"\n# this will delete the string - although the del can't be used to delete within the string\n# strings themselves are immutable\ndel a_string\n\n# remove for the list\nmy_list = [1,2,3,1]\n# remove ONLY removes the first instance from the list\nmy_list.remove(1)\nmy_list\n# [2,3,1]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"removing-vowels-from-a-list-of-words-and-capitalising-them\"\n    }}>{`Removing vowels from a list of words and capitalising them`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`names = [\"Dennis\", \"Billy\", \"Trojan\", \"Horse\"]\nvowels = list('aeiou')\noutput = []\n\nfor name in names:\n    name_list = list(name.lower())\n\n    for vowel in vowels:\n        while True:\n            try:\n                state_list.remove(vowel)\n            except:\n                break\n    output.append(''.join(name_list).capitalize())\n\nprint(output)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"pop-an-item-from-the-list\"\n    }}>{`Pop an item from the list`}</h2>\n    <p>{`pop() removes an item by index but gives us the item.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`names = [\"Dennis\", \"Billy\", \"Trojan\", \"Horse\"]\nfirst = names.pop() // gives the first name\nanother = names.pop(2) // gives index 3\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`// Quiz Challenge\n\n// 1. Move the '1' to the front of the list\n\nthe_list = [\"a\", 2, 3, 1, False, [1, 2, 3]]\n\n# Your code goes below here\nthe_list.insert(0, the_list.pop(3))\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"slices\"\n    }}>{`Slices`}</h2>\n    <p>{`Slices mean we can get back more than one item from a list. We call this `}<inlineCode parentName=\"p\">{`slicing`}</inlineCode>{`.`}</p>\n    <p>{`Something important to not is the useability of have the `}{`[:]`}{` call for a copy of the list!`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_string=\"Hello there!\"\nmy_string[0:5]\n\nmy_list=list(range(1,6))\nmy_list[0:2] // same as my_list[:2]\nmy_list[2:len(my_list)]\n\nmy_list[1:]\nmy_list[:] // gets back a copy of the list\n\nmy_new_list = [4,2,1,3,5]\nmy_new_list.sort()\nmy_new_list\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"slicing-with-a-step\"\n    }}>{`Slicing with a Step`}</h2>\n    <p>{`How can we slice that move backward or that skip items?`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list=list(range(20))\n\n# let's get the even numbers\nmy_list[::2]\n\"Testing\"[::2]\n\n# reversing\n\"Slap\"[::-1]\n\n# getting the middle slice - must swap positions!\nmy_list[8:2:-1]\n\n# negative indexes will also give you the positions from the end\nmy_list[-1]\n\n# example of grabbing the first four iterables through a Python function\ndef first_4(iter):\n    return iter[:4]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"deleting-or-replacing-slices\"\n    }}>{`Deleting or Replacing Slices`}</h2>\n    <p>{`We can delete and replace with lists.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list = [1,2, 'a', 'b', 5,6,'f','g']\n\n# what if I just want letters?\nmy_list[4:7] = ['e','f']\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Code Challenge`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`def sillycase(c):\n    return c[:round(len(c) / 2)].lower() + c[round(len(c) / 2):].upper()\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"dictionaries\"\n    }}>{`Dictionaries`}</h2>\n    <p>{`Key-Value organisation. They themselves do not have an order.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_dict = {'name': 'Dennis', 'job': 'Software Engineer'}\n\n# to access it, you need to use the key name\nmy_dict['name']\n`}</code></pre>\n    <p>{`Dictionaries can contain anything - even your own custom classes.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`named_dict = { 'name' : { 'first' : 'Dennis', 'last': 'OKeeffe'} }\nnamed_dict['name']['first']\n\n# tuple game dict\ngame_dict = {(1,2) : True}\ngame_dict[(1,2)]\n`}</code></pre>\n    <p>{`Challenge: Check if a dict key is in the list`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def members(dict, keys):\n    counter = 0\n    for key in dict:\n        if key in keys:\n            counter = counter + 1\n    return counter\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"managing-keys\"\n    }}>{`Managing Keys`}</h2>\n    <p>{`We can `}<inlineCode parentName=\"p\">{`del`}</inlineCode>{` keys etc similar to the way we do it for keys.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_dict['test'] = 'value'\n>>> my_dict\n{'test': 'value', 'job': 'Software Engineer', 'name': 'Dennis'}\n>>> del my_dict['test']\n>>> my_dict\n{'job': 'Software Engineer', 'name': 'Dennis'}\n\n# we can use update for multiple keys etc\n>>> my_dict.update({'job': 'Developer', 'age': 24, 'state': 'New South Wales'})\n>>> my_dict\n{'job': 'Developer', 'name': 'Dennis', 'age': 24, 'state': 'New South Wales'}\n`}</code></pre>\n    <p>{`Challenge: Create a function named word_count() that takes a string. Return a dictionary with each word in the string as the key and the number of times it appears as the value.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def word_count(sentence):\n    new_dict = {}\n    word_list = sentence.split()\n    count = 0\n\n    for original_word in word_list:\n        if original_word not in new_dict:\n            count = 0\n            for comparison_word in word_list:\n                if original_word == comparison_word:\n                    count += 1\n                    new_dict.update({original_word: count})\n    return new_dict\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"unpacking-dictionaries\"\n    }}>{`Unpacking Dictionaries`}</h2>\n    <p>{`You can give placeholders a name and use dictionaries to make it a little easier.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_string = \"Hi my name is {name} and I live in {state}\"\n>>> my_string\n'Hi my name is {name} and I live in {state}'\n>>> my_string.format('Dennis', 'Sydney')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'name'\n>>> my_string.format('name'='Dennis', state='Sydney')\n  File \"<stdin>\", line 1\nSyntaxError: keyword can't be an expression\n>>> my_string.format(name='Dennis', state='Sydney')\n'Hi my name is Dennis and I live in Sydney'\n\n# how do we make this programmatic?\n>>> test_dict = {'name':'Dennis', 'state':'Sydney'}\n>>> my_string.format(**test_dict)\n'Hi my name is Dennis and I live in Sydney'\n`}</code></pre>\n    <p>{`Code Challenge: Create a function named string_factory that accepts a list of dictionaries and a string. Return a new list built by using .format() on the string, filled in by each of the dictionaries in the list.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`dicts = [\n    {'name': 'Michelangelo',\n     'food': 'PIZZA'},\n    {'name': 'Garfield',\n     'food': 'lasanga'},\n    {'name': 'Walter',\n     'food': 'pancakes'},\n    {'name': 'Galactus',\n     'food': 'worlds'}\n]\n\nstring = \"Hi, I'm {name} and I love to eat {food}!\"\n\ndef string_factory(list_of_dict, str):\n    new_list = []\n    for ind_list in list_of_dict:\n        new_list.append(str.format(**ind_list))\n    return new_list\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"dictionary-iteration\"\n    }}>{`Dictionary Iteration`}</h2>\n    <p>{`Again, Dictionaries in Python do not have a set order, but we can still iterate over them.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_dict\n{'job': 'Developer', 'name': 'Dennis', 'age': 24, 'state': 'New South Wales'}\n>>> for thing in my_dict:\n...     print(thing)\n...\njob\nname\nage\nstate\n\n>>> for key in my_dict:\n...     print(my_dict[key])\n...\nDeveloper\nDennis\n24\nNew South Wales\n\n>>> for value in my_dict.values():\n...     print(value)\n...\nDeveloper\nDennis\n24\nNew South Wales\n`}</code></pre>\n    <p>{`Create a function named most-classes that takes a dictionary of teachers. Each key is a teacher's name and their value is a list of classes they've taught. most-classes should return the teacher with the most classes.`}</p>\n    <p>{`Next, create a function named num_teachers that takes the same dictionary of teachers and classes. Return the total number of teachers.`}</p>\n    <p>{`Now, create a function named stats that takes the teacher dictionary. Return a list of lists in the format `}{`[`}<inlineCode parentName=\"p\">{`<teacher name>`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`<number of classes>`}</inlineCode>{`]`}{`. For example, one item in the list would be `}{`['Dave McFarland', 1]`}{`.`}</p>\n    <p>{`Great work! Finally, write a function named courses that takes the teachers dictionary. It should return a single list of all of the courses offered by all of the teachers.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def most_classes(teachers):\n    highest_value = 0\n    teacher_name = \"\"\n    for teacher in teachers:\n        if len(teachers[teacher]) > highest_value:\n            highest_value = len(teachers[teacher])\n            teacher_name = teacher\n    return teacher_name\n\ndef num_teachers(teachers):\n    return len(teachers)\n\ndef stats(teachers):\n    return_list = []\n    for teacher in teachers:\n        return_list.append([teacher, len(teachers[teacher])])\n    return return_list\n\ndef courses(teachers):\n    single_courses = []\n    for courses in teachers.values():\n        for course in courses:\n            if course not in single_courses:\n                single_courses.append(course)\n    return single_courses\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"tuples\"\n    }}>{`Tuples`}</h2>\n    <p>{`Lists themselves can be mutated, but sometimes we want the collections to stay the same. That's where tuples come in. They themselves are immutable.`}</p>\n    <p>{`Tuples do not support item assignment.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> tupleTest = (1,2,3)\n>>> tupleTest\n(1, 2, 3)\n>>> my_second_tuple = 1,2,3\n>>> my_second_tuple\n(1, 2, 3)\n>>> my_third_tuple = tuple([1,2,3])\n>>> my_third_tuple\n(1, 2, 3)\n>>> dir(tuple)\n['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuple-packing-and-unpacking\"\n    }}>{`Tuple Packing and Unpacking`}</h2>\n    <p>{`Here we create a tuple that has valued assigned by another tuple. It's referred to as `}<inlineCode parentName=\"p\">{`simulatneous assignment`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> a,b = 1,2\n>>> a\n1\n>>> b\n2\n\n# unpacking\n>>> c = (3,4)\n>>> (d,e) = c\n>>> d\n3\n>>> e\n4\n\n# packing\n>>> f = d,e\n>>> f\n(3, 4)\n>>> f == c\nTrue\n\n# swapping the value\n>>> del a\n>>> del b\n>>> a = 1\n>>> b = 2\n>>> a,b = b,a\n>>> a\n2\n>>> b\n1\n\n# function example\n>>> def my_func():\n...     return 1,2,3\n...\n>>> my_func()\n(1, 2, 3)\n>>> a,b,c = my_func()\n>>> a\n1\n>>> b\n2\n>>> c\n3\n`}</code></pre>\n    <p>{`Challenge: Create a function named stringcases that takes a string and returns a tuple of four versions of the string: uppercased, lowercased, titlecased (where every word's first letter is capitalized), and a reversed version of the string.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def stringcases(str):\n    uppercased = str.upper()\n    lowercased = str.lower()\n    titlecased = str.title()\n    reverse = str[::-1]\n    return uppercased, lowercased, titlecased, reverse\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuples-with-functions\"\n    }}>{`Tuples with functions`}</h2>\n    <p>{`We can use enumerate for some packing etc.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> alpha = list('abcdefghijklmnopqrstuvwxyz')\n>>> alpha\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n>>> dir(enumerate)\n['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'next']\n# prints the help\n>>> help(enumerate)\n>>> for (index, letter) in enumerate(alpha):\n...     print('{}: {}').format(index,letter)\n...\n0: a\n1: b\n2: c\n3: d\n4: e\n5: f\n6: g\n7: h\n8: i\n9: j\n10: k\n11: l\n12: m\n13: n\n14: o\n15: p\n16: q\n17: r\n18: s\n19: t\n20: u\n21: v\n22: w\n23: x\n24: y\n25: z\n\n>>> for step in enumerate(alpha):\n...     print('{}: {}'.format(*step))\n...\n0: a\n1: b\n2: c\n3: d\n4: e\n5: f\n6: g\n7: h\n8: i\n9: j\n10: k\n11: l\n12: m\n13: n\n14: o\n15: p\n16: q\n17: r\n18: s\n19: t\n20: u\n21: v\n22: w\n23: x\n24: y\n25: z\n`}</code></pre>\n    <p>{`We can also unpack dictionaries in a similar matter:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_dict\n{'job': 'Developer', 'name': 'Dennis', 'age': 24, 'state': 'New South Wales'}\n>>> for key, value in my_dict.items():\n...     print('{}: {}'.format(key.title(), value))\n...\nJob: Developer\nName: Dennis\nAge: 24\nState: New South Wales\n`}</code></pre>\n    <p>{`Create a function named combo() that takes two iterables and returns a list of tuples. Each tuple should hold the first item in each list, then the second set, then the third, and so on. Assume the iterables will be the same length.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def combo(iter1, iter2):\n    ret = []\n    length = len(iter1)\n    counter = 0\n    while counter < length:\n        ret.append((iter1[counter],iter2[counter]))\n        counter += 1\n    return ret\n\n# better alternatives\n\ndef combo(iterable_1, iterable_2):\n  list_of_tuples = []\n  for index in range(len(iterable_1)):\n    list_of_tuples.append((iterable_1[index], iterable_2[index]))\n\n  return list_of_tuples\n\ndef combo(iterable_1, iterable_2):\n  list_of_tuples = []\n  for index, item2 in enumerate(iterable_2):\n    list_of_tuples.append( (iterable_1[index], item2) )\n\n  return list_of_tuples\n\ndef combo(iterable_1, iterable_2):\n  return list(zip(iterable_1, iterable_2))\n\ndef combo(iter1, iter2):\n  combo_list = []\n  for index, value in enumerate(iter1):\n    tuple = value, iter2[index]\n    combo_list.append(tuple)\n  return combo_list\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}