{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/R/R-Intro.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/R/R-Intro.md","mtime":1562563032081},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiZGl2Iix7aWQ6IjEifSksbWR4KCJociIsbnVsbCksbWR4KCJoMiIseyJpZCI6InItMS1ob3ctaXQtd29ya3MifSwiUi0xOiBIb3cgaXQgV29ya3MiKSxtZHgoInAiLG51bGwsIkluIHRoZSBlZGl0b3Igb24gdGhlIHJpZ2h0IHlvdSBzaG91bGQgdHlwZSBSIGNvZGUgdG8gc29sdmUgdGhlIGV4ZXJjaXNlcy4gV2hlbiB5b3UgaGl0IHRoZSAnU3VibWl0IEFuc3dlcicgYnV0dG9uLCBldmVyeSBsaW5lIG9mIGNvZGUgaXMgaW50ZXJwcmV0ZWQgYW5kIGV4ZWN1dGVkIGJ5IFIgYW5kIHlvdSBnZXQgYSBtZXNzYWdlIHdoZXRoZXIgb3Igbm90IHlvdXIgY29kZSB3YXMgY29ycmVjdC4gVGhlIG91dHB1dCBvZiB5b3VyIFIgY29kZSBpcyBzaG93biBpbiB0aGUgY29uc29sZSBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyLiIpLG1keCgicCIsbnVsbCwiUiBtYWtlcyB1c2Ugb2YgdGhlICMgc2lnbiB0byBhZGQgY29tbWVudHMsIHNvIHRoYXQgeW91IGFuZCBvdGhlcnMgY2FuIHVuZGVyc3RhbmQgd2hhdCB0aGUgUiBjb2RlIGlzIGFib3V0LiBKdXN0IGxpa2UgVHdpdHRlciEgQ29tbWVudHMgYXJlIG5vdCBydW4gYXMgUiBjb2RlLCBzbyB0aGV5IHdpbGwgbm90IGluZmx1ZW5jZSB5b3VyIHJlc3VsdC4gRm9yIGV4YW1wbGUsIENhbGN1bGF0ZSAzICsgNCBpbiB0aGUgZWRpdG9yIG9uIHRoZSByaWdodCBpcyBhIGNvbW1lbnQuIiksbWR4KCJwIixudWxsLCJZb3UgY2FuIGFsc28gZXhlY3V0ZSBSIGNvbW1hbmRzIHN0cmFpZ2h0IGluIHRoZSBjb25zb2xlLiBUaGlzIGlzIGEgZ29vZCB3YXkgdG8gZXhwZXJpbWVudCB3aXRoIFIgY29kZSwgYXMgeW91ciBzdWJtaXNzaW9uIGlzIG5vdCBjaGVja2VkIGZvciBjb3JyZWN0bmVzcy4iKSxtZHgoImRpdiIse2lkOiIyIn0pLG1keCgiaDMiLHsiaWQiOiItLS0tLWFyaXRobWV0aWMtd2l0aC1yIn0sIi0tLS0gQXJpdGhtZXRpYyB3aXRoIFIiKSxtZHgoInAiLG51bGwsIkluIGl0cyBtb3N0IGJhc2ljIGZvcm0sIFIgY2FuIGJlIHVzZWQgYXMgYSBzaW1wbGUgY2FsY3VsYXRvci4gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBhcml0aG1ldGljIG9wZXJhdG9yczoiKSxtZHgoInAiLG51bGwsIkFkZGl0aW9uOiArXG5TdWJ0cmFjdGlvbjogLVxuTXVsdGlwbGljYXRpb246ICIsIioiLCJcbkRpdmlzaW9uOiAvXG5FeHBvbmVudGlhdGlvbjogXlxuTW9kdWxvOiAlJSIpLG1keCgicCIsbnVsbCwiVGhlIGxhc3QgdHdvIG1pZ2h0IG5lZWQgc29tZSBleHBsYWluaW5nOiAtIFRoZSBeIG9wZXJhdG9yIHJhaXNlcyB0aGUgbnVtYmVyIHRvIGl0cyBsZWZ0IHRvIHRoZSBwb3dlciBvZiB0aGUgbnVtYmVyIHRvIGl0cyByaWdodDogZm9yIGV4YW1wbGUgM14yIGlzIDkuIC0gVGhlIG1vZHVsbyByZXR1cm5zIHRoZSByZW1haW5kZXIgb2YgdGhlIGRpdmlzaW9uIG9mIHRoZSBudW1iZXIgdG8gdGhlIGxlZnQgYnkgdGhlIG51bWJlciBvbiBpdHMgcmlnaHQsIGZvciBleGFtcGxlIDUgbW9kdWxvIDMgb3IgNSAlJSAzIGlzIDIuIiksbWR4KCJkaXYiLHtpZDoiMyJ9KSxtZHgoImgzIix7ImlkIjoiLS0tLS12YXJpYWJsZS1hc3NpZ25tZW50In0sIi0tLS0gVmFyaWFibGUgQXNzaWdubWVudCIpLG1keCgicCIsbnVsbCwiQSBiYXNpYyBjb25jZXB0IGluIChzdGF0aXN0aWNhbCkgcHJvZ3JhbW1pbmcgaXMgY2FsbGVkIGEgdmFyaWFibGUuIiksbWR4KCJwIixudWxsLCJBIHZhcmlhYmxlIGFsbG93cyB5b3UgdG8gc3RvcmUgYSB2YWx1ZSAoZS5nLiA0KSBvciBhbiBvYmplY3QgKGUuZy4gYSBmdW5jdGlvbiBkZXNjcmlwdGlvbikgaW4gUi4gWW91IGNhbiB0aGVuIGxhdGVyIHVzZSB0aGlzIHZhcmlhYmxlJ3MgbmFtZSB0byBlYXNpbHkgYWNjZXNzIHRoZSB2YWx1ZSBvciB0aGUgb2JqZWN0IHRoYXQgaXMgc3RvcmVkIHdpdGhpbiB0aGlzIHZhcmlhYmxlLiIpLG1keCgicCIsbnVsbCwiWW91IGNhbiBhc3NpZ24gYSB2YWx1ZSA0IHRvIGEgdmFyaWFibGUgbXlfdmFyIHdpdGggdGhlIGNvbW1hbmQiKSxtZHgoInAiLG51bGwsIm15X3ZhciA8LSA0IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQXNzaWduIHRoZSB2YWx1ZSA0MiB0byB4XG54IDwtIDQyXG5cbiMgUHJpbnQgb3V0IHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgeFxueFxuXG4jIEFzc2lnbiBhIHZhbHVlIHRvIHRoZSB2YXJpYWJsZXMgbXlfYXBwbGVzIGFuZCBteV9vcmFuZ2VzXG5teV9hcHBsZXMgPC0gNVxubXlfb3JhbmdlcyA8LSA2XG5cbiMgQWRkIHRoZXNlIHR3byB2YXJpYWJsZXMgdG9nZXRoZXJcbm15X2FwcGxlcyArIG15X29yYW5nZXNcblxuIyBDcmVhdGUgdGhlIHZhcmlhYmxlIG15X2ZydWl0XG5teV9mcnVpdCA8LSBteV9hcHBsZXMgKyBteV9vcmFuZ2VzXG4iKSksbWR4KCJkaXYiLHtpZDoiNCJ9KSxtZHgoImgzIix7ImlkIjoiLS0tLS1iYXNpYy1kYXRhLXR5cGVzLWluLXIifSwiLS0tLSBCYXNpYyBkYXRhIHR5cGVzIGluIFIiKSxtZHgoInAiLG51bGwsIlIgd29ya3Mgd2l0aCBudW1lcm91cyBkYXRhIHR5cGVzLiBTb21lIG9mIHRoZSBtb3N0IGJhc2ljIHR5cGVzIHRvIGdldCBzdGFydGVkIGFyZToiKSxtZHgoInAiLG51bGwsIkRlY2ltYWxzIHZhbHVlcyBsaWtlIDQuNSBhcmUgY2FsbGVkICIsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIm51bWVyaWNzIiksIi5cbk5hdHVyYWwgbnVtYmVycyBsaWtlIDQgYXJlIGNhbGxlZCBpbnRlZ2Vycy4gSW50ZWdlcnMgYXJlIGFsc28gIixtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwibnVtZXJpY3MiKSwiLlxuQm9vbGVhbiB2YWx1ZXMgKFRSVUUgb3IgRkFMU0UpIGFyZSBjYWxsZWQgIixtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwibG9naWNhbCIpLCIuXG5UZXh0IChvciBzdHJpbmcpIHZhbHVlcyBhcmUgY2FsbGVkICIsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sImNoYXJhY3RlcnMiKSwiLlxuTm90ZSBob3cgdGhlIHF1b3RhdGlvbiBtYXJrcyBvbiB0aGUgcmlnaHQgaW5kaWNhdGUgdGhhdCBcInNvbWUgdGV4dFwiIGlzIGEgIixtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiY2hhcmFjdGVyIiksIi4iKSxtZHgoInAiLG51bGwsIk5vdGUgdGhhdCBSIGlzIGNhc2Ugc2Vuc2l0aXZlLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIENoYW5nZSBteV9udW1lcmljIHRvIGJlIDQyXG5teV9udW1lcmljIDwtIDQyXG5cbiMgQ2hhbmdlIG15X2NoYXJhY3RlciB0byBiZSBcInVuaXZlcnNlXCJcbm15X2NoYXJhY3RlciA8LSBcInVuaXZlcnNlXCJcblxuIyBDaGFuZ2UgbXlfbG9naWNhbCB0byBiZSBGQUxTRVxubXlfbG9naWNhbCA8LSBGQUxTRVxuXG4jIERlY2xhcmUgdmFyaWFibGVzIG9mIGRpZmZlcmVudCB0eXBlc1xubXlfbnVtZXJpYyA8LSA0MlxubXlfY2hhcmFjdGVyIDwtIFwidW5pdmVyc2VcIlxubXlfbG9naWNhbCA8LSBGQUxTRVxuXG4jIENoZWNrIGNsYXNzIG9mIG15X251bWVyaWNcbmNsYXNzKG15X251bWVyaWMpXG5cbiMgQ2hlY2sgY2xhc3Mgb2YgbXlfY2hhcmFjdGVyXG5jbGFzcyhteV9jaGFyYWN0ZXIpXG5cbiMgQ2hlY2sgY2xhc3Mgb2YgbXlfbG9naWNhbFxuY2xhc3MobXlfbG9naWNhbClcbiIpKSxtZHgoImRpdiIse2lkOiJ2ZWN0b3JzIn0pLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJyLTItdmVjdG9ycyJ9LCJSLTI6IFZlY3RvcnMiKSxtZHgoInAiLG51bGwsIkluIFIsIHlvdSBjcmVhdGUgYSB2ZWN0b3Igd2l0aCB0aGUgY29tYmluZSBmdW5jdGlvbiBjKCkuIFlvdSBwbGFjZSB0aGUgdmVjdG9yIGVsZW1lbnRzIHNlcGFyYXRlZCBieSBhIGNvbW1hIGJldHdlZW4gdGhlIHBhcmVudGhlc2VzLiBGb3IgZXhhbXBsZToiKSxtZHgoInAiLG51bGwsIm51bWVyaWNfdmVjdG9yIDwtIGMoMSwgMiwgMylcbmNoYXJhY3Rlcl92ZWN0b3IgPC0gYyhcImFcIiwgXCJiXCIsIFwiY1wiKVxuT25jZSB5b3UgaGF2ZSBjcmVhdGVkIHRoZXNlIHZlY3RvcnMgaW4gUiwgeW91IGNhbiB1c2UgdGhlbSB0byBkbyBjYWxjdWxhdGlvbnMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm51bWVyaWNfdmVjdG9yIDwtIGMoMSwgMTAsIDQ5KVxuY2hhcmFjdGVyX3ZlY3RvciA8LSBjKFwiYVwiLCBcImJcIiwgXCJjXCIpXG5cbiMgQ29tcGxldGUgdGhlIGNvZGUgZm9yIGJvb2xlYW5fdmVjdG9yXG5ib29sZWFuX3ZlY3RvciA8LSBjKFRSVUUsIEZBTFNFLCBUUlVFKVxuIikpLG1keCgiZGl2Iix7aWQ6InZlY3RvcnMyIn0pLG1keCgiaDMiLHsiaWQiOiItLS0tLW5hbWluZy1hLXZlY3RvciJ9LCItLS0tIE5hbWluZyBhIFZlY3RvciIpLG1keCgicCIsbnVsbCwiWW91IGNhbiBnaXZlIGEgbmFtZSB0byB0aGUgZWxlbWVudHMgb2YgYSB2ZWN0b3Igd2l0aCB0aGUgbmFtZXMoKSBmdW5jdGlvbi4gSGF2ZSBhIGxvb2sgYXQgdGhpcyBleGFtcGxlOiIpLG1keCgicCIsbnVsbCwic29tZV92ZWN0b3IgPC0gYyhcIkpvaG4gRG9lXCIsIFwicG9rZXIgcGxheWVyXCIpXG5uYW1lcyhzb21lX3ZlY3RvcikgPC0gYyhcIk5hbWVcIiwgXCJQcm9mZXNzaW9uXCIpXG5UaGlzIGNvZGUgZmlyc3QgY3JlYXRlcyBhIHZlY3RvciBzb21lX3ZlY3RvciBhbmQgdGhlbiBnaXZlcyB0aGUgdHdvIGVsZW1lbnRzIGEgbmFtZS4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgYXNzaWduZWQgdGhlIG5hbWUgTmFtZSwgd2hpbGUgdGhlIHNlY29uZCBlbGVtZW50IGlzIGxhYmVsZWQgUHJvZmVzc2lvbi4gUHJpbnRpbmcgdGhlIGNvbnRlbnRzIHRvIHRoZSBjb25zb2xlIHlpZWxkcyBmb2xsb3dpbmcgb3V0cHV0OiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIgICAgICAgICAgTmFtZSAgICAgUHJvZmVzc2lvblxuICAgIFwiSm9obiBEb2VcIiBcInBva2VyIHBsYXllclwiXG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgUG9rZXIgd2lubmluZ3MgZnJvbSBNb25kYXkgdG8gRnJpZGF5XG5wb2tlcl92ZWN0b3IgPC0gYygxNDAsIC01MCwgMjAsIC0xMjAsIDI0MClcblxuIyBSb3VsZXR0ZSB3aW5uaW5ncyBmcm9tIE1vbmRheSB0byBGcmlkYXlcbnJvdWxldHRlX3ZlY3RvciA8LSBjKC0yNCwgLTUwLCAxMDAsIC0zNTAsIDEwKVxuXG4jIEFzc2lnbiBkYXlzIGFzIG5hbWVzIG9mIHBva2VyX3ZlY3RvclxubmFtZXMocG9rZXJfdmVjdG9yKSA8LSBjKFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIpXG5cbiMgQXNzaWduIGRheXMgYXMgbmFtZXMgb2Ygcm91bGV0dGVfdmVjdG9yc1xubmFtZXMocm91bGV0dGVfdmVjdG9yKSA8LWMoXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIilcblxuIyBQb2tlciB3aW5uaW5ncyBmcm9tIE1vbmRheSB0byBGcmlkYXlcbnBva2VyX3ZlY3RvciA8LSBjKDE0MCwgLTUwLCAyMCwgLTEyMCwgMjQwKVxuXG4jIFJvdWxldHRlIHdpbm5pbmdzIGZyb20gTW9uZGF5IHRvIEZyaWRheVxucm91bGV0dGVfdmVjdG9yIDwtIGMoLTI0LCAtNTAsIDEwMCwgLTM1MCwgMTApXG5cbiMgVGhlIHZhcmlhYmxlIGRheXNfdmVjdG9yXG5kYXlzX3ZlY3RvciA8LSBjKFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIpXG5cbiMgQXNzaWduIHRoZSBuYW1lcyBvZiB0aGUgZGF5IHRvIHJvdWxldHRlX3ZlY3RvciBhbmQgcG9rZXJfdmVjdG9yXG5uYW1lcyhwb2tlcl92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG5uYW1lcyhyb3VsZXR0ZV92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG5cbiMgQ2FsY3VsYXRpbmcgYSB0b3RhbCB2ZWN0b3JcbkFfdmVjdG9yIDwtIGMoMSwgMiwgMylcbkJfdmVjdG9yIDwtIGMoNCwgNSwgNilcblxuIyBUYWtlIHRoZSBzdW0gb2YgQV92ZWN0b3IgYW5kIEJfdmVjdG9yXG50b3RhbF92ZWN0b3IgPC0gQV92ZWN0b3IgKyBCX3ZlY3RvclxuXG4jIFByaW50IG91dCB0b3RhbF92ZWN0b3JcbnRvdGFsX3ZlY3RvclxuXG4jIyBFeCAzXG5cbiMgUG9rZXIgYW5kIHJvdWxldHRlIHdpbm5pbmdzIGZyb20gTW9uZGF5IHRvIEZyaWRheTpcbnBva2VyX3ZlY3RvciA8LSBjKDE0MCwgLTUwLCAyMCwgLTEyMCwgMjQwKVxucm91bGV0dGVfdmVjdG9yIDwtIGMoLTI0LCAtNTAsIDEwMCwgLTM1MCwgMTApXG5kYXlzX3ZlY3RvciA8LSBjKFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIpXG5uYW1lcyhwb2tlcl92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG5uYW1lcyhyb3VsZXR0ZV92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG5cbiMgVG90YWwgd2lubmluZ3Mgd2l0aCBwb2tlclxudG90YWxfcG9rZXIgPC0gc3VtKHBva2VyX3ZlY3RvcilcblxuIyBUb3RhbCB3aW5uaW5ncyB3aXRoIHJvdWxldHRlXG50b3RhbF9yb3VsZXR0ZSA8LSBzdW0ocm91bGV0dGVfdmVjdG9yKVxuXG4jIFRvdGFsIHdpbm5pbmdzIG92ZXJhbGxcbnRvdGFsX3dlZWsgPC0gdG90YWxfcm91bGV0dGUgKyB0b3RhbF9wb2tlclxuXG4jIFByaW50IG91dCB0b3RhbF93ZWVrXG50b3RhbF93ZWVrXG5cbiMjIEV4IDRcblxuIyBQb2tlciBhbmQgcm91bGV0dGUgd2lubmluZ3MgZnJvbSBNb25kYXkgdG8gRnJpZGF5OlxucG9rZXJfdmVjdG9yIDwtIGMoMTQwLCAtNTAsIDIwLCAtMTIwLCAyNDApXG5yb3VsZXR0ZV92ZWN0b3IgPC0gYygtMjQsIC01MCwgMTAwLCAtMzUwLCAxMClcbmRheXNfdmVjdG9yIDwtIGMoXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIilcbm5hbWVzKHBva2VyX3ZlY3RvcikgPC0gZGF5c192ZWN0b3Jcbm5hbWVzKHJvdWxldHRlX3ZlY3RvcikgPC0gZGF5c192ZWN0b3JcblxuIyBDYWxjdWxhdGUgdG90YWwgZ2FpbnMgZm9yIHBva2VyIGFuZCByb3VsZXR0ZVxudG90YWxfcG9rZXIgPC0gc3VtKHBva2VyX3ZlY3RvcilcbnRvdGFsX3JvdWxldHRlIDwtIHN1bShyb3VsZXR0ZV92ZWN0b3IpXG5cbiMgQ2hlY2sgaWYgeW91IHJlYWxpemVkIGhpZ2hlciB0b3RhbCBnYWlucyBpbiBwb2tlciB0aGFuIGluIHJvdWxldHRlXG50b3RhbF9wb2tlciA+IHRvdGFsX3JvdWxldHRlXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJWZWN0b3IgU2VsZWN0aW9uIikpLG1keCgiaDMiLHsiaWQiOiItLS0tLXZlY3Rvci1zZWxlY3Rpb24ifSwiLS0tLSBWZWN0b3IgU2VsZWN0aW9uIiksbWR4KCJoMSIseyJpZCI6InBva2VyLWFuZC1yb3VsZXR0ZS13aW5uaW5ncy1mcm9tLW1vbmRheS10by1mcmlkYXkifSwiUG9rZXIgYW5kIHJvdWxldHRlIHdpbm5pbmdzIGZyb20gTW9uZGF5IHRvIEZyaWRheToiKSxtZHgoInAiLG51bGwsInBva2VyX3ZlY3RvciA8LSBjKDE0MCwgLTUwLCAyMCwgLTEyMCwgMjQwKVxucm91bGV0dGVfdmVjdG9yIDwtIGMoLTI0LCAtNTAsIDEwMCwgLTM1MCwgMTApXG5kYXlzX3ZlY3RvciA8LSBjKFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIpXG5uYW1lcyhwb2tlcl92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG5uYW1lcyhyb3VsZXR0ZV92ZWN0b3IpIDwtIGRheXNfdmVjdG9yIiksbWR4KCJoMSIseyJpZCI6ImRlZmluZS1hLW5ldy12YXJpYWJsZS1iYXNlZC1vbi1hLXNlbGVjdGlvbiJ9LCJEZWZpbmUgYSBuZXcgdmFyaWFibGUgYmFzZWQgb24gYSBzZWxlY3Rpb24iKSxtZHgoInAiLG51bGwsInBva2VyX3dlZG5lc2RheSA8LSBwb2tlcl92ZWN0b3IiLCJbM10iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBQb2tlciBhbmQgcm91bGV0dGUgd2lubmluZ3MgZnJvbSBNb25kYXkgdG8gRnJpZGF5OlxucG9rZXJfdmVjdG9yIDwtIGMoMTQwLCAtNTAsIDIwLCAtMTIwLCAyNDApXG5yb3VsZXR0ZV92ZWN0b3IgPC0gYygtMjQsIC01MCwgMTAwLCAtMzUwLCAxMClcbmRheXNfdmVjdG9yIDwtIGMoXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIilcbm5hbWVzKHBva2VyX3ZlY3RvcikgPC0gZGF5c192ZWN0b3Jcbm5hbWVzKHJvdWxldHRlX3ZlY3RvcikgPC0gZGF5c192ZWN0b3JcblxuIyBEZWZpbmUgYSBuZXcgdmFyaWFibGUgYmFzZWQgb24gYSBzZWxlY3Rpb25cbnBva2VyX21pZHdlZWsgPC0gcG9rZXJfdmVjdG9yW2MoMiwzLDQpXVxucG9rZXJfbWlkd2Vla1xuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFBva2VyIGFuZCByb3VsZXR0ZSB3aW5uaW5ncyBmcm9tIE1vbmRheSB0byBGcmlkYXk6XG4+IHBva2VyX3ZlY3RvciA8LSBjKDE0MCwgLTUwLCAyMCwgLTEyMCwgMjQwKVxuPiByb3VsZXR0ZV92ZWN0b3IgPC0gYygtMjQsIC01MCwgMTAwLCAtMzUwLCAxMClcbj4gZGF5c192ZWN0b3IgPC0gYyhcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiKVxuPiBuYW1lcyhwb2tlcl92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG4+IG5hbWVzKHJvdWxldHRlX3ZlY3RvcikgPC0gZGF5c192ZWN0b3Jcbj5cbiMgRGVmaW5lIGEgbmV3IHZhcmlhYmxlIGJhc2VkIG9uIGEgc2VsZWN0aW9uXG4+IHJvdWxldHRlX3NlbGVjdGlvbl92ZWN0b3IgPC0gcm91bGV0dGVfdmVjdG9yWzI6NV1cbiIpKSxtZHgoInAiLG51bGwsIkFub3RoZXIgd2F5IHRvIHRhY2tsZSB0aGUgcHJldmlvdXMgZXhlcmNpc2UgaXMgYnkgdXNpbmcgdGhlIG5hbWVzIG9mIHRoZSB2ZWN0b3IgZWxlbWVudHMgKE1vbmRheSwgVHVlc2RheSwgLi4uKSBpbnN0ZWFkIG9mIHRoZWlyIG51bWVyaWMgcG9zaXRpb25zLiBGb3IgZXhhbXBsZSwiKSxtZHgoInAiLG51bGwsInBva2VyX3ZlY3RvciIsIltcIk1vbmRheVwiXSIsIlxud2lsbCBzZWxlY3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgcG9rZXJfdmVjdG9yIHNpbmNlIFwiTW9uZGF5XCIgaXMgdGhlIG5hbWUgb2YgdGhhdCBmaXJzdCBlbGVtZW50LiIpLG1keCgicCIsbnVsbCwiSnVzdCBsaWtlIHlvdSBkaWQgaW4gdGhlIHByZXZpb3VzIGV4ZXJjaXNlIHdpdGggbnVtZXJpY3MsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGVsZW1lbnQgbmFtZXMgdG8gc2VsZWN0IG11bHRpcGxlIGVsZW1lbnRzLCBmb3IgZXhhbXBsZToiKSxtZHgoInAiLG51bGwsInBva2VyX3ZlY3RvciIsIltjKFwiTW9uZGF5XCIsXCJUdWVzZGF5XCIpXSIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFBva2VyIGFuZCByb3VsZXR0ZSB3aW5uaW5ncyBmcm9tIE1vbmRheSB0byBGcmlkYXk6XG4+IHBva2VyX3ZlY3RvciA8LSBjKDE0MCwgLTUwLCAyMCwgLTEyMCwgMjQwKVxuPiByb3VsZXR0ZV92ZWN0b3IgPC0gYygtMjQsIC01MCwgMTAwLCAtMzUwLCAxMClcbj4gZGF5c192ZWN0b3IgPC0gYyhcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiKVxuPiBuYW1lcyhwb2tlcl92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG4+IG5hbWVzKHJvdWxldHRlX3ZlY3RvcikgPC0gZGF5c192ZWN0b3Jcbj5cbiMgU2VsZWN0IHBva2VyIHJlc3VsdHMgZm9yIE1vbmRheSwgVHVlc2RheSBhbmQgV2VkbmVzZGF5XG4+IHBva2VyX3N0YXJ0IDwtIHBva2VyX3ZlY3RvcltjKFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiKV1cbj5cbiMgQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIG9mIHRoZSBlbGVtZW50cyBpbiBwb2tlcl9zdGFydFxuPiBtZWFuKHBva2VyX3N0YXJ0KVxuWzFdIDM2LjY2NjY3XG4iKSksbWR4KCJkaXYiLHtpZDoidmVjdG9yczMifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tc2VsZWN0aW9uLWJ5LWNvbXBhcmlzb24ifSwiLS0tLSBTZWxlY3Rpb24gYnkgQ29tcGFyaXNvbiIpLG1keCgicCIsbnVsbCwiQnkgbWFraW5nIHVzZSBvZiBjb21wYXJpc29uIG9wZXJhdG9ycywgd2UgY2FuIGFwcHJvYWNoIHRoZSBwcmV2aW91cyBxdWVzdGlvbiBpbiBhIG1vcmUgcHJvYWN0aXZlIHdheS4iKSxtZHgoInAiLG51bGwsIlRoZSAobG9naWNhbCkgY29tcGFyaXNvbiBvcGVyYXRvcnMga25vd24gdG8gUiBhcmU6IiksbWR4KCJwIixudWxsLCI8IGZvciBsZXNzIHRoYW4iKSxtZHgoImJsb2NrcXVvdGUiLG51bGwsbWR4KCJwIix7cGFyZW50TmFtZToiYmxvY2txdW90ZSJ9LCJmb3IgZ3JlYXRlciB0aGFuXG48PSBmb3IgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG49IGZvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbj09IGZvciBlcXVhbCB0byBlYWNoIG90aGVyXG4hPSBub3QgZXF1YWwgdG8gZWFjaCBvdGhlclxuQXMgc2VlbiBpbiB0aGUgcHJldmlvdXMgY2hhcHRlciwgc3RhdGluZyA2ID4gNSByZXR1cm5zIFRSVUUuIFRoZSBuaWNlIHRoaW5nIGFib3V0IFIgaXMgdGhhdCB5b3UgY2FuIHVzZSB0aGVzZSBjb21wYXJpc29uIG9wZXJhdG9ycyBhbHNvIG9uIHZlY3RvcnMuIEZvciBleGFtcGxlOiIpLG1keCgicCIse3BhcmVudE5hbWU6ImJsb2NrcXVvdGUifSwiYyg0LCA1LCA2KSA+IDVcbiIsIlsxXSIsIiBGQUxTRSBGQUxTRSBUUlVFXG5UaGlzIGNvbW1hbmQgdGVzdHMgZm9yIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIHZlY3RvciBpZiB0aGUgY29uZGl0aW9uIHN0YXRlZCBieSB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciBpcyBUUlVFIG9yIEZBTFNFIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFBva2VyIGFuZCByb3VsZXR0ZSB3aW5uaW5ncyBmcm9tIE1vbmRheSB0byBGcmlkYXk6XG4+IHBva2VyX3ZlY3RvciA8LSBjKDE0MCwgLTUwLCAyMCwgLTEyMCwgMjQwKVxuPiByb3VsZXR0ZV92ZWN0b3IgPC0gYygtMjQsIC01MCwgMTAwLCAtMzUwLCAxMClcbj4gZGF5c192ZWN0b3IgPC0gYyhcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiKVxuPiBuYW1lcyhwb2tlcl92ZWN0b3IpIDwtIGRheXNfdmVjdG9yXG4+IG5hbWVzKHJvdWxldHRlX3ZlY3RvcikgPC0gZGF5c192ZWN0b3Jcbj5cbiMgV2hpY2ggZGF5cyBkaWQgeW91IG1ha2UgbW9uZXkgb24gcG9rZXI/XG4+IHNlbGVjdGlvbl92ZWN0b3IgPC0gcG9rZXJfdmVjdG9yID4gMFxuPlxuIyBQcmludCBvdXQgc2VsZWN0aW9uX3ZlY3RvclxuPiBzZWxlY3Rpb25fdmVjdG9yXG4gICBNb25kYXkgICBUdWVzZGF5IFdlZG5lc2RheSAgVGh1cnNkYXkgICAgRnJpZGF5XG4gICAgIFRSVUUgICAgIEZBTFNFICAgICAgVFJVRSAgICAgRkFMU0UgICAgICBUUlVFXG4iKSksbWR4KCJwIixudWxsLCJXb3JraW5nIHdpdGggY29tcGFyaXNvbnMgd2lsbCBtYWtlIHlvdXIgZGF0YSBhbmFseXRpY2FsIGxpZmUgZWFzaWVyLiBJbnN0ZWFkIG9mIHNlbGVjdGluZyBhIHN1YnNldCBvZiBkYXlzIHRvIGludmVzdGlnYXRlIHlvdXJzZWxmIChsaWtlIGJlZm9yZSksIHlvdSBjYW4gc2ltcGx5IGFzayBSIHRvIHJldHVybiBvbmx5IHRob3NlIGRheXMgd2hlcmUgeW91IHJlYWxpemVkIGEgcG9zaXRpdmUgcmV0dXJuIGZvciBwb2tlci4iKSxtZHgoInAiLG51bGwsIkluIHRoZSBwcmV2aW91cyBleGVyY2lzZXMgeW91IHVzZWQgc2VsZWN0aW9uX3ZlY3RvciA8LSBwb2tlcl92ZWN0b3IgPiAwIHRvIGZpbmQgdGhlIGRheXMgb24gd2hpY2ggeW91IGhhZCBhIHBvc2l0aXZlIHBva2VyIHJldHVybi4gTm93LCB5b3Ugd291bGQgbGlrZSB0byBrbm93IG5vdCBvbmx5IHRoZSBkYXlzIG9uIHdoaWNoIHlvdSB3b24sIGJ1dCBhbHNvIGhvdyBtdWNoIHlvdSB3b24gb24gdGhvc2UgZGF5cy4iKSxtZHgoInAiLG51bGwsIllvdSBjYW4gc2VsZWN0IHRoZSBkZXNpcmVkIGVsZW1lbnRzLCBieSBwdXR0aW5nIHNlbGVjdGlvbl92ZWN0b3IgYmV0d2VlbiB0aGUgc3F1YXJlIGJyYWNrZXRzIHRoYXQgZm9sbG93IHBva2VyX3ZlY3RvcjoiKSxtZHgoInAiLG51bGwsInBva2VyX3ZlY3RvciIsIltzZWxlY3Rpb25fdmVjdG9yXSIsIlxuUiBrbm93cyB3aGF0IHRvIGRvIHdoZW4geW91IHBhc3MgYSBsb2dpY2FsIHZlY3RvciBpbiBzcXVhcmUgYnJhY2tldHM6IGl0IHdpbGwgb25seSBzZWxlY3QgdGhlIGVsZW1lbnRzIHRoYXQgY29ycmVzcG9uZCB0byBUUlVFIGluIHNlbGVjdGlvbl92ZWN0b3IuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgUG9rZXIgYW5kIHJvdWxldHRlIHdpbm5pbmdzIGZyb20gTW9uZGF5IHRvIEZyaWRheTpcbj4gcG9rZXJfdmVjdG9yIDwtIGMoMTQwLCAtNTAsIDIwLCAtMTIwLCAyNDApXG4+IHJvdWxldHRlX3ZlY3RvciA8LSBjKC0yNCwgLTUwLCAxMDAsIC0zNTAsIDEwKVxuPiBkYXlzX3ZlY3RvciA8LSBjKFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIpXG4+IG5hbWVzKHBva2VyX3ZlY3RvcikgPC0gZGF5c192ZWN0b3Jcbj4gbmFtZXMocm91bGV0dGVfdmVjdG9yKSA8LSBkYXlzX3ZlY3RvclxuPlxuIyBXaGljaCBkYXlzIGRpZCB5b3UgbWFrZSBtb25leSBvbiBwb2tlcj9cbj4gc2VsZWN0aW9uX3ZlY3RvciA8LSBwb2tlcl92ZWN0b3IgPiAwXG4+XG4jIFNlbGVjdCBmcm9tIHBva2VyX3ZlY3RvciB0aGVzZSBkYXlzXG4+IHBva2VyX3dpbm5pbmdfZGF5cyA8LSBwb2tlcl92ZWN0b3Jbc2VsZWN0aW9uX3ZlY3Rvcl1cbj4gcG9rZXJfd2lubmluZ19kYXlzXG4gICBNb25kYXkgV2VkbmVzZGF5ICAgIEZyaWRheVxuICAgICAgMTQwICAgICAgICAyMCAgICAgICAyNDBcbiIpKSxtZHgoImRpdiIse2lkOiJtYXRyaXgifSksbWR4KCJociIsbnVsbCksbWR4KCJoMiIseyJpZCI6InItMy1tYXRyaWNlcyJ9LCJSLTM6IE1hdHJpY2VzIiksbWR4KCJwIixudWxsLCJJbiBSLCBhIG1hdHJpeCBpcyBhIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgb2YgdGhlIHNhbWUgZGF0YSB0eXBlIChudW1lcmljLCBjaGFyYWN0ZXIsIG9yIGxvZ2ljYWwpIGFycmFuZ2VkIGludG8gYSBmaXhlZCBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy4gU2luY2UgeW91IGFyZSBvbmx5IHdvcmtpbmcgd2l0aCByb3dzIGFuZCBjb2x1bW5zLCBhIG1hdHJpeCBpcyBjYWxsZWQgdHdvLWRpbWVuc2lvbmFsLiIpLG1keCgicCIsbnVsbCwiWW91IGNhbiBjb25zdHJ1Y3QgYSBtYXRyaXggaW4gUiB3aXRoIHRoZSBtYXRyaXgoKSBmdW5jdGlvbi4gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBleGFtcGxlOiIpLG1keCgicCIsbnVsbCwibWF0cml4KDE6OSwgYnlyb3cgPSBUUlVFLCBucm93ID0gMylcbkluIHRoZSBtYXRyaXgoKSBmdW5jdGlvbjoiKSxtZHgoInAiLG51bGwsIlRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgY29sbGVjdGlvbiBvZiBlbGVtZW50cyB0aGF0IFIgd2lsbCBhcnJhbmdlIGludG8gdGhlIHJvd3MgYW5kIGNvbHVtbnMgb2YgdGhlIG1hdHJpeC4gSGVyZSwgd2UgdXNlIDE6OSB3aGljaCBpcyBhIHNob3J0Y3V0IGZvciBjKDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDkpLiIpLG1keCgicCIsbnVsbCwiVGhlIGFyZ3VtZW50IGJ5cm93IGluZGljYXRlcyB0aGF0IHRoZSBtYXRyaXggaXMgZmlsbGVkIGJ5IHRoZSByb3dzLiBJZiB3ZSB3YW50IHRoZSBtYXRyaXggdG8gYmUgZmlsbGVkIGJ5IHRoZSBjb2x1bW5zLCB3ZSBqdXN0IHBsYWNlIGJ5cm93ID0gRkFMU0UuXG5UaGUgdGhpcmQgYXJndW1lbnQgbnJvdyBpbmRpY2F0ZXMgdGhhdCB0aGUgbWF0cml4IHNob3VsZCBoYXZlIHRocmVlIHJvd3MuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQ29uc3RydWN0IGEgbWF0cml4IHdpdGggMyByb3dzIHRoYXQgY29udGFpbiB0aGUgbnVtYmVycyAxIHVwIHRvIDlcbj4gbWF0cml4KDE6OSwgYnlyb3cgPSBUUlVFLCBucm93ID0gMylcbiAgICAgWywxXSBbLDJdIFssM11cblsxLF0gICAgMSAgICAyICAgIDNcblsyLF0gICAgNCAgICA1ICAgIDZcblszLF0gICAgNyAgICA4ICAgIDlcbj4gbWF0cml4XG5mdW5jdGlvbiAoZGF0YSA9IE5BLCBucm93ID0gMSwgbmNvbCA9IDEsIGJ5cm93ID0gRkFMU0UsIGRpbW5hbWVzID0gTlVMTClcbntcbiAgICBpZiAoaXMub2JqZWN0KGRhdGEpIHx8ICFpcy5hdG9taWMoZGF0YSkpXG4gICAgICAgIGRhdGEgPC0gYXMudmVjdG9yKGRhdGEpXG4gICAgLkludGVybmFsKG1hdHJpeChkYXRhLCBucm93LCBuY29sLCBieXJvdywgZGltbmFtZXMsIG1pc3NpbmcobnJvdyksXG4gICAgICAgIG1pc3NpbmcobmNvbCkpKVxufVxuPGJ5dGVjb2RlOiAweGRhYmUzMD5cbjxlbnZpcm9ubWVudDogbmFtZXNwYWNlOmJhc2U+XG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJDcmVhdGluZyBhIG1hdHJpeCB1c2luZyB2YXJpYWJsZXMiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQm94IG9mZmljZSBTdGFyIFdhcnMgKGluIG1pbGxpb25zISlcbj4gbmV3X2hvcGUgPC0gYyg0NjAuOTk4LCAzMTQuNClcbj4gZW1waXJlX3N0cmlrZXMgPC0gYygyOTAuNDc1LCAyNDcuOTAwKVxuPiByZXR1cm5famVkaSA8LSBjKDMwOS4zMDYsIDE2NS44KVxuPlxuIyBDcmVhdGUgYm94X29mZmljZVxuPiBib3hfb2ZmaWNlIDwtIGMobmV3X2hvcGUsIGVtcGlyZV9zdHJpa2VzLCByZXR1cm5famVkaSlcbj5cbiMgQ29uc3RydWN0IHN0YXJfd2Fyc19tYXRyaXhcbj4gc3Rhcl93YXJzX21hdHJpeCA8LSBtYXRyaXgoYm94X29mZmljZSwgYnlyb3cgPSBUUlVFLCBucm93ID0gMylcbj4gc3Rhcl93YXJzX21hdHJpeFxuICAgICAgICBbLDFdICBbLDJdXG5bMSxdIDQ2MC45OTggMzE0LjRcblsyLF0gMjkwLjQ3NSAyNDcuOVxuWzMsXSAzMDkuMzA2IDE2NS44XG4iKSksbWR4KCJkaXYiLHtpZDoibWF0cml4MiJ9KSxtZHgoImgzIix7ImlkIjoiLS0tLS1uYW1pbmctYS1tYXRyaXgifSwiLS0tLSBOYW1pbmcgYSBtYXRyaXgiKSxtZHgoInAiLG51bGwsIlNpbWlsYXIgdG8gdmVjdG9ycywgeW91IGNhbiBhZGQgbmFtZXMgZm9yIHRoZSByb3dzIGFuZCB0aGUgY29sdW1ucyBvZiBhIG1hdHJpeCIpLG1keCgicCIsbnVsbCwicm93bmFtZXMobXlfbWF0cml4KSA8LSByb3dfbmFtZXNfdmVjdG9yXG5jb2xuYW1lcyhteV9tYXRyaXgpIDwtIGNvbF9uYW1lc192ZWN0b3JcbldlIHdlbnQgYWhlYWQgYW5kIHByZXBhcmVkIHR3byB2ZWN0b3JzIGZvciB5b3U6IHJlZ2lvbiwgYW5kIHRpdGxlcy4gWW91IHdpbGwgbmVlZCB0aGVzZSB2ZWN0b3JzIHRvIG5hbWUgdGhlIGNvbHVtbnMgYW5kIHJvd3Mgb2Ygc3Rhcl93YXJzX21hdHJpeCwgcmVzcGVjdGl2ZWx5LiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIEJveCBvZmZpY2UgU3RhciBXYXJzIChpbiBtaWxsaW9ucyEpXG4+IG5ld19ob3BlIDwtIGMoNDYwLjk5OCwgMzE0LjQpXG4+IGVtcGlyZV9zdHJpa2VzIDwtIGMoMjkwLjQ3NSwgMjQ3LjkwMClcbj4gcmV0dXJuX2plZGkgPC0gYygzMDkuMzA2LCAxNjUuOClcbj5cbiMgQ29uc3RydWN0IG1hdHJpeFxuPiBzdGFyX3dhcnNfbWF0cml4IDwtIG1hdHJpeChjKG5ld19ob3BlLCBlbXBpcmVfc3RyaWtlcywgcmV0dXJuX2plZGkpLCBucm93ID0gMywgYnlyb3cgPSBUUlVFKVxuPlxuIyBWZWN0b3JzIHJlZ2lvbiBhbmQgdGl0bGVzLCB1c2VkIGZvciBuYW1pbmdcbj4gcmVnaW9uIDwtIGMoXCJVU1wiLCBcIm5vbi1VU1wiKVxuPiB0aXRsZXMgPC0gYyhcIkEgTmV3IEhvcGVcIiwgXCJUaGUgRW1waXJlIFN0cmlrZXMgQmFja1wiLCBcIlJldHVybiBvZiB0aGUgSmVkaVwiKVxuPlxuIyBOYW1lIHRoZSBjb2x1bW5zIHdpdGggcmVnaW9uXG4+IGNvbG5hbWVzKHN0YXJfd2Fyc19tYXRyaXgpIDwtIHJlZ2lvblxuPlxuIyBOYW1lIHRoZSByb3dzIHdpdGggdGl0bGVzXG4+IHJvd25hbWVzKHN0YXJfd2Fyc19tYXRyaXgpIDwtIHRpdGxlc1xuPlxuIyBQcmludCBvdXQgc3Rhcl93YXJzX21hdHJpeFxuPiBzdGFyX3dhcnNfbWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVTIG5vbi1VU1xuQSBOZXcgSG9wZSAgICAgICAgICAgICAgNDYwLjk5OCAgMzE0LjRcblRoZSBFbXBpcmUgU3RyaWtlcyBCYWNrIDI5MC40NzUgIDI0Ny45XG5SZXR1cm4gb2YgdGhlIEplZGkgICAgICAzMDkuMzA2ICAxNjUuOFxuIikpLG1keCgicCIsbnVsbCwiSW4gUiwgdGhlIGZ1bmN0aW9uIHJvd1N1bXMoKSBjb252ZW5pZW50bHkgY2FsY3VsYXRlcyB0aGUgdG90YWxzIGZvciBlYWNoIHJvdyBvZiBhIG1hdHJpeC4gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IHZlY3RvcjoiKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJyb3dTdW1zKG15X21hdHJpeCkiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQ29uc3RydWN0IHN0YXJfd2Fyc19tYXRyaXhcbj4gYm94X29mZmljZSA8LSBjKDQ2MC45OTgsIDMxNC40LCAyOTAuNDc1LCAyNDcuOTAwLCAzMDkuMzA2LCAxNjUuOClcbj4gc3Rhcl93YXJzX21hdHJpeCA8LSBtYXRyaXgoYm94X29mZmljZSwgbnJvdyA9IDMsIGJ5cm93ID0gVFJVRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltbmFtZXMgPSBsaXN0KGMoXCJBIE5ldyBIb3BlXCIsIFwiVGhlIEVtcGlyZSBTdHJpa2VzIEJhY2tcIiwgXCJSZXR1cm4gb2YgdGhlIEplZGlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjKFwiVVNcIiwgXCJub24tVVNcIikpKVxuPlxuIyBDYWxjdWxhdGUgd29ybGR3aWRlIGJveCBvZmZpY2UgZmlndXJlc1xuPiB3b3JsZHdpZGVfdmVjdG9yIDwtIHJvd1N1bXMoc3Rhcl93YXJzX21hdHJpeClcbiIpKSxtZHgoInAiLG51bGwsIllvdSBjYW4gYWRkIGEgY29sdW1uIG9yIG11bHRpcGxlIGNvbHVtbnMgdG8gYSBtYXRyaXggd2l0aCB0aGUgY2JpbmQoKSBmdW5jdGlvbiwgd2hpY2ggbWVyZ2VzIG1hdHJpY2VzIGFuZC9vciB2ZWN0b3JzIHRvZ2V0aGVyIGJ5IGNvbHVtbi4gRm9yIGV4YW1wbGU6IiksbWR4KCJwIixudWxsLCJiaWdfbWF0cml4IDwtIGNiaW5kKG1hdHJpeDEsIG1hdHJpeDIsIHZlY3RvcjEgLi4uKSIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIENvbnN0cnVjdCBzdGFyX3dhcnNfbWF0cml4XG4+IGJveF9vZmZpY2UgPC0gYyg0NjAuOTk4LCAzMTQuNCwgMjkwLjQ3NSwgMjQ3LjkwMCwgMzA5LjMwNiwgMTY1LjgpXG4+IHN0YXJfd2Fyc19tYXRyaXggPC0gbWF0cml4KGJveF9vZmZpY2UsIG5yb3cgPSAzLCBieXJvdyA9IFRSVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbW5hbWVzID0gbGlzdChjKFwiQSBOZXcgSG9wZVwiLCBcIlRoZSBFbXBpcmUgU3RyaWtlcyBCYWNrXCIsIFwiUmV0dXJuIG9mIHRoZSBKZWRpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyhcIlVTXCIsIFwibm9uLVVTXCIpKSlcbj5cbiMgVGhlIHdvcmxkd2lkZSBib3ggb2ZmaWNlIGZpZ3VyZXNcbj4gd29ybGR3aWRlX3ZlY3RvciA8LSByb3dTdW1zKHN0YXJfd2Fyc19tYXRyaXgpXG4+XG4jIEJpbmQgdGhlIG5ldyB2YXJpYWJsZSB3b3JsZHdpZGVfdmVjdG9yIGFzIGEgY29sdW1uIHRvIHN0YXJfd2Fyc19tYXRyaXhcbj4gYWxsX3dhcnNfbWF0cml4IDwtIGNiaW5kKHN0YXJfd2Fyc19tYXRyaXgsIHdvcmxkd2lkZV92ZWN0b3IpXG4iKSksbWR4KCJkaXYiLHtpZDoiYWRkcm93In0pLG1keCgiaDMiLHsiaWQiOiItLS0tLWFkZGluZy1hLXJvdyJ9LCItLS0tIEFkZGluZyBhIFJvdyIpLG1keCgicCIsbnVsbCwiSnVzdCBsaWtlIGV2ZXJ5IGFjdGlvbiBoYXMgYSByZWFjdGlvbiwgZXZlcnkgY2JpbmQoKSBoYXMgYW4gcmJpbmQoKS4gKFdlIGFkbWl0LCB3ZSBhcmUgcHJldHR5IGJhZCB3aXRoIG1ldGFwaG9ycy4pIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgc3Rhcl93YXJzX21hdHJpeCBhbmQgc3Rhcl93YXJzX21hdHJpeDIgYXJlIGF2YWlsYWJsZSBpbiB5b3VyIHdvcmtzcGFjZVxuPiBzdGFyX3dhcnNfbWF0cml4ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFVTIG5vbi1VU1xuQSBOZXcgSG9wZSAgICAgICAgICAgICAgNDYxLjAgIDMxNC40XG5UaGUgRW1waXJlIFN0cmlrZXMgQmFjayAyOTAuNSAgMjQ3LjlcblJldHVybiBvZiB0aGUgSmVkaSAgICAgIDMwOS4zICAxNjUuOFxuPiBzdGFyX3dhcnNfbWF0cml4MlxuICAgICAgICAgICAgICAgICAgICAgICAgVVMgbm9uLVVTXG5UaGUgUGhhbnRvbSBNZW5hY2UgICA0NzQuNSAgNTUyLjVcbkF0dGFjayBvZiB0aGUgQ2xvbmVzIDMxMC43ICAzMzguN1xuUmV2ZW5nZSBvZiB0aGUgU2l0aCAgMzgwLjMgIDQ2OC41XG4+XG4jIENvbWJpbmUgYm90aCBTdGFyIFdhcnMgdHJpbG9naWVzIGluIG9uZSBtYXRyaXhcbj4gYWxsX3dhcnNfbWF0cml4IDwtIHJiaW5kKHN0YXJfd2Fyc19tYXRyaXgsIHN0YXJfd2Fyc19tYXRyaXgyKVxuPiBhbGxfd2Fyc19tYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFVTIG5vbi1VU1xuQSBOZXcgSG9wZSAgICAgICAgICAgICAgNDYxLjAgIDMxNC40XG5UaGUgRW1waXJlIFN0cmlrZXMgQmFjayAyOTAuNSAgMjQ3LjlcblJldHVybiBvZiB0aGUgSmVkaSAgICAgIDMwOS4zICAxNjUuOFxuVGhlIFBoYW50b20gTWVuYWNlICAgICAgNDc0LjUgIDU1Mi41XG5BdHRhY2sgb2YgdGhlIENsb25lcyAgICAzMTAuNyAgMzM4LjdcblJldmVuZ2Ugb2YgdGhlIFNpdGggICAgIDM4MC4zICA0NjguNVxuIikpLG1keCgiZGl2Iix7aWQ6Im5ld1NlY3Rpb24ifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tYWxsLWZ1bmN0aW9ucy1mb3ItY29tYmluaW5nIn0sIi0tLS0gQWxsIGZ1bmN0aW9ucyBmb3IgY29tYmluaW5nIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImNiaW5kKClcbnJiaW5kKClcbmNvbFN1bXMoKVxucm93U3VtcygpXG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gYWxsX3dhcnNfbWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBVUyBub24tVVNcbkEgTmV3IEhvcGUgICAgICAgICAgICAgIDQ2MS4wICAzMTQuNFxuVGhlIEVtcGlyZSBTdHJpa2VzIEJhY2sgMjkwLjUgIDI0Ny45XG5SZXR1cm4gb2YgdGhlIEplZGkgICAgICAzMDkuMyAgMTY1LjhcblRoZSBQaGFudG9tIE1lbmFjZSAgICAgIDQ3NC41ICA1NTIuNVxuQXR0YWNrIG9mIHRoZSBDbG9uZXMgICAgMzEwLjcgIDMzOC43XG5SZXZlbmdlIG9mIHRoZSBTaXRoICAgICAzODAuMyAgNDY4LjVcbj5cbiMgVG90YWwgcmV2ZW51ZSBmb3IgVVMgYW5kIG5vbi1VU1xuPiB0b3RhbF9yZXZlbnVlX3ZlY3RvciA8LSBjb2xTdW1zKGFsbF93YXJzX21hdHJpeClcbj5cbiMgUHJpbnQgb3V0IHRvdGFsX3JldmVudWVfdmVjdG9yXG4+IHRvdGFsX3JldmVudWVfdmVjdG9yXG4gICAgVVMgbm9uLVVTXG4yMjI2LjMgMjA4Ny44XG4iKSksbWR4KCJkaXYiLHtpZDoibWF0cml4RWxlbWVudHMifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tc2VsZWN0aW9uLW9mLW1hdHJpeC1lbGVtZW50cyJ9LCItLS0tIFNlbGVjdGlvbiBvZiBNYXRyaXggRWxlbWVudHMiKSxtZHgoInAiLG51bGwsIlNpbWlsYXIgdG8gdmVjdG9ycywgeW91IGNhbiB1c2UgdGhlIHNxdWFyZSBicmFja2V0cyAiLCJbIF0iLCIgdG8gc2VsZWN0IG9uZSBvciBtdWx0aXBsZSBlbGVtZW50cyBmcm9tIGEgbWF0cml4LiBXaGVyZWFzIHZlY3RvcnMgaGF2ZSBvbmUgZGltZW5zaW9uLCBtYXRyaWNlcyBoYXZlIHR3byBkaW1lbnNpb25zLiBZb3Ugc2hvdWxkIHRoZXJlZm9yZSB1c2UgYSBjb21tYSB0byBzZXBhcmF0ZSB0aGF0IHdoYXQgdG8gc2VsZWN0IGZyb20gdGhlIHJvd3MgZnJvbSB0aGF0IHdoYXQgeW91IHdhbnQgdG8gc2VsZWN0IGZyb20gdGhlIGNvbHVtbnMuIEZvciBleGFtcGxlOiIpLG1keCgicCIsbnVsbCwibXlfbWF0cml4IiwiWzEsMl0iLCIgc2VsZWN0cyB0aGUgZWxlbWVudCBhdCB0aGUgZmlyc3Qgcm93IGFuZCBzZWNvbmQgY29sdW1uLlxubXlfbWF0cml4IiwiWzE6MywyOjRdIiwiIHJlc3VsdHMgaW4gYSBtYXRyaXggd2l0aCB0aGUgZGF0YSBvbiB0aGUgcm93cyAxLCAyLCAzIGFuZCBjb2x1bW5zIDIsIDMsIDQuXG5JZiB5b3Ugd2FudCB0byBzZWxlY3QgYWxsIGVsZW1lbnRzIG9mIGEgcm93IG9yIGEgY29sdW1uLCBubyBudW1iZXIgaXMgbmVlZGVkIGJlZm9yZSBvciBhZnRlciB0aGUgY29tbWEsIHJlc3BlY3RpdmVseToiKSxtZHgoInAiLG51bGwsIm15X21hdHJpeCIsIlssMV0iLCIgc2VsZWN0cyBhbGwgZWxlbWVudHMgb2YgdGhlIGZpcnN0IGNvbHVtbi5cbm15X21hdHJpeCIsIlsxLF0iLCIgc2VsZWN0cyBhbGwgZWxlbWVudHMgb2YgdGhlIGZpcnN0IHJvdy4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBhbGxfd2Fyc19tYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFVTIG5vbi1VU1xuQSBOZXcgSG9wZSAgICAgICAgICAgICAgNDYxLjAgIDMxNC40XG5UaGUgRW1waXJlIFN0cmlrZXMgQmFjayAyOTAuNSAgMjQ3LjlcblJldHVybiBvZiB0aGUgSmVkaSAgICAgIDMwOS4zICAxNjUuOFxuVGhlIFBoYW50b20gTWVuYWNlICAgICAgNDc0LjUgIDU1Mi41XG5BdHRhY2sgb2YgdGhlIENsb25lcyAgICAzMTAuNyAgMzM4LjdcblJldmVuZ2Ugb2YgdGhlIFNpdGggICAgIDM4MC4zICA0NjguNVxuPlxuIyBTZWxlY3QgdGhlIG5vbi1VUyByZXZlbnVlIGZvciBhbGwgbW92aWVzXG4+IG5vbl91c19hbGwgPC0gYWxsX3dhcnNfbWF0cml4WywyXVxuPlxuIyBBdmVyYWdlIG5vbi1VUyByZXZlbnVlXG4+IG1lYW4obm9uX3VzX2FsbClcblsxXSAzNDcuOTY2N1xuPlxuIyBTZWxlY3QgdGhlIG5vbi1VUyByZXZlbnVlIGZvciBmaXJzdCB0d28gbW92aWVzXG4+IG5vbl91c19zb21lIDwtIGFsbF93YXJzX21hdHJpeFsxOjIsMl1cbj5cbiMgQXZlcmFnZSBub24tVVMgcmV2ZW51ZSBmb3IgZmlyc3QgdHdvIG1vdmllc1xuPiBtZWFuKG5vbl91c19zb21lKVxuWzFdIDI4MS4xNVxuIikpLG1keCgiZGl2Iix7aWQ6Im1hdHJpeEFyaXRobWV0aWMifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tbWF0cml4LWFyaXRobWV0aWMifSwiLS0tLSBNYXRyaXggQXJpdGhtZXRpYyIpLG1keCgicCIsbnVsbCwiQmFzaWMgYXJpdGhtZXRpYyBhbHNvIHdvcmtzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gYWxsX3dhcnNfbWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBVUyBub24tVVNcbkEgTmV3IEhvcGUgICAgICAgICAgICAgIDQ2MS4wICAzMTQuNFxuVGhlIEVtcGlyZSBTdHJpa2VzIEJhY2sgMjkwLjUgIDI0Ny45XG5SZXR1cm4gb2YgdGhlIEplZGkgICAgICAzMDkuMyAgMTY1LjhcblRoZSBQaGFudG9tIE1lbmFjZSAgICAgIDQ3NC41ICA1NTIuNVxuQXR0YWNrIG9mIHRoZSBDbG9uZXMgICAgMzEwLjcgIDMzOC43XG5SZXZlbmdlIG9mIHRoZSBTaXRoICAgICAzODAuMyAgNDY4LjVcbj5cbiMgRXN0aW1hdGUgdGhlIHZpc2l0b3JzXG4+IHZpc2l0b3JzIDwtIGFsbF93YXJzX21hdHJpeCAvIDVcbj5cbiMgUHJpbnQgdGhlIGVzdGltYXRlIHRvIHRoZSBjb25zb2xlXG4+IHZpc2l0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBVUyBub24tVVNcbkEgTmV3IEhvcGUgICAgICAgICAgICAgIDkyLjIwICA2Mi44OFxuVGhlIEVtcGlyZSBTdHJpa2VzIEJhY2sgNTguMTAgIDQ5LjU4XG5SZXR1cm4gb2YgdGhlIEplZGkgICAgICA2MS44NiAgMzMuMTZcblRoZSBQaGFudG9tIE1lbmFjZSAgICAgIDk0LjkwIDExMC41MFxuQXR0YWNrIG9mIHRoZSBDbG9uZXMgICAgNjIuMTQgIDY3Ljc0XG5SZXZlbmdlIG9mIHRoZSBTaXRoICAgICA3Ni4wNiAgOTMuNzBcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBhbGxfd2Fyc19tYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFVTIG5vbi1VU1xuQSBOZXcgSG9wZSAgICAgICAgICAgICAgNDYxLjAgIDMxNC40XG5UaGUgRW1waXJlIFN0cmlrZXMgQmFjayAyOTAuNSAgMjQ3LjlcblJldHVybiBvZiB0aGUgSmVkaSAgICAgIDMwOS4zICAxNjUuOFxuVGhlIFBoYW50b20gTWVuYWNlICAgICAgNDc0LjUgIDU1Mi41XG5BdHRhY2sgb2YgdGhlIENsb25lcyAgICAzMTAuNyAgMzM4LjdcblJldmVuZ2Ugb2YgdGhlIFNpdGggICAgIDM4MC4zICA0NjguNVxuPiB0aWNrZXRfcHJpY2VzX21hdHJpeFxuICAgICAgICAgICAgICAgICAgICAgICAgIFVTIG5vbi1VU1xuQSBOZXcgSG9wZSAgICAgICAgICAgICAgNS4wICAgIDUuMFxuVGhlIEVtcGlyZSBTdHJpa2VzIEJhY2sgNi4wICAgIDYuMFxuUmV0dXJuIG9mIHRoZSBKZWRpICAgICAgNy4wICAgIDcuMFxuVGhlIFBoYW50b20gTWVuYWNlICAgICAgNC4wICAgIDQuMFxuQXR0YWNrIG9mIHRoZSBDbG9uZXMgICAgNC41ICAgIDQuNVxuUmV2ZW5nZSBvZiB0aGUgU2l0aCAgICAgNC45ICAgIDQuOVxuPlxuIyBFc3RpbWF0ZWQgbnVtYmVyIG9mIHZpc2l0b3JzXG4+IHZpc2l0b3JzIDwtIGFsbF93YXJzX21hdHJpeCAvIHRpY2tldF9wcmljZXNfbWF0cml4XG4+XG4jIFVTIHZpc2l0b3JzXG4+IHVzX3Zpc2l0b3JzIDwtIHZpc2l0b3JzWywxXVxuPlxuIyBBdmVyYWdlIG51bWJlciBvZiBVUyB2aXNpdG9yc1xuPiBtZWFuKHVzX3Zpc2l0b3JzKVxuWzFdIDc1LjAxNDAxXG4iKSksbWR4KCJwIixudWxsLCJUaG9zZSB3aG8gYXJlIGZhbWlsaWFyIHdpdGggbWF0cmljZXMgc2hvdWxkIG5vdGUgdGhhdCB0aGlzIGlzIG5vdCB0aGUgc3RhbmRhcmQgbWF0cml4IG11bHRpcGxpY2F0aW9uIGZvciB3aGljaCB5b3Ugc2hvdWxkIHVzZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiJSolIiksIiBpbiBSLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCI+IGFsbF93YXJzX21hdHJpeFssMV0gJSolIHRpY2tldF9wcmljZXNfbWF0cml4WywxXVxuICAgICAgICAgWywxXVxuWzEsXSAxMTM3Mi43MlxuIikpLG1keCgiZGl2Iix7aWQ6ImZhY3RvcnMifSksbWR4KCJociIsbnVsbCksbWR4KCJoMiIseyJpZCI6ImZhY3RvcnMtaW4tciJ9LCJGYWN0b3JzIGluIFIiKSxtZHgoInAiLG51bGwsIlRoZSB0ZXJtIGZhY3RvciByZWZlcnMgdG8gYSBzdGF0aXN0aWNhbCBkYXRhIHR5cGUgdXNlZCB0byBzdG9yZSBjYXRlZ29yaWNhbCB2YXJpYWJsZXMuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBjYXRlZ29yaWNhbCB2YXJpYWJsZSBhbmQgYSBjb250aW51b3VzIHZhcmlhYmxlIGlzIHRoYXQgYSBjYXRlZ29yaWNhbCB2YXJpYWJsZSBjYW4gYmVsb25nIHRvIGEgbGltaXRlZCBudW1iZXIgb2YgY2F0ZWdvcmllcy4gQSBjb250aW51b3VzIHZhcmlhYmxlLCBvbiB0aGUgb3RoZXIgaGFuZCwgY2FuIGNvcnJlc3BvbmQgdG8gYW4gaW5maW5pdGUgbnVtYmVyIG9mIHZhbHVlcy4iKSxtZHgoInAiLG51bGwsIkl0IGlzIGltcG9ydGFudCB0aGF0IFIga25vd3Mgd2hldGhlciBpdCBpcyBkZWFsaW5nIHdpdGggYSBjb250aW51b3VzIG9yIGEgY2F0ZWdvcmljYWwgdmFyaWFibGUsIGFzIHRoZSBzdGF0aXN0aWNhbCBtb2RlbHMgeW91IHdpbGwgZGV2ZWxvcCBpbiB0aGUgZnV0dXJlIHRyZWF0IGJvdGggdHlwZXMgZGlmZmVyZW50bHkuIChZb3Ugd2lsbCBzZWUgbGF0ZXIgd2h5IHRoaXMgaXMgdGhlIGNhc2UuKSIpLG1keCgicCIsbnVsbCwiQSBnb29kIGV4YW1wbGUgb2YgYSBjYXRlZ29yaWNhbCB2YXJpYWJsZSBpcyB0aGUgdmFyaWFibGUgJ0dlbmRlcicuIEEgaHVtYW4gaW5kaXZpZHVhbCBjYW4gZWl0aGVyIGJlIFwiTWFsZVwiIG9yIFwiRmVtYWxlXCIsIG1ha2luZyBhYnN0cmFjdGlvbiBvZiBpbnRlci1zZXhlcy4gU28gaGVyZSBcIk1hbGVcIiBhbmQgXCJGZW1hbGVcIiBhcmUsIGluIGEgc2ltcGxpZmllZCBzZW5zZSwgdGhlIHR3byB2YWx1ZXMgb2YgdGhlIGNhdGVnb3JpY2FsIHZhcmlhYmxlIFwiR2VuZGVyXCIsIGFuZCBldmVyeSBvYnNlcnZhdGlvbiBjYW4gYmUgYXNzaWduZWQgdG8gZWl0aGVyIHRoZSB2YWx1ZSBcIk1hbGVcIiBvZiBcIkZlbWFsZVwiLiIpLG1keCgicCIsbnVsbCwiVG8gY3JlYXRlIGZhY3RvcnMgaW4gUiwgeW91IG1ha2UgdXNlIG9mIHRoZSBmdW5jdGlvbiBmYWN0b3IoKS4gRmlyc3QgdGhpbmcgdGhhdCB5b3UgaGF2ZSB0byBkbyBpcyBjcmVhdGUgYSB2ZWN0b3IgdGhhdCBjb250YWlucyBhbGwgdGhlIG9ic2VydmF0aW9ucyB0aGF0IGJlbG9uZyB0byBhIGxpbWl0ZWQgbnVtYmVyIG9mIGNhdGVnb3JpZXMuIEZvciBleGFtcGxlLCBnZW5kZXJfdmVjdG9yIGNvbnRhaW5zIHRoZSBzZXggb2YgNSBkaWZmZXJlbnQgaW5kaXZpZHVhbHM6IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImdlbmRlcl92ZWN0b3IgPC0gYyhcIk1hbGVcIixcIkZlbWFsZVwiLFwiRmVtYWxlXCIsXCJNYWxlXCIsXCJNYWxlXCIpXG4iKSksbWR4KCJwIixudWxsLCJJdCBpcyBjbGVhciB0aGF0IHRoZXJlIGFyZSB0d28gY2F0ZWdvcmllcywgb3IgaW4gUi10ZXJtcyAnZmFjdG9yIGxldmVscycsIGF0IHdvcmsgaGVyZTogXCJNYWxlXCIgYW5kIFwiRmVtYWxlXCIuIiksbWR4KCJwIixudWxsLCJUaGUgZnVuY3Rpb24gZmFjdG9yKCkgd2lsbCBlbmNvZGUgdGhlIHZlY3RvciBhcyBhIGZhY3RvcjoiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiZmFjdG9yX2dlbmRlcl92ZWN0b3IgPC0gZmFjdG9yKGdlbmRlcl92ZWN0b3IpXG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgR2VuZGVyIHZlY3RvclxuPiBnZW5kZXJfdmVjdG9yIDwtIGMoXCJNYWxlXCIsIFwiRmVtYWxlXCIsIFwiRmVtYWxlXCIsIFwiTWFsZVwiLCBcIk1hbGVcIilcbj5cbiMgQ29udmVydCBnZW5kZXJfdmVjdG9yIHRvIGEgZmFjdG9yXG4+IGZhY3Rvcl9nZW5kZXJfdmVjdG9yIDwtIGZhY3RvcihnZW5kZXJfdmVjdG9yKVxuPlxuIyBQcmludCBvdXQgZmFjdG9yX2dlbmRlcl92ZWN0b3Jcbj4gZmFjdG9yX2dlbmRlcl92ZWN0b3JcblsxXSBNYWxlICAgRmVtYWxlIEZlbWFsZSBNYWxlICAgTWFsZSAgXG5MZXZlbHM6IEZlbWFsZSBNYWxlXG4+IGdlbmRlcl92ZWN0b3JcblsxXSBcIk1hbGVcIiAgIFwiRmVtYWxlXCIgXCJGZW1hbGVcIiBcIk1hbGVcIiAgIFwiTWFsZVwiXG4iKSksbWR4KCJwIixudWxsLCJUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGNhdGVnb3JpY2FsIHZhcmlhYmxlczogYSBub21pbmFsIGNhdGVnb3JpY2FsIHZhcmlhYmxlIGFuZCBhbiBvcmRpbmFsIGNhdGVnb3JpY2FsIHZhcmlhYmxlLiIpLG1keCgicCIsbnVsbCwiQSBub21pbmFsIHZhcmlhYmxlIGlzIGEgY2F0ZWdvcmljYWwgdmFyaWFibGUgd2l0aG91dCBhbiBpbXBsaWVkIG9yZGVyLiBUaGlzIG1lYW5zIHRoYXQgaXQgaXMgaW1wb3NzaWJsZSB0byBzYXkgdGhhdCAnb25lIGlzIHdvcnRoIG1vcmUgdGhhbiB0aGUgb3RoZXInLiBGb3IgZXhhbXBsZSwgdGhpbmsgb2YgdGhlIGNhdGVnb3JpY2FsIHZhcmlhYmxlIGFuaW1hbHNfdmVjdG9yIHdpdGggdGhlIGNhdGVnb3JpZXMgXCJFbGVwaGFudFwiLCBcIkdpcmFmZmVcIiwgXCJEb25rZXlcIiBhbmQgXCJIb3JzZVwiLiBIZXJlLCBpdCBpcyBpbXBvc3NpYmxlIHRvIHNheSB0aGF0IG9uZSBzdGFuZHMgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiAoTm90ZSB0aGF0IHNvbWUgb2YgeW91IG1pZ2h0IGRpc2FncmVlIDstKSApLiIpLG1keCgicCIsbnVsbCwiSW4gY29udHJhc3QsIG9yZGluYWwgdmFyaWFibGVzIGRvIGhhdmUgYSBuYXR1cmFsIG9yZGVyaW5nLiBDb25zaWRlciBmb3IgZXhhbXBsZSB0aGUgY2F0ZWdvcmljYWwgdmFyaWFibGUgdGVtcGVyYXR1cmVfdmVjdG9yIHdpdGggdGhlIGNhdGVnb3JpZXM6IFwiTG93XCIsIFwiTWVkaXVtXCIgYW5kIFwiSGlnaFwiLiBIZXJlIGl0IGlzIG9idmlvdXMgdGhhdCBcIk1lZGl1bVwiIHN0YW5kcyBhYm92ZSBcIkxvd1wiLCBhbmQgXCJIaWdoXCIgc3RhbmRzIGFib3ZlIFwiTWVkaXVtXCIuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQW5pbWFsc1xuPiBhbmltYWxzX3ZlY3RvciA8LSBjKFwiRWxlcGhhbnRcIiwgXCJHaXJhZmZlXCIsIFwiRG9ua2V5XCIsIFwiSG9yc2VcIilcbj4gZmFjdG9yX2FuaW1hbHNfdmVjdG9yIDwtIGZhY3RvcihhbmltYWxzX3ZlY3Rvcilcbj4gZmFjdG9yX2FuaW1hbHNfdmVjdG9yXG5bMV0gRWxlcGhhbnQgR2lyYWZmZSAgRG9ua2V5ICAgSG9yc2VcbkxldmVsczogRG9ua2V5IEVsZXBoYW50IEdpcmFmZmUgSG9yc2Vcbj5cbiMgVGVtcGVyYXR1cmVcbj4gdGVtcGVyYXR1cmVfdmVjdG9yIDwtIGMoXCJIaWdoXCIsIFwiTG93XCIsIFwiSGlnaFwiLFwiTG93XCIsIFwiTWVkaXVtXCIpXG4+IGZhY3Rvcl90ZW1wZXJhdHVyZV92ZWN0b3IgPC0gZmFjdG9yKHRlbXBlcmF0dXJlX3ZlY3Rvciwgb3JkZXIgPSBUUlVFLCBsZXZlbHMgPSBjKFwiTG93XCIsIFwiTWVkaXVtXCIsIFwiSGlnaFwiKSlcbj4gZmFjdG9yX3RlbXBlcmF0dXJlX3ZlY3RvclxuWzFdIEhpZ2ggICBMb3cgICAgSGlnaCAgIExvdyAgICBNZWRpdW1cbkxldmVsczogTG93IDwgTWVkaXVtIDwgSGlnaFxuIikpLG1keCgicCIsbnVsbCwiVGhlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJsZXZlbHMoKSIpLCIgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIGxldmVscyBsYXRlci4iKSxtZHgoInAiLG51bGwsIldhdGNoIG91dDogdGhlIG9yZGVyIHdpdGggd2hpY2ggeW91IGFzc2lnbiB0aGUgbGV2ZWxzIGlzIGltcG9ydGFudC4gUiB3b3VsZCBhc3NpZ24gdGhlbSBhbHBoYWJldGljYWxseSBieSBkZWZhdWx0LiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIENvZGUgdG8gYnVpbGQgZmFjdG9yX3N1cnZleV92ZWN0b3Jcbj4gc3VydmV5X3ZlY3RvciA8LSBjKFwiTVwiLCBcIkZcIiwgXCJGXCIsIFwiTVwiLCBcIk1cIilcbj4gZmFjdG9yX3N1cnZleV92ZWN0b3IgPC0gZmFjdG9yKHN1cnZleV92ZWN0b3IpXG4+XG4jIFNwZWNpZnkgdGhlIGxldmVscyBvZiBmYWN0b3Jfc3VydmV5X3ZlY3RvclxuPiBsZXZlbHMoZmFjdG9yX3N1cnZleV92ZWN0b3IpIDwtIGMoXCJGZW1hbGVcIiwgXCJNYWxlXCIpXG4+XG4+IGZhY3Rvcl9zdXJ2ZXlfdmVjdG9yXG5bMV0gTWFsZSAgIEZlbWFsZSBGZW1hbGUgTWFsZSAgIE1hbGUgIFxuTGV2ZWxzOiBGZW1hbGUgTWFsZVxuIikpLG1keCgiZGl2Iix7aWQ6ImZhY3RvclN1bW1hcnkifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tc3VtbWFyaXppbmctYS1mYWN0b3IifSwiLS0tLSBTdW1tYXJpemluZyBhIGZhY3RvciIpLG1keCgicCIsbnVsbCxtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInN1bW1hcnkobXlfdmFyKSIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBzdXJ2ZXlfdmVjdG9yIDwtIGMoXCJNXCIsIFwiRlwiLCBcIkZcIiwgXCJNXCIsIFwiTVwiKVxuPiBmYWN0b3Jfc3VydmV5X3ZlY3RvciA8LSBmYWN0b3Ioc3VydmV5X3ZlY3Rvcilcbj4gbGV2ZWxzKGZhY3Rvcl9zdXJ2ZXlfdmVjdG9yKSA8LSBjKFwiRmVtYWxlXCIsIFwiTWFsZVwiKVxuPiBmYWN0b3Jfc3VydmV5X3ZlY3RvclxuWzFdIE1hbGUgICBGZW1hbGUgRmVtYWxlIE1hbGUgICBNYWxlICBcbkxldmVsczogRmVtYWxlIE1hbGVcbj5cbiMgR2VuZXJhdGUgc3VtbWFyeSBmb3Igc3VydmV5X3ZlY3RvclxuPiBzdW1tYXJ5KHN1cnZleV92ZWN0b3IpXG4gICBMZW5ndGggICAgIENsYXNzICAgICAgTW9kZVxuICAgICAgICA1IGNoYXJhY3RlciBjaGFyYWN0ZXJcbj5cbiMgR2VuZXJhdGUgc3VtbWFyeSBmb3IgZmFjdG9yX3N1cnZleV92ZWN0b3Jcbj4gc3VtbWFyeShmYWN0b3Jfc3VydmV5X3ZlY3RvcilcbkZlbWFsZSAgIE1hbGVcbiAgICAgMiAgICAgIDNcbiIpKSxtZHgoInAiLG51bGwsIkdlbmRlciBOZXV0cmFsIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQnVpbGQgZmFjdG9yX3N1cnZleV92ZWN0b3Igd2l0aCBjbGVhbiBsZXZlbHNcbj4gc3VydmV5X3ZlY3RvciA8LSBjKFwiTVwiLCBcIkZcIiwgXCJGXCIsIFwiTVwiLCBcIk1cIilcbj4gZmFjdG9yX3N1cnZleV92ZWN0b3IgPC0gZmFjdG9yKHN1cnZleV92ZWN0b3IpXG4+IGxldmVscyhmYWN0b3Jfc3VydmV5X3ZlY3RvcikgPC0gYyhcIkZlbWFsZVwiLCBcIk1hbGVcIilcbj5cbiMgTWFsZVxuPiBtYWxlIDwtIGZhY3Rvcl9zdXJ2ZXlfdmVjdG9yWzFdXG4+XG4jIEZlbWFsZVxuPiBmZW1hbGUgPC0gZmFjdG9yX3N1cnZleV92ZWN0b3JbMl1cbj5cbiMgQmF0dGxlIG9mIHRoZSBzZXhlczogTWFsZSAnbGFyZ2VyJyB0aGFuIGZlbWFsZT9cbj4gbWFsZSA+IGZlbWFsZVxuV2FybmluZyBtZXNzYWdlOiAnPicgbm90IG1lYW5pbmdmdWwgZm9yIGZhY3RvcnNcblsxXSBOQVxuIikpLG1keCgiZGl2Iix7aWQ6Im9yZGVyZWRGYWN0b3JzIn0pLG1keCgiaDMiLHsiaWQiOiItLS0tLW9yZGVyZWQtZmFjdG9ycyJ9LCItLS0tIE9yZGVyZWQgRmFjdG9ycyIpLG1keCgicCIsbnVsbCwiU2luY2UgXCJNYWxlXCIgYW5kIFwiRmVtYWxlXCIgYXJlIHVub3JkZXJlZCAob3Igbm9taW5hbCkgZmFjdG9yIGxldmVscywgUiByZXR1cm5zIGEgd2FybmluZyBtZXNzYWdlLCB0ZWxsaW5nIHlvdSB0aGF0IHRoZSBncmVhdGVyIHRoYW4gb3BlcmF0b3IgaXMgbm90IG1lYW5pbmdmdWwuIEFzIHNlZW4gYmVmb3JlLCBSIGF0dGFjaGVzIGFuIGVxdWFsIHZhbHVlIHRvIHRoZSBsZXZlbHMgZm9yIHN1Y2ggZmFjdG9ycy4iKSxtZHgoInAiLG51bGwsIkJ1dCB0aGlzIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UhIFNvbWV0aW1lcyB5b3Ugd2lsbCBhbHNvIGRlYWwgd2l0aCBmYWN0b3JzIHRoYXQgZG8gaGF2ZSBhIG5hdHVyYWwgb3JkZXJpbmcgYmV0d2VlbiBpdHMgY2F0ZWdvcmllcy4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwYXNzIHRoaXMgaW5mb3JtYXRpb24gdG8gUi4uLiIpLG1keCgicCIsbnVsbCwiTGV0IHVzIHNheSB0aGF0IHlvdSBhcmUgbGVhZGluZyBhIHJlc2VhcmNoIHRlYW0gb2YgZml2ZSBkYXRhIGFuYWx5c3RzIGFuZCB0aGF0IHlvdSB3YW50IHRvIGV2YWx1YXRlIHRoZWlyIHBlcmZvcm1hbmNlLiBUbyBkbyB0aGlzLCB5b3UgdHJhY2sgdGhlaXIgc3BlZWQsIGV2YWx1YXRlIGVhY2ggYW5hbHlzdCBhcyBcInNsb3dcIiwgXCJmYXN0XCIgb3IgXCJpbnNhbmVcIiwgYW5kIHNhdmUgdGhlIHJlc3VsdHMgaW4gc3BlZWRfdmVjdG9yLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIENyZWF0ZSBzcGVlZF92ZWN0b3Jcbj4gc3BlZWRfdmVjdG9yIDwtIGMoXCJmYXN0XCIsIFwic2xvd1wiLCBcInNsb3dcIiwgXCJmYXN0XCIsIFwiaW5zYW5lXCIpXG4+XG4jIENvbnZlcnQgc3BlZWRfdmVjdG9yIHRvIG9yZGVyZWQgZmFjdG9yIHZlY3RvclxuPiBmYWN0b3Jfc3BlZWRfdmVjdG9yIDwtIGZhY3RvcihzcGVlZF92ZWN0b3IsIG9yZGVyZWQ9VFJVRSwgbGV2ZWxzID0gYyhcInNsb3dcIiwgXCJmYXN0XCIsIFwiaW5zYW5lXCIpKVxuPlxuIyBQcmludCBmYWN0b3Jfc3BlZWRfdmVjdG9yXG4+IGZhY3Rvcl9zcGVlZF92ZWN0b3JcblsxXSBmYXN0ICAgc2xvdyAgIHNsb3cgICBmYXN0ICAgaW5zYW5lXG5MZXZlbHM6IHNsb3cgPCBmYXN0IDwgaW5zYW5lXG4+IHN1bW1hcnkoZmFjdG9yX3NwZWVkX3ZlY3RvcilcbiAgc2xvdyAgIGZhc3QgaW5zYW5lXG4gICAgIDIgICAgICAyICAgICAgMVxuIikpLG1keCgicCIsbnVsbCwiVGhlbiBhcyBhbiBleGFtcGxlIG9mIGNvbXBhcmluZyBPcmRlcmVkIEZhY3RvcnMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBDcmVhdGUgZmFjdG9yX3NwZWVkX3ZlY3RvclxuPiBzcGVlZF92ZWN0b3IgPC0gYyhcImZhc3RcIiwgXCJzbG93XCIsIFwic2xvd1wiLCBcImZhc3RcIiwgXCJpbnNhbmVcIilcbj4gZmFjdG9yX3NwZWVkX3ZlY3RvciA8LSBmYWN0b3Ioc3BlZWRfdmVjdG9yLCBvcmRlcmVkID0gVFJVRSwgbGV2ZWxzID0gYyhcInNsb3dcIiwgXCJmYXN0XCIsIFwiaW5zYW5lXCIpKVxuPlxuIyBGYWN0b3IgdmFsdWUgZm9yIHNlY29uZCBkYXRhIGFuYWx5c3Rcbj4gZGEyIDwtIGZhY3Rvcl9zcGVlZF92ZWN0b3JbMl1cbj5cbiMgRmFjdG9yIHZhbHVlIGZvciBmaWZ0aCBkYXRhIGFuYWx5c3Rcbj4gZGE1IDwtIGZhY3Rvcl9zcGVlZF92ZWN0b3JbNV1cbj5cbiMgSXMgZGF0YSBhbmFseXN0IDIgZmFzdGVyIHRoYW4gZGF0YSBhbmFseXN0IDU/XG4+IGRhMiA+IGRhNVxuWzFdIEZBTFNFXG4iKSksbWR4KCJkaXYiLHtpZDoiZGF0YUZyYW1lcyJ9KSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoiZGF0YS1mcmFtZXMifSwiRGF0YSBGcmFtZXMiKSxtZHgoInAiLG51bGwsIldoZW4gZG9pbmcgYSBtYXJrZXQgcmVzZWFyY2ggc3VydmV5LCB5b3Ugb2Z0ZW4gaGF2ZSBxdWVzdGlvbnMgc3VjaCBhczoiKSxtZHgoInAiLG51bGwsIidBcmUgeW91ciBtYXJyaWVkPycgb3IgJ3llcy9ubycgcXVlc3Rpb25zIChsb2dpY2FsKVxuJ0hvdyBvbGQgYXJlIHlvdT8nIChudW1lcmljKVxuJ1doYXQgaXMgeW91ciBvcGluaW9uIG9uIHRoaXMgcHJvZHVjdD8nIG9yIG90aGVyICdvcGVuLWVuZGVkJyBxdWVzdGlvbnMgKGNoYXJhY3Rlcilcbi4uLlxuVGhlIG91dHB1dCwgbmFtZWx5IHRoZSByZXNwb25kZW50cycgYW5zd2VycyB0byB0aGUgcXVlc3Rpb25zIGZvcm11bGF0ZWQgYWJvdmUsIGlzIGEgZGF0YSBzZXQgb2YgZGlmZmVyZW50IGRhdGEgdHlwZXMuIFlvdSB3aWxsIG9mdGVuIGZpbmQgeW91cnNlbGYgd29ya2luZyB3aXRoIGRhdGEgc2V0cyB0aGF0IGNvbnRhaW4gZGlmZmVyZW50IGRhdGEgdHlwZXMgaW5zdGVhZCBvZiBvbmx5IG9uZS4iKSxtZHgoInAiLG51bGwsIkEgZGF0YSBmcmFtZSBoYXMgdGhlIHZhcmlhYmxlcyBvZiBhIGRhdGEgc2V0IGFzIGNvbHVtbnMgYW5kIHRoZSBvYnNlcnZhdGlvbnMgYXMgcm93cy4gVGhpcyB3aWxsIGJlIGEgZmFtaWxpYXIgY29uY2VwdCBmb3IgdGhvc2UgY29taW5nIGZyb20gZGlmZmVyZW50IHN0YXRpc3RpY2FsIHNvZnR3YXJlIHBhY2thZ2VzIHN1Y2ggYXMgU0FTIG9yIFNQU1MuIiksbWR4KCJwIixudWxsLCJXb3JraW5nIHdpdGggbGFyZ2UgZGF0YSBzZXRzIGlzIG5vdCB1bmNvbW1vbiBpbiBkYXRhIGFuYWx5c2lzLiBXaGVuIHlvdSB3b3JrIHdpdGggKGV4dHJlbWVseSkgbGFyZ2UgZGF0YSBzZXRzIGFuZCBkYXRhIGZyYW1lcywgeW91ciBmaXJzdCB0YXNrIGFzIGEgZGF0YSBhbmFseXN0IGlzIHRvIGRldmVsb3AgYSBjbGVhciB1bmRlcnN0YW5kaW5nIG9mIGl0cyBzdHJ1Y3R1cmUgYW5kIG1haW4gZWxlbWVudHMuIFRoZXJlZm9yZSwgaXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIHNob3cgb25seSBhIHNtYWxsIHBhcnQgb2YgdGhlIGVudGlyZSBkYXRhIHNldC4iKSxtZHgoInAiLG51bGwsIlNvIGhvdyB0byBkbyB0aGlzIGluIFI/IFdlbGwsIHRoZSBmdW5jdGlvbiBoZWFkKCkgZW5hYmxlcyB5b3UgdG8gc2hvdyB0aGUgZmlyc3Qgb2JzZXJ2YXRpb25zIG9mIGEgZGF0YSBmcmFtZS4gU2ltaWxhcmx5LCB0aGUgZnVuY3Rpb24gdGFpbCgpIHByaW50cyBvdXQgdGhlIGxhc3Qgb2JzZXJ2YXRpb25zIGluIHlvdXIgZGF0YSBzZXQuIiksbWR4KCJwIixudWxsLCJCb3RoIGhlYWQoKSBhbmQgdGFpbCgpIHByaW50IGEgdG9wIGxpbmUgY2FsbGVkIHRoZSAnaGVhZGVyJywgd2hpY2ggY29udGFpbnMgdGhlIG5hbWVzIG9mIHRoZSBkaWZmZXJlbnQgdmFyaWFibGVzIGluIHlvdXIgZGF0YSBzZXQuIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgdW5peCBjb21tYW5kLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCI+IGhlYWQobXRjYXJzKVxuICAgICAgICAgICAgICAgICAgIG1wZyBjeWwgZGlzcCAgaHAgZHJhdCAgICB3dCAgcXNlYyB2cyBhbSBnZWFyIGNhcmJcbk1hemRhIFJYNCAgICAgICAgIDIxLjAgICA2ICAxNjAgMTEwIDMuOTAgMi42MjAgMTYuNDYgIDAgIDEgICAgNCAgICA0XG5NYXpkYSBSWDQgV2FnICAgICAyMS4wICAgNiAgMTYwIDExMCAzLjkwIDIuODc1IDE3LjAyICAwICAxICAgIDQgICAgNFxuRGF0c3VuIDcxMCAgICAgICAgMjIuOCAgIDQgIDEwOCAgOTMgMy44NSAyLjMyMCAxOC42MSAgMSAgMSAgICA0ICAgIDFcbkhvcm5ldCA0IERyaXZlICAgIDIxLjQgICA2ICAyNTggMTEwIDMuMDggMy4yMTUgMTkuNDQgIDEgIDAgICAgMyAgICAxXG5Ib3JuZXQgU3BvcnRhYm91dCAxOC43ICAgOCAgMzYwIDE3NSAzLjE1IDMuNDQwIDE3LjAyICAwICAwICAgIDMgICAgMlxuVmFsaWFudCAgICAgICAgICAgMTguMSAgIDYgIDIyNSAxMDUgMi43NiAzLjQ2MCAyMC4yMiAgMSAgMCAgICAzICAgIDFcbiIpKSxtZHgoInAiLG51bGwsIkFub3RoZXIgbWV0aG9kIHRoYXQgaXMgb2Z0ZW4gdXNlZCB0byBnZXQgYSByYXBpZCBvdmVydmlldyBvZiB5b3VyIGRhdGEgaXMgdGhlIGZ1bmN0aW9uIHN0cigpLiBUaGUgZnVuY3Rpb24gc3RyKCkgc2hvd3MgeW91IHRoZSBzdHJ1Y3R1cmUgb2YgeW91ciBkYXRhIHNldC4gRm9yIGEgZGF0YSBmcmFtZSBpdCB0ZWxscyB5b3U6IiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiVGhlIHRvdGFsIG51bWJlciBvZiBvYnNlcnZhdGlvbnMgKGUuZy4gMzIgY2FyIHR5cGVzKSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJUaGUgdG90YWwgbnVtYmVyIG9mIHZhcmlhYmxlcyAoZS5nLiAxMSBjYXIgZmVhdHVyZXMpIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkEgZnVsbCBsaXN0IG9mIHRoZSB2YXJpYWJsZXMgbmFtZXMgKGUuZy4gbXBnLCBjeWwgLi4uICkiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiVGhlIGRhdGEgdHlwZSBvZiBlYWNoIHZhcmlhYmxlIChlLmcuIG51bSkiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiVGhlIGZpcnN0IG9ic2VydmF0aW9ucyIpKSxtZHgoInAiLG51bGwsIkFwcGx5aW5nIHRoZSBzdHIoKSBmdW5jdGlvbiB3aWxsIG9mdGVuIGJlIHRoZSBmaXJzdCB0aGluZyB0aGF0IHlvdSBkbyB3aGVuIHJlY2VpdmluZyBhIG5ldyBkYXRhIHNldCBvciBkYXRhIGZyYW1lLiBJdCBpcyBhIGdyZWF0IHdheSB0byBnZXQgbW9yZSBpbnNpZ2h0IGluIHlvdXIgZGF0YSBzZXQgYmVmb3JlIGRpdmluZyBpbnRvIHRoZSByZWFsIGFuYWx5c2lzLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIEludmVzdGlnYXRlIHRoZSBzdHJ1Y3R1cmUgb2YgbXRjYXJzXG4+IHN0cihtdGNhcnMpXG4nZGF0YS5mcmFtZSc6ICAgMzIgb2JzLiBvZiAgMTEgdmFyaWFibGVzOlxuICQgbXBnIDogbnVtICAyMSAyMSAyMi44IDIxLjQgMTguNyAxOC4xIDE0LjMgMjQuNCAyMi44IDE5LjIgLi4uXG4gJCBjeWwgOiBudW0gIDYgNiA0IDYgOCA2IDggNCA0IDYgLi4uXG4gJCBkaXNwOiBudW0gIDE2MCAxNjAgMTA4IDI1OCAzNjAgLi4uXG4gJCBocCAgOiBudW0gIDExMCAxMTAgOTMgMTEwIDE3NSAxMDUgMjQ1IDYyIDk1IDEyMyAuLi5cbiAkIGRyYXQ6IG51bSAgMy45IDMuOSAzLjg1IDMuMDggMy4xNSAyLjc2IDMuMjEgMy42OSAzLjkyIDMuOTIgLi4uXG4gJCB3dCAgOiBudW0gIDIuNjIgMi44OCAyLjMyIDMuMjEgMy40NCAuLi5cbiAkIHFzZWM6IG51bSAgMTYuNSAxNyAxOC42IDE5LjQgMTcgLi4uXG4gJCB2cyAgOiBudW0gIDAgMCAxIDEgMCAxIDAgMSAxIDEgLi4uXG4gJCBhbSAgOiBudW0gIDEgMSAxIDAgMCAwIDAgMCAwIDAgLi4uXG4gJCBnZWFyOiBudW0gIDQgNCA0IDMgMyAzIDMgNCA0IDQgLi4uXG4gJCBjYXJiOiBudW0gIDQgNCAxIDEgMiAxIDQgMiAyIDQgLi4uXG5cbiMgQ2hlY2sgdGhlIHN0cnVjdHVyZSBvZiBwbGFuZXRzX2RmXG4+IHN0cihwbGFuZXRzX2RmKVxuJ2RhdGEuZnJhbWUnOiAgIDggb2JzLiBvZiAgNSB2YXJpYWJsZXM6XG4gJCBuYW1lICAgIDogRmFjdG9yIHcvIDggbGV2ZWxzIFwiRWFydGhcIixcIkp1cGl0ZXJcIiwuLjogNCA4IDEgMyAyIDYgNyA1XG4gJCB0eXBlICAgIDogRmFjdG9yIHcvIDIgbGV2ZWxzIFwiR2FzIGdpYW50XCIsXCJUZXJyZXN0cmlhbCBwbGFuZXRcIjogMiAyIDIgMiAxIDEgMSAxXG4gJCBkaWFtZXRlcjogbnVtICAwLjM4MiAwLjk0OSAxIDAuNTMyIDExLjIwOSAuLi5cbiAkIHJvdGF0aW9uOiBudW0gIDU4LjY0IC0yNDMuMDIgMSAxLjAzIDAuNDEgLi4uXG4gJCByaW5ncyAgIDogbG9naSAgRkFMU0UgRkFMU0UgRkFMU0UgRkFMU0UgVFJVRSBUUlVFIC4uLlxuIikpLG1keCgiZGl2Iix7aWQ6InNlbGVjdGlvbkZyYW1lRWxlbWVudHMifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tc2VsZWN0aW9uLW9mLWRhdGEtZnJhbWUtZWxlbWVudHMifSwiLS0tLSBTZWxlY3Rpb24gb2YgZGF0YSBmcmFtZSBlbGVtZW50cyIpLG1keCgicCIsbnVsbCwiU2ltaWxhciB0byB2ZWN0b3JzIGFuZCBtYXRyaWNlcywgeW91IHNlbGVjdCBlbGVtZW50cyBmcm9tIGEgZGF0YSBmcmFtZSB3aXRoIHRoZSBoZWxwIG9mIHNxdWFyZSBicmFja2V0cyAiLCJbIF0iLCIuIEJ5IHVzaW5nIGEgY29tbWEsIHlvdSBjYW4gaW5kaWNhdGUgd2hhdCB0byBzZWxlY3QgZnJvbSB0aGUgcm93cyBhbmQgdGhlIGNvbHVtbnMgcmVzcGVjdGl2ZWx5LiBGb3IgZXhhbXBsZToiKSxtZHgoInAiLG51bGwsIm15X2RmIiwiWzEsMl0iLCIgc2VsZWN0cyB0aGUgdmFsdWUgYXQgdGhlIGZpcnN0IHJvdyBhbmQgc2VsZWN0IGVsZW1lbnQgaW4gbXlfZGYuXG5teV9kZiIsIlsxOjMsMjo0XSIsIiBzZWxlY3RzIHJvd3MgMSwgMiwgMyBhbmQgY29sdW1ucyAyLCAzLCA0IGluIG15X2RmLlxuU29tZXRpbWVzIHlvdSB3YW50IHRvIHNlbGVjdCBhbGwgZWxlbWVudHMgb2YgYSByb3cgb3IgY29sdW1uLiBGb3IgZXhhbXBsZSwgbXlfZGYiLCJbMSwgXSIsIiBzZWxlY3RzIGFsbCBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgcm93LiBMZXQgdXMgbm93IGFwcGx5IHRoaXMgdGVjaG5pcXVlIG9uIHBsYW5ldHNfZGYhIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gcGxhbmV0c19kZlxuICAgICBuYW1lICAgICAgICAgICAgICAgdHlwZSBkaWFtZXRlciByb3RhdGlvbiByaW5nc1xuMSBNZXJjdXJ5IFRlcnJlc3RyaWFsIHBsYW5ldCAgICAwLjM4MiAgICA1OC42NCBGQUxTRVxuMiAgIFZlbnVzIFRlcnJlc3RyaWFsIHBsYW5ldCAgICAwLjk0OSAgLTI0My4wMiBGQUxTRVxuMyAgIEVhcnRoIFRlcnJlc3RyaWFsIHBsYW5ldCAgICAxLjAwMCAgICAgMS4wMCBGQUxTRVxuNCAgICBNYXJzIFRlcnJlc3RyaWFsIHBsYW5ldCAgICAwLjUzMiAgICAgMS4wMyBGQUxTRVxuNSBKdXBpdGVyICAgICAgICAgIEdhcyBnaWFudCAgIDExLjIwOSAgICAgMC40MSAgVFJVRVxuNiAgU2F0dXJuICAgICAgICAgIEdhcyBnaWFudCAgICA5LjQ0OSAgICAgMC40MyAgVFJVRVxuNyAgVXJhbnVzICAgICAgICAgIEdhcyBnaWFudCAgICA0LjAwNyAgICAtMC43MiAgVFJVRVxuOCBOZXB0dW5lICAgICAgICAgIEdhcyBnaWFudCAgICAzLjg4MyAgICAgMC42NyAgVFJVRVxuXG4jIFByaW50IG91dCBkaWFtZXRlciBvZiBNZXJjdXJ5IChyb3cgMSwgY29sdW1uIDMpXG4+IHBsYW5ldHNfZGZbMSwzXVxuWzFdIDAuMzgyXG4+XG4jIFByaW50IG91dCBkYXRhIGZvciBNYXJzIChlbnRpcmUgZm91cnRoIHJvdylcbj4gcGxhbmV0c19kZls0LCBdXG4gIG5hbWUgICAgICAgICAgICAgICB0eXBlIGRpYW1ldGVyIHJvdGF0aW9uIHJpbmdzXG40IE1hcnMgVGVycmVzdHJpYWwgcGxhbmV0ICAgIDAuNTMyICAgICAxLjAzIEZBTFNFXG5cbiMgU2VsZWN0IGZpcnN0IDUgdmFsdWVzIG9mIGRpYW1ldGVyIGNvbHVtblxuPiBwbGFuZXRzX2RmWzE6NSwgXCJkaWFtZXRlclwiXVxuWzFdICAwLjM4MiAgMC45NDkgIDEuMDAwICAwLjUzMiAxMS4yMDlcblxuIyBTZWxlY3QgdGhlIHJpbmdzIHZhcmlhYmxlIGZyb20gcGxhbmV0c19kZlxuPiByaW5nc192ZWN0b3IgPC0gcGxhbmV0c19kZlssXCJyaW5nc1wiXVxuPlxuIyBQcmludCBvdXQgcmluZ3NfdmVjdG9yXG4+IHJpbmdzX3ZlY3RvclxuWzFdIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFICBUUlVFICBUUlVFICBUUlVFICBUUlVFXG5cbiMgQWRhcHQgdGhlIGNvZGUgdG8gc2VsZWN0IGFsbCBjb2x1bW5zIGZvciBwbGFuZXRzIHdpdGggcmluZ3Ncbj4gcGxhbmV0c19kZltyaW5nc192ZWN0b3IsIF1cbiAgICAgbmFtZSAgICAgIHR5cGUgZGlhbWV0ZXIgcm90YXRpb24gcmluZ3NcbjUgSnVwaXRlciBHYXMgZ2lhbnQgICAxMS4yMDkgICAgIDAuNDEgIFRSVUVcbjYgIFNhdHVybiBHYXMgZ2lhbnQgICAgOS40NDkgICAgIDAuNDMgIFRSVUVcbjcgIFVyYW51cyBHYXMgZ2lhbnQgICAgNC4wMDcgICAgLTAuNzIgIFRSVUVcbjggTmVwdHVuZSBHYXMgZ2lhbnQgICAgMy44ODMgICAgIDAuNjcgIFRSVUVcbiIpKSxtZHgoImRpdiIse2lkOiJzdWJzZXRzIn0pLG1keCgiaDMiLHsiaWQiOiItLS0tLXN1YnNldHMifSwiLS0tLSBTdWJzZXRzIiksbWR4KCJwIixudWxsLCJZb3Ugc2hvdWxkIHNlZSB0aGUgc3Vic2V0KCkgZnVuY3Rpb24gYXMgYSBzaG9ydC1jdXQgdG8gZG8gZXhhY3RseSB0aGUgc2FtZSBhcyB3aGF0IHlvdSBkaWQgaW4gdGhlIHByZXZpb3VzIGV4ZXJjaXNlcy4iKSxtZHgoInAiLG51bGwsInN1YnNldChteV9kZiwgc3Vic2V0ID0gc29tZV9jb25kaXRpb24pXG5UaGUgZmlyc3QgYXJndW1lbnQgb2Ygc3Vic2V0KCkgc3BlY2lmaWVzIHRoZSBkYXRhIHNldCBmb3Igd2hpY2ggeW91IHdhbnQgYSBzdWJzZXQuIEJ5IGFkZGluZyB0aGUgc2Vjb25kIGFyZ3VtZW50LCB5b3UgZ2l2ZSBSIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gYW5kIGNvbmRpdGlvbnMgdG8gc2VsZWN0IHRoZSBjb3JyZWN0IHN1YnNldC4iKSxtZHgoInAiLG51bGwsIlRoZSBjb2RlIGJlbG93IHdpbGwgZ2l2ZSB0aGUgZXhhY3Qgc2FtZSByZXN1bHQgYXMgeW91IGdvdCBpbiB0aGUgcHJldmlvdXMgZXhlcmNpc2UsIGJ1dCB0aGlzIHRpbWUsIHlvdSBkaWRuJ3QgbmVlZCB0aGUgcmluZ3NfdmVjdG9yISIpLG1keCgicCIsbnVsbCwic3Vic2V0KHBsYW5ldHNfZGYsIHN1YnNldCA9IHJpbmdzKSIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFNlbGVjdCBwbGFuZXRzIHdpdGggZGlhbWV0ZXIgPCAxXG4+IHN1YnNldChwbGFuZXRzX2RmLCBzdWJzZXQgPSBkaWFtZXRlciA8IDEpXG4gICAgIG5hbWUgICAgICAgICAgICAgICB0eXBlIGRpYW1ldGVyIHJvdGF0aW9uIHJpbmdzXG4xIE1lcmN1cnkgVGVycmVzdHJpYWwgcGxhbmV0ICAgIDAuMzgyICAgIDU4LjY0IEZBTFNFXG4yICAgVmVudXMgVGVycmVzdHJpYWwgcGxhbmV0ICAgIDAuOTQ5ICAtMjQzLjAyIEZBTFNFXG40ICAgIE1hcnMgVGVycmVzdHJpYWwgcGxhbmV0ICAgIDAuNTMyICAgICAxLjAzIEZBTFNFXG5cbj4gc3Vic2V0KHBsYW5ldHNfZGYsIHN1YnNldCA9IGRpYW1ldGVyID4gMSlcbiAgICAgbmFtZSAgICAgIHR5cGUgZGlhbWV0ZXIgcm90YXRpb24gcmluZ3NcbjUgSnVwaXRlciBHYXMgZ2lhbnQgICAxMS4yMDkgICAgIDAuNDEgIFRSVUVcbjYgIFNhdHVybiBHYXMgZ2lhbnQgICAgOS40NDkgICAgIDAuNDMgIFRSVUVcbjcgIFVyYW51cyBHYXMgZ2lhbnQgICAgNC4wMDcgICAgLTAuNzIgIFRSVUVcbjggTmVwdHVuZSBHYXMgZ2lhbnQgICAgMy44ODMgICAgIDAuNjcgIFRSVUVcbiIpKSxtZHgoImRpdiIse2lkOiJzb3J0aW5nIn0pLG1keCgiaDMiLHsiaWQiOiItLS0tLXNvcnRpbmcifSwiLS0tLSBTb3J0aW5nIiksbWR4KCJwIixudWxsLCJJbiBkYXRhIGFuYWx5c2lzIHlvdSBjYW4gc29ydCB5b3VyIGRhdGEgYWNjb3JkaW5nIHRvIGEgY2VydGFpbiB2YXJpYWJsZSBpbiB0aGUgZGF0YSBzZXQuIEluIFIsIHRoaXMgaXMgZG9uZSB3aXRoIHRoZSBoZWxwIG9mIHRoZSBmdW5jdGlvbiBvcmRlcigpLiIpLG1keCgicCIsbnVsbCwib3JkZXIoKSBpcyBhIGZ1bmN0aW9uIHRoYXQgZ2l2ZXMgeW91IHRoZSByYW5rZWQgcG9zaXRpb24gb2YgZWFjaCBlbGVtZW50IHdoZW4gaXQgaXMgYXBwbGllZCBvbiBhIHZhcmlhYmxlLCBzdWNoIGFzIGEgdmVjdG9yIGZvciBleGFtcGxlOiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCI+IGEgPC0gYygxMDAsIDEwLCAxMDAwKVxuPiBvcmRlcihhKVxuWzFdIDIgMSAzXG4iKSksbWR4KCJwIixudWxsLCIxMCwgd2hpY2ggaXMgdGhlIHNlY29uZCBlbGVtZW50IGluIGEsIGlzIHRoZSBzbWFsbGVzdCBlbGVtZW50LCBzbyAyIGNvbWVzIGZpcnN0IGluIHRoZSBvdXRwdXQgb2Ygb3JkZXIoYSkuIDEwMCwgd2hpY2ggaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBpcyB0aGUgc2Vjb25kIHNtYWxsZXN0IGVsZW1lbnQsIHNvIDEgY29tZXMgc2Vjb25kIGluIHRoZSBvdXRwdXQgb2Ygb3JkZXIoYSkuIiksbWR4KCJwIixudWxsLCJUaGlzIG1lYW5zIHdlIGNhbiB1c2UgdGhlIG91dHB1dCBvZiBvcmRlcihhKSB0byByZXNodWZmbGUgYToiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBhIDwtIGMoMTAsIDMwLCAxMDApXG4+IG9yZGVyKGEpXG5bMV0gMSAyIDNcbj4gYiA8LSBjKDEwMCwgMzAwLCAyMClcbj4gb3JkZXIoYilcblsxXSAzIDEgMlxuPiBjIDwtIGEgKyBiXG4+IG9yZGVyKGMpXG5bMV0gMSAzIDJcbj4gY1tvcmRlcihjKV1cblsxXSAxMTAgMTIwIDMzMFxuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIHBsYW5ldHNfZGYgaXMgcHJlLWxvYWRlZCBpbiB5b3VyIHdvcmtzcGFjZVxuPiBwbGFuZXRzX2RmJGRpYW1ldGVyXG5bMV0gIDAuMzgyICAwLjk0OSAgMS4wMDAgIDAuNTMyIDExLjIwOSAgOS40NDkgIDQuMDA3ICAzLjg4M1xuXG4jIFVzZSBvcmRlcigpIHRvIGNyZWF0ZSBwb3NpdGlvbnNcbj4gcG9zaXRpb25zIDwtIG9yZGVyKHBsYW5ldHNfZGYkZGlhbWV0ZXIpXG4+IHBsYW5ldHNfZGZcbiAgICAgbmFtZSAgICAgICAgICAgICAgIHR5cGUgZGlhbWV0ZXIgcm90YXRpb24gcmluZ3NcbjEgTWVyY3VyeSBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMC4zODIgICAgNTguNjQgRkFMU0VcbjIgICBWZW51cyBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMC45NDkgIC0yNDMuMDIgRkFMU0VcbjMgICBFYXJ0aCBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMS4wMDAgICAgIDEuMDAgRkFMU0VcbjQgICAgTWFycyBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMC41MzIgICAgIDEuMDMgRkFMU0VcbjUgSnVwaXRlciAgICAgICAgICBHYXMgZ2lhbnQgICAxMS4yMDkgICAgIDAuNDEgIFRSVUVcbjYgIFNhdHVybiAgICAgICAgICBHYXMgZ2lhbnQgICAgOS40NDkgICAgIDAuNDMgIFRSVUVcbjcgIFVyYW51cyAgICAgICAgICBHYXMgZ2lhbnQgICAgNC4wMDcgICAgLTAuNzIgIFRSVUVcbjggTmVwdHVuZSAgICAgICAgICBHYXMgZ2lhbnQgICAgMy44ODMgICAgIDAuNjcgIFRSVUVcblxuIyBVc2UgcG9zaXRpb25zIHRvIHNvcnQgcGxhbmV0c19kZlxuPiBwbGFuZXRzX2RmW3Bvc2l0aW9ucywgXVxuICAgICBuYW1lICAgICAgICAgICAgICAgdHlwZSBkaWFtZXRlciByb3RhdGlvbiByaW5nc1xuMSBNZXJjdXJ5IFRlcnJlc3RyaWFsIHBsYW5ldCAgICAwLjM4MiAgICA1OC42NCBGQUxTRVxuNCAgICBNYXJzIFRlcnJlc3RyaWFsIHBsYW5ldCAgICAwLjUzMiAgICAgMS4wMyBGQUxTRVxuMiAgIFZlbnVzIFRlcnJlc3RyaWFsIHBsYW5ldCAgICAwLjk0OSAgLTI0My4wMiBGQUxTRVxuMyAgIEVhcnRoIFRlcnJlc3RyaWFsIHBsYW5ldCAgICAxLjAwMCAgICAgMS4wMCBGQUxTRVxuOCBOZXB0dW5lICAgICAgICAgIEdhcyBnaWFudCAgICAzLjg4MyAgICAgMC42NyAgVFJVRVxuNyAgVXJhbnVzICAgICAgICAgIEdhcyBnaWFudCAgICA0LjAwNyAgICAtMC43MiAgVFJVRVxuNiAgU2F0dXJuICAgICAgICAgIEdhcyBnaWFudCAgICA5LjQ0OSAgICAgMC40MyAgVFJVRVxuNSBKdXBpdGVyICAgICAgICAgIEdhcyBnaWFudCAgIDExLjIwOSAgICAgMC40MSAgVFJVRVxuXG4+IHBsYW5ldHNfZGZcbiAgICAgbmFtZSAgICAgICAgICAgICAgIHR5cGUgZGlhbWV0ZXIgcm90YXRpb24gcmluZ3NcbjEgTWVyY3VyeSBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMC4zODIgICAgNTguNjQgRkFMU0VcbjIgICBWZW51cyBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMC45NDkgIC0yNDMuMDIgRkFMU0VcbjMgICBFYXJ0aCBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMS4wMDAgICAgIDEuMDAgRkFMU0VcbjQgICAgTWFycyBUZXJyZXN0cmlhbCBwbGFuZXQgICAgMC41MzIgICAgIDEuMDMgRkFMU0VcbjUgSnVwaXRlciAgICAgICAgICBHYXMgZ2lhbnQgICAxMS4yMDkgICAgIDAuNDEgIFRSVUVcbjYgIFNhdHVybiAgICAgICAgICBHYXMgZ2lhbnQgICAgOS40NDkgICAgIDAuNDMgIFRSVUVcbjcgIFVyYW51cyAgICAgICAgICBHYXMgZ2lhbnQgICAgNC4wMDcgICAgLTAuNzIgIFRSVUVcbjggTmVwdHVuZSAgICAgICAgICBHYXMgZ2lhbnQgICAgMy44ODMgICAgIDAuNjcgIFRSVUVcbiIpKSxtZHgoImRpdiIse2lkOiJsaXN0cyJ9KSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoibGlzdHMifSwiTGlzdHMiKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIlJlY2FwIHNvIGZhciIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgicCIse3BhcmVudE5hbWU6ImxpIn0sIlZlY3RvcnMgKG9uZSBkaW1lbnNpb25hbCBhcnJheSk6IGNhbiBob2xkIG51bWVyaWMsIGNoYXJhY3RlciBvciBsb2dpY2FsIHZhbHVlcy4gVGhlIGVsZW1lbnRzIGluIGEgdmVjdG9yIGFsbCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS4iKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJwIix7cGFyZW50TmFtZToibGkifSwiTWF0cmljZXMgKHR3byBkaW1lbnNpb25hbCBhcnJheSk6IGNhbiBob2xkIG51bWVyaWMsIGNoYXJhY3RlciBvciBsb2dpY2FsIHZhbHVlcy4gVGhlIGVsZW1lbnRzIGluIGEgbWF0cml4IGFsbCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS4iKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJwIix7cGFyZW50TmFtZToibGkifSwiRGF0YSBmcmFtZXMgKHR3by1kaW1lbnNpb25hbCBvYmplY3RzKTogY2FuIGhvbGQgbnVtZXJpYywgY2hhcmFjdGVyIG9yIGxvZ2ljYWwgdmFsdWVzLiBXaXRoaW4gYSBjb2x1bW4gYWxsIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLCBidXQgZGlmZmVyZW50IGNvbHVtbnMgY2FuIGJlIG9mIGRpZmZlcmVudCBkYXRhIHR5cGUuIikpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIkxpc3RzIikpLG1keCgicCIsbnVsbCwiQSBsaXN0IGluIFIgaXMgc2ltaWxhciB0byB5b3VyIHRvLWRvIGxpc3QgYXQgd29yayBvciBzY2hvb2w6IHRoZSBkaWZmZXJlbnQgaXRlbXMgb24gdGhhdCBsaXN0IG1vc3QgbGlrZWx5IGRpZmZlciBpbiBsZW5ndGgsIGNoYXJhY3RlcmlzdGljLCB0eXBlIG9mIGFjdGl2aXR5IHRoYXQgaGFzIHRvIGRvIGJlIGRvbmUsIC4uLiIpLG1keCgicCIsbnVsbCwiQSBsaXN0IGluIFIgYWxsb3dzIHlvdSB0byBnYXRoZXIgYSB2YXJpZXR5IG9mIG9iamVjdHMgdW5kZXIgb25lIG5hbWUgKHRoYXQgaXMsIHRoZSBuYW1lIG9mIHRoZSBsaXN0KSBpbiBhbiBvcmRlcmVkIHdheS4gVGhlc2Ugb2JqZWN0cyBjYW4gYmUgbWF0cmljZXMsIHZlY3RvcnMsIGRhdGEgZnJhbWVzLCBldmVuIG90aGVyIGxpc3RzLCBldGMuIEl0IGlzIG5vdCBldmVuIHJlcXVpcmVkIHRoYXQgdGhlc2Ugb2JqZWN0cyBhcmUgcmVsYXRlZCB0byBlYWNoIG90aGVyIGluIGFueSB3YXkuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm15X2xpc3QgPC0gbGlzdChjb21wMSwgY29tcDIsIC4uLilcbiIpKSxtZHgoInAiLG51bGwsIlRoZSBhcmd1bWVudHMgdG8gdGhlIGxpc3QgZnVuY3Rpb24gYXJlIHRoZSBsaXN0IGNvbXBvbmVudHMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVmVjdG9yIHdpdGggbnVtZXJpY3MgZnJvbSAxIHVwIHRvIDEwXG4+IG15X3ZlY3RvciA8LSAxOjEwXG4+XG4jIE1hdHJpeCB3aXRoIG51bWVyaWNzIGZyb20gMSB1cCB0byA5XG4+IG15X21hdHJpeCA8LSBtYXRyaXgoMTo5LCBuY29sID0gMylcbj5cbiMgRmlyc3QgMTAgZWxlbWVudHMgb2YgdGhlIGJ1aWx0LWluIGRhdGEgZnJhbWUgbXRjYXJzXG4+IG15X2RmIDwtIG10Y2Fyc1sxOjEwLF1cbj5cbiMgQ29uc3RydWN0IGxpc3Qgd2l0aCB0aGVzZSBkaWZmZXJlbnQgZWxlbWVudHM6XG4+IG15X2xpc3QgPC0gbGlzdChteV92ZWN0b3IsIG15X21hdHJpeCwgbXlfZGYpXG4+IG15X2xpc3RcbltbMV1dXG4gWzFdICAxICAyICAzICA0ICA1ICA2ICA3ICA4ICA5IDEwXG5cbltbMl1dXG4gICAgIFssMV0gWywyXSBbLDNdXG5bMSxdICAgIDEgICAgNCAgICA3XG5bMixdICAgIDIgICAgNSAgICA4XG5bMyxdICAgIDMgICAgNiAgICA5XG5cbltbM11dXG4gICAgICAgICAgICAgICAgICAgbXBnIGN5bCAgZGlzcCAgaHAgZHJhdCAgICB3dCAgcXNlYyB2cyBhbSBnZWFyIGNhcmJcbk1hemRhIFJYNCAgICAgICAgIDIxLjAgICA2IDE2MC4wIDExMCAzLjkwIDIuNjIwIDE2LjQ2ICAwICAxICAgIDQgICAgNFxuTWF6ZGEgUlg0IFdhZyAgICAgMjEuMCAgIDYgMTYwLjAgMTEwIDMuOTAgMi44NzUgMTcuMDIgIDAgIDEgICAgNCAgICA0XG5EYXRzdW4gNzEwICAgICAgICAyMi44ICAgNCAxMDguMCAgOTMgMy44NSAyLjMyMCAxOC42MSAgMSAgMSAgICA0ICAgIDFcbkhvcm5ldCA0IERyaXZlICAgIDIxLjQgICA2IDI1OC4wIDExMCAzLjA4IDMuMjE1IDE5LjQ0ICAxICAwICAgIDMgICAgMVxuSG9ybmV0IFNwb3J0YWJvdXQgMTguNyAgIDggMzYwLjAgMTc1IDMuMTUgMy40NDAgMTcuMDIgIDAgIDAgICAgMyAgICAyXG5WYWxpYW50ICAgICAgICAgICAxOC4xICAgNiAyMjUuMCAxMDUgMi43NiAzLjQ2MCAyMC4yMiAgMSAgMCAgICAzICAgIDFcbkR1c3RlciAzNjAgICAgICAgIDE0LjMgICA4IDM2MC4wIDI0NSAzLjIxIDMuNTcwIDE1Ljg0ICAwICAwICAgIDMgICAgNFxuTWVyYyAyNDBEICAgICAgICAgMjQuNCAgIDQgMTQ2LjcgIDYyIDMuNjkgMy4xOTAgMjAuMDAgIDEgIDAgICAgNCAgICAyXG5NZXJjIDIzMCAgICAgICAgICAyMi44ICAgNCAxNDAuOCAgOTUgMy45MiAzLjE1MCAyMi45MCAgMSAgMCAgICA0ICAgIDJcbk1lcmMgMjgwICAgICAgICAgIDE5LjIgICA2IDE2Ny42IDEyMyAzLjkyIDMuNDQwIDE4LjMwICAxICAwICAgIDQgICAgNFxuIikpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiTmFtaW5nIGEgTGlzdCIpKSxtZHgoInAiLG51bGwsIldlIGNhbiB1c2UgdGhlIG5hbWUoKSBmdW5jdGlvbiB0byBnZXQgYXJvdW5kIHRoaXMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm15X2xpc3QgPC0gbGlzdChuYW1lMSA9IHlvdXJfY29tcDEsXG4gICAgICAgICAgICAgICAgbmFtZTIgPSB5b3VyX2NvbXAyKVxuIikpLG1keCgicCIsbnVsbCwiV2UgYWxzbyBhbHRlciBuYW1lcyBsYXRlciBsaWtlIHNvLi4uIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIm15X2xpc3QgPC0gbGlzdCh5b3VyX2NvbXAxLCB5b3VyX2NvbXAyKVxubmFtZXMobXlfbGlzdCkgPC0gYyhcIm5hbWUxXCIsIFwibmFtZTJcIilcbiIpKSxtZHgoInAiLG51bGwsIkNvbnRpbnVpbmcgb24gZnJvbSB0aGUgYWJvdmUgZXhhbXBlLi4uIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gbmFtZXMobXlfbGlzdCkgPC0gYyhcInZlY1wiLCBcIm1hdFwiLCBcImRmXCIpXG4+XG4+ICMgUHJpbnQgb3V0IG15X2xpc3Rcbj4gbXlfbGlzdFxuJHZlY1xuIFsxXSAgMSAgMiAgMyAgNCAgNSAgNiAgNyAgOCAgOSAxMFxuXG4kbWF0XG4gICAgIFssMV0gWywyXSBbLDNdXG5bMSxdICAgIDEgICAgNCAgICA3XG5bMixdICAgIDIgICAgNSAgICA4XG5bMyxdICAgIDMgICAgNiAgICA5XG5cbiRkZlxuICAgICAgICAgICAgICAgICAgIG1wZyBjeWwgIGRpc3AgIGhwIGRyYXQgICAgd3QgIHFzZWMgdnMgYW0gZ2VhciBjYXJiXG5NYXpkYSBSWDQgICAgICAgICAyMS4wICAgNiAxNjAuMCAxMTAgMy45MCAyLjYyMCAxNi40NiAgMCAgMSAgICA0ICAgIDRcbk1hemRhIFJYNCBXYWcgICAgIDIxLjAgICA2IDE2MC4wIDExMCAzLjkwIDIuODc1IDE3LjAyICAwICAxICAgIDQgICAgNFxuRGF0c3VuIDcxMCAgICAgICAgMjIuOCAgIDQgMTA4LjAgIDkzIDMuODUgMi4zMjAgMTguNjEgIDEgIDEgICAgNCAgICAxXG5Ib3JuZXQgNCBEcml2ZSAgICAyMS40ICAgNiAyNTguMCAxMTAgMy4wOCAzLjIxNSAxOS40NCAgMSAgMCAgICAzICAgIDFcbkhvcm5ldCBTcG9ydGFib3V0IDE4LjcgICA4IDM2MC4wIDE3NSAzLjE1IDMuNDQwIDE3LjAyICAwICAwICAgIDMgICAgMlxuVmFsaWFudCAgICAgICAgICAgMTguMSAgIDYgMjI1LjAgMTA1IDIuNzYgMy40NjAgMjAuMjIgIDEgIDAgICAgMyAgICAxXG5EdXN0ZXIgMzYwICAgICAgICAxNC4zICAgOCAzNjAuMCAyNDUgMy4yMSAzLjU3MCAxNS44NCAgMCAgMCAgICAzICAgIDRcbk1lcmMgMjQwRCAgICAgICAgIDI0LjQgICA0IDE0Ni43ICA2MiAzLjY5IDMuMTkwIDIwLjAwICAxICAwICAgIDQgICAgMlxuTWVyYyAyMzAgICAgICAgICAgMjIuOCAgIDQgMTQwLjggIDk1IDMuOTIgMy4xNTAgMjIuOTAgIDEgIDAgICAgNCAgICAyXG5NZXJjIDI4MCAgICAgICAgICAxOS4yICAgNiAxNjcuNiAxMjMgMy45MiAzLjQ0MCAxOC4zMCAgMSAgMCAgICA0ICAgIDRcbiIpKSxtZHgoInAiLG51bGwsIkFub3RoZXIgZXhhbXBsZSBvZiBuYW1pbmcgTGlzdCBjb21wb25lbnRzLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCI+IHNoaW5pbmdfbGlzdCA8LSBsaXN0KG1vdmllbmFtZSA9IG1vdiwgYWN0b3JzID0gYWN0LCByZXZpZXdzID0gcmV2KVxuPiBzaGluaW5nX2xpc3RcbiRtb3ZpZW5hbWVcblsxXSBcIlRoZSBTaGluaW5nXCJcblxuJGFjdG9yc1xuWzFdIFwiSmFjayBOaWNob2xzb25cIiAgIFwiU2hlbGxleSBEdXZhbGxcIiAgIFwiRGFubnkgTGxveWRcIiAgICAgIFwiU2NhdG1hbiBDcm90aGVyc1wiXG5bNV0gXCJCYXJyeSBOZWxzb25cIlxuXG4kcmV2aWV3c1xuICBzY29yZXMgc291cmNlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50c1xuMSAgICA0LjUgICBJTURiMSAgICAgICAgICAgICAgICAgICAgIEJlc3QgSG9ycm9yIEZpbG0gSSBIYXZlIEV2ZXIgU2VlblxuMiAgICA0LjAgICBJTURiMiBBIHRydWx5IGJyaWxsaWFudCBhbmQgc2NhcnkgZmlsbSBmcm9tIFN0YW5sZXkgS3Vicmlja1xuMyAgICA1LjAgICBJTURiMyAgICAgICAgICAgICAgICAgQSBtYXN0ZXJwaWVjZSBvZiBwc3ljaG9sb2dpY2FsIGhvcnJvclxuIikpLG1keCgiZGl2Iix7aWQ6Imxpc3RlbGVtZW50cyJ9KSxtZHgoImgzIix7ImlkIjoiLS0tLS1zZWxlY3RpbmctZWxlbWVudHMtZnJvbS1hLWxpc3QifSwiLS0tLSBTZWxlY3RpbmcgRWxlbWVudHMgZnJvbSBhIExpc3QiKSxtZHgoInAiLG51bGwsIllvdXIgbGlzdCB3aWxsIG9mdGVuIGJlIGJ1aWx0IG91dCBvZiBudW1lcm91cyBlbGVtZW50cyBhbmQgY29tcG9uZW50cy4gVGhlcmVmb3JlLCBnZXR0aW5nIGEgc2luZ2xlIGVsZW1lbnQsIG11bHRpcGxlIGVsZW1lbnRzLCBvciBhIGNvbXBvbmVudCBvdXQgb2YgaXQgaXMgbm90IGFsd2F5cyBzdHJhaWdodGZvcndhcmQuIiksbWR4KCJwIixudWxsLCJPbmUgd2F5IHRvIHNlbGVjdCBhIGNvbXBvbmVudCBpcyB1c2luZyB0aGUgbnVtYmVyZWQgcG9zaXRpb24gb2YgdGhhdCBjb21wb25lbnQuIEZvciBleGFtcGxlLCB0byBcImdyYWJcIiB0aGUgZmlyc3QgY29tcG9uZW50IG9mIHNoaW5pbmdfbGlzdCB5b3UgdHlwZSIpLG1keCgicCIsbnVsbCxtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInNoaW5pbmdfbGlzdFtbMV1dIikpLG1keCgicCIsbnVsbCwiQSBxdWljayB3YXkgdG8gY2hlY2sgdGhpcyBvdXQgaXMgdHlwaW5nIGl0IGluIHRoZSBjb25zb2xlLiBJbXBvcnRhbnQgdG8gcmVtZW1iZXI6IHRvIHNlbGVjdCBlbGVtZW50cyBmcm9tIHZlY3RvcnMsIHlvdSB1c2Ugc2luZ2xlIHNxdWFyZSBicmFja2V0czogIiwiWyBdIiwiLiBEb24ndCBtaXggdGhlbSB1cCEiKSxtZHgoInAiLG51bGwsIllvdSBjYW4gYWxzbyByZWZlciB0byB0aGUgbmFtZXMgb2YgdGhlIGNvbXBvbmVudHMsIHdpdGggWyIsIlsgXSIsIl0gb3Igd2l0aCB0aGUgJCBzaWduLiBCb3RoIHdpbGwgc2VsZWN0IHRoZSBkYXRhIGZyYW1lIHJlcHJlc2VudGluZyB0aGUgcmV2aWV3czoiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwic2hpbmluZ19saXN0W1tcInJldmlld3NcIl1dXG5zaGluaW5nX2xpc3QkcmV2aWV3c1xuIikpLG1keCgicCIsbnVsbCwiQmVzaWRlcyBzZWxlY3RpbmcgY29tcG9uZW50cywgeW91IG9mdGVuIG5lZWQgdG8gc2VsZWN0IHNwZWNpZmljIGVsZW1lbnRzIG91dCBvZiB0aGVzZSBjb21wb25lbnRzLiBGb3IgZXhhbXBsZSwgd2l0aCAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwic2hpbmluZ19saXN0W1syXV1bMV0iKSwiIHlvdSBzZWxlY3QgZnJvbSB0aGUgc2Vjb25kIGNvbXBvbmVudCwgYWN0b3JzICgiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwic2hpbmluZ19saXN0W1syXV0iKSwiKSwgdGhlIGZpcnN0IGVsZW1lbnQgKCIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJbMV0iKSwiKS4gV2hlbiB5b3UgdHlwZSB0aGlzIGluIHRoZSBjb25zb2xlLCB5b3Ugd2lsbCBzZWUgdGhlIGFuc3dlciBpcyBKYWNrIE5pY2hvbHNvbi4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBQcmludCBvdXQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGFjdG9yc1xuPiBzaGluaW5nX2xpc3QkYWN0b3JzXG5bMV0gXCJKYWNrIE5pY2hvbHNvblwiICAgXCJTaGVsbGV5IER1dmFsbFwiICAgXCJEYW5ueSBMbG95ZFwiICAgICAgXCJTY2F0bWFuIENyb3RoZXJzXCJcbls1XSBcIkJhcnJ5IE5lbHNvblwiXG4+XG4jIFByaW50IHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgYWN0b3JzXG4+IHNoaW5pbmdfbGlzdFtbXCJhY3RvcnNcIl1dWzJdXG5bMV0gXCJTaGVsbGV5IER1dmFsbFwiXG4iKSksbWR4KCJkaXYiLHtpZDoiYWRkaW5nZWxlbXMifSksbWR4KCJoMyIseyJpZCI6Ii0tLS0tYWRkaW5nLW1vcmUtY29tcG9uZW50cy10by1hLWxpc3QifSwiLS0tLSBBZGRpbmcgbW9yZSBjb21wb25lbnRzIHRvIGEgbGlzdCIpLG1keCgicCIsbnVsbCwiVG8gY29udmVuaWVudGx5IGFkZCBlbGVtZW50cyB0byBsaXN0cyB5b3UgY2FuIHVzZSB0aGUgYygpIGZ1bmN0aW9uLCB0aGF0IHlvdSBhbHNvIHVzZWQgdG8gYnVpbGQgdmVjdG9yczoiKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJleHRfbGlzdCA8LSBjKG15X2xpc3QgLCBteV92YWwpIikpLG1keCgicCIsbnVsbCwiVGhpcyB3aWxsIHNpbXBseSBleHRlbmQgdGhlIG9yaWdpbmFsIGxpc3QsICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJteV9saXN0IiksIiwgd2l0aCB0aGUgY29tcG9uZW50ICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJteV92YWwiKSwiLiBUaGlzIGNvbXBvbmVudCBnZXRzIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIElmIHlvdSB3YW50IHRvIGdpdmUgdGhlIG5ldyBsaXN0IGl0ZW0gYSBuYW1lLCB5b3UganVzdCBhZGQgdGhlIG5hbWUgYXMgeW91IGRpZCBiZWZvcmU6IiksbWR4KCJwIixudWxsLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiZXh0X2xpc3QgPC0gYyhteV9saXN0LCBteV9uYW1lID0gbXlfdmFsKSIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBXZSBmb3Jnb3Qgc29tZXRoaW5nOyBhZGQgdGhlIHllYXIgdG8gc2hpbmluZ19saXN0XG4+IHNoaW5pbmdfbGlzdF9mdWxsIDwtIGMoc2hpbmluZ19saXN0LCB5ZWFyID0gMTk4MClcbj5cbiMgSGF2ZSBhIGxvb2sgYXQgc2hpbmluZ19saXN0X2Z1bGxcbj4gc3RyKHNoaW5pbmdfbGlzdF9mdWxsKVxuTGlzdCBvZiA0XG4gJCBtb3ZpZW5hbWU6IGNociBcIlRoZSBTaGluaW5nXCJcbiAkIGFjdG9ycyAgIDogY2hyIFsxOjVdIFwiSmFjayBOaWNob2xzb25cIiBcIlNoZWxsZXkgRHV2YWxsXCIgXCJEYW5ueSBMbG95ZFwiIFwiU2NhdG1hbiBDcm90aGVyc1wiIC4uLlxuICQgcmV2aWV3cyAgOidkYXRhLmZyYW1lJzogIDMgb2JzLiBvZiAgMyB2YXJpYWJsZXM6XG4gIC4uJCBzY29yZXMgIDogbnVtIFsxOjNdIDQuNSA0IDVcbiAgLi4kIHNvdXJjZXMgOiBGYWN0b3Igdy8gMyBsZXZlbHMgXCJJTURiMVwiLFwiSU1EYjJcIiwuLjogMSAyIDNcbiAgLi4kIGNvbW1lbnRzOiBGYWN0b3Igdy8gMyBsZXZlbHMgXCJBIG1hc3RlcnBpZWNlIG9mIHBzeWNob2xvZ2ljYWwgaG9ycm9yXCIsLi46IDMgMiAxXG4gJCB5ZWFyICAgICA6IG51bSAxOTgwXG4iKSkpO31pZih0eXBlb2YgTURYQ29udGVudCE9PSd1bmRlZmluZWQnJiZNRFhDb250ZW50JiZNRFhDb250ZW50PT09T2JqZWN0KE1EWENvbnRlbnQpJiZPYmplY3QuaXNFeHRlbnNpYmxlKE1EWENvbnRlbnQpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoTURYQ29udGVudCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiTURYQ29udGVudCIsZmlsZW5hbWU6Im1hbnVhbC9SL1ItSW50cm8ubWQifX0pO31NRFhDb250ZW50LmlzTURYQ29tcG9uZW50PXRydWU7"},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/R/R-Intro.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <div id=\"1\"></div>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"r-1-how-it-works\"\n    }}>{`R-1: How it Works`}</h2>\n    <p>{`In the editor on the right you should type R code to solve the exercises. When you hit the 'Submit Answer' button, every line of code is interpreted and executed by R and you get a message whether or not your code was correct. The output of your R code is shown in the console in the lower right corner.`}</p>\n    <p>{`R makes use of the # sign to add comments, so that you and others can understand what the R code is about. Just like Twitter! Comments are not run as R code, so they will not influence your result. For example, Calculate 3 + 4 in the editor on the right is a comment.`}</p>\n    <p>{`You can also execute R commands straight in the console. This is a good way to experiment with R code, as your submission is not checked for correctness.`}</p>\n    <div id=\"2\"></div>\n    <h3 {...{\n      \"id\": \"-----arithmetic-with-r\"\n    }}>{`---- Arithmetic with R`}</h3>\n    <p>{`In its most basic form, R can be used as a simple calculator. Consider the following arithmetic operators:`}</p>\n    <p>{`Addition: +\nSubtraction: -\nMultiplication: `}{`*`}{`\nDivision: /\nExponentiation: ^\nModulo: %%`}</p>\n    <p>{`The last two might need some explaining: - The ^ operator raises the number to its left to the power of the number to its right: for example 3^2 is 9. - The modulo returns the remainder of the division of the number to the left by the number on its right, for example 5 modulo 3 or 5 %% 3 is 2.`}</p>\n    <div id=\"3\"></div>\n    <h3 {...{\n      \"id\": \"-----variable-assignment\"\n    }}>{`---- Variable Assignment`}</h3>\n    <p>{`A basic concept in (statistical) programming is called a variable.`}</p>\n    <p>{`A variable allows you to store a value (e.g. 4) or an object (e.g. a function description) in R. You can then later use this variable's name to easily access the value or the object that is stored within this variable.`}</p>\n    <p>{`You can assign a value 4 to a variable my_var with the command`}</p>\n    <p>{`my_var <- 4`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Assign the value 42 to x\nx <- 42\n\n# Print out the value of the variable x\nx\n\n# Assign a value to the variables my_apples and my_oranges\nmy_apples <- 5\nmy_oranges <- 6\n\n# Add these two variables together\nmy_apples + my_oranges\n\n# Create the variable my_fruit\nmy_fruit <- my_apples + my_oranges\n`}</code></pre>\n    <div id=\"4\"></div>\n    <h3 {...{\n      \"id\": \"-----basic-data-types-in-r\"\n    }}>{`---- Basic data types in R`}</h3>\n    <p>{`R works with numerous data types. Some of the most basic types to get started are:`}</p>\n    <p>{`Decimals values like 4.5 are called `}<strong parentName=\"p\">{`numerics`}</strong>{`.\nNatural numbers like 4 are called integers. Integers are also `}<strong parentName=\"p\">{`numerics`}</strong>{`.\nBoolean values (TRUE or FALSE) are called `}<strong parentName=\"p\">{`logical`}</strong>{`.\nText (or string) values are called `}<strong parentName=\"p\">{`characters`}</strong>{`.\nNote how the quotation marks on the right indicate that \"some text\" is a `}<strong parentName=\"p\">{`character`}</strong>{`.`}</p>\n    <p>{`Note that R is case sensitive.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Change my_numeric to be 42\nmy_numeric <- 42\n\n# Change my_character to be \"universe\"\nmy_character <- \"universe\"\n\n# Change my_logical to be FALSE\nmy_logical <- FALSE\n\n# Declare variables of different types\nmy_numeric <- 42\nmy_character <- \"universe\"\nmy_logical <- FALSE\n\n# Check class of my_numeric\nclass(my_numeric)\n\n# Check class of my_character\nclass(my_character)\n\n# Check class of my_logical\nclass(my_logical)\n`}</code></pre>\n    <div id=\"vectors\"></div>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"r-2-vectors\"\n    }}>{`R-2: Vectors`}</h2>\n    <p>{`In R, you create a vector with the combine function c(). You place the vector elements separated by a comma between the parentheses. For example:`}</p>\n    <p>{`numeric_vector <- c(1, 2, 3)\ncharacter_vector <- c(\"a\", \"b\", \"c\")\nOnce you have created these vectors in R, you can use them to do calculations.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`numeric_vector <- c(1, 10, 49)\ncharacter_vector <- c(\"a\", \"b\", \"c\")\n\n# Complete the code for boolean_vector\nboolean_vector <- c(TRUE, FALSE, TRUE)\n`}</code></pre>\n    <div id=\"vectors2\"></div>\n    <h3 {...{\n      \"id\": \"-----naming-a-vector\"\n    }}>{`---- Naming a Vector`}</h3>\n    <p>{`You can give a name to the elements of a vector with the names() function. Have a look at this example:`}</p>\n    <p>{`some_vector <- c(\"John Doe\", \"poker player\")\nnames(some_vector) <- c(\"Name\", \"Profession\")\nThis code first creates a vector some_vector and then gives the two elements a name. The first element is assigned the name Name, while the second element is labeled Profession. Printing the contents to the console yields following output:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`          Name     Profession\n    \"John Doe\" \"poker player\"\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Poker winnings from Monday to Friday\npoker_vector <- c(140, -50, 20, -120, 240)\n\n# Roulette winnings from Monday to Friday\nroulette_vector <- c(-24, -50, 100, -350, 10)\n\n# Assign days as names of poker_vector\nnames(poker_vector) <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n# Assign days as names of roulette_vectors\nnames(roulette_vector) <-c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n# Poker winnings from Monday to Friday\npoker_vector <- c(140, -50, 20, -120, 240)\n\n# Roulette winnings from Monday to Friday\nroulette_vector <- c(-24, -50, 100, -350, 10)\n\n# The variable days_vector\ndays_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n# Assign the names of the day to roulette_vector and poker_vector\nnames(poker_vector) <- days_vector\nnames(roulette_vector) <- days_vector\n\n# Calculating a total vector\nA_vector <- c(1, 2, 3)\nB_vector <- c(4, 5, 6)\n\n# Take the sum of A_vector and B_vector\ntotal_vector <- A_vector + B_vector\n\n# Print out total_vector\ntotal_vector\n\n## Ex 3\n\n# Poker and roulette winnings from Monday to Friday:\npoker_vector <- c(140, -50, 20, -120, 240)\nroulette_vector <- c(-24, -50, 100, -350, 10)\ndays_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nnames(poker_vector) <- days_vector\nnames(roulette_vector) <- days_vector\n\n# Total winnings with poker\ntotal_poker <- sum(poker_vector)\n\n# Total winnings with roulette\ntotal_roulette <- sum(roulette_vector)\n\n# Total winnings overall\ntotal_week <- total_roulette + total_poker\n\n# Print out total_week\ntotal_week\n\n## Ex 4\n\n# Poker and roulette winnings from Monday to Friday:\npoker_vector <- c(140, -50, 20, -120, 240)\nroulette_vector <- c(-24, -50, 100, -350, 10)\ndays_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nnames(poker_vector) <- days_vector\nnames(roulette_vector) <- days_vector\n\n# Calculate total gains for poker and roulette\ntotal_poker <- sum(poker_vector)\ntotal_roulette <- sum(roulette_vector)\n\n# Check if you realized higher total gains in poker than in roulette\ntotal_poker > total_roulette\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Vector Selection`}</strong></p>\n    <h3 {...{\n      \"id\": \"-----vector-selection\"\n    }}>{`---- Vector Selection`}</h3>\n    <h1 {...{\n      \"id\": \"poker-and-roulette-winnings-from-monday-to-friday\"\n    }}>{`Poker and roulette winnings from Monday to Friday:`}</h1>\n    <p>{`poker_vector <- c(140, -50, 20, -120, 240)\nroulette_vector <- c(-24, -50, 100, -350, 10)\ndays_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nnames(poker_vector) <- days_vector\nnames(roulette_vector) <- days_vector`}</p>\n    <h1 {...{\n      \"id\": \"define-a-new-variable-based-on-a-selection\"\n    }}>{`Define a new variable based on a selection`}</h1>\n    <p>{`poker_wednesday <- poker_vector`}{`[3]`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Poker and roulette winnings from Monday to Friday:\npoker_vector <- c(140, -50, 20, -120, 240)\nroulette_vector <- c(-24, -50, 100, -350, 10)\ndays_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nnames(poker_vector) <- days_vector\nnames(roulette_vector) <- days_vector\n\n# Define a new variable based on a selection\npoker_midweek <- poker_vector[c(2,3,4)]\npoker_midweek\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Poker and roulette winnings from Monday to Friday:\n> poker_vector <- c(140, -50, 20, -120, 240)\n> roulette_vector <- c(-24, -50, 100, -350, 10)\n> days_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n> names(poker_vector) <- days_vector\n> names(roulette_vector) <- days_vector\n>\n# Define a new variable based on a selection\n> roulette_selection_vector <- roulette_vector[2:5]\n`}</code></pre>\n    <p>{`Another way to tackle the previous exercise is by using the names of the vector elements (Monday, Tuesday, ...) instead of their numeric positions. For example,`}</p>\n    <p>{`poker_vector`}{`[\"Monday\"]`}{`\nwill select the first element of poker_vector since \"Monday\" is the name of that first element.`}</p>\n    <p>{`Just like you did in the previous exercise with numerics, you can also use the element names to select multiple elements, for example:`}</p>\n    <p>{`poker_vector`}{`[c(\"Monday\",\"Tuesday\")]`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Poker and roulette winnings from Monday to Friday:\n> poker_vector <- c(140, -50, 20, -120, 240)\n> roulette_vector <- c(-24, -50, 100, -350, 10)\n> days_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n> names(poker_vector) <- days_vector\n> names(roulette_vector) <- days_vector\n>\n# Select poker results for Monday, Tuesday and Wednesday\n> poker_start <- poker_vector[c(\"Monday\", \"Tuesday\", \"Wednesday\")]\n>\n# Calculate the average of the elements in poker_start\n> mean(poker_start)\n[1] 36.66667\n`}</code></pre>\n    <div id=\"vectors3\"></div>\n    <h3 {...{\n      \"id\": \"-----selection-by-comparison\"\n    }}>{`---- Selection by Comparison`}</h3>\n    <p>{`By making use of comparison operators, we can approach the previous question in a more proactive way.`}</p>\n    <p>{`The (logical) comparison operators known to R are:`}</p>\n    <p>{`< for less than`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`for greater than\n<= for less than or equal to\n= for greater than or equal to\n== for equal to each other\n!= not equal to each other\nAs seen in the previous chapter, stating 6 > 5 returns TRUE. The nice thing about R is that you can use these comparison operators also on vectors. For example:`}</p>\n      <p parentName=\"blockquote\">{`c(4, 5, 6) > 5\n`}{`[1]`}{` FALSE FALSE TRUE\nThis command tests for every element of the vector if the condition stated by the comparison operator is TRUE or FALSE`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{}}>{`# Poker and roulette winnings from Monday to Friday:\n> poker_vector <- c(140, -50, 20, -120, 240)\n> roulette_vector <- c(-24, -50, 100, -350, 10)\n> days_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n> names(poker_vector) <- days_vector\n> names(roulette_vector) <- days_vector\n>\n# Which days did you make money on poker?\n> selection_vector <- poker_vector > 0\n>\n# Print out selection_vector\n> selection_vector\n   Monday   Tuesday Wednesday  Thursday    Friday\n     TRUE     FALSE      TRUE     FALSE      TRUE\n`}</code></pre>\n    <p>{`Working with comparisons will make your data analytical life easier. Instead of selecting a subset of days to investigate yourself (like before), you can simply ask R to return only those days where you realized a positive return for poker.`}</p>\n    <p>{`In the previous exercises you used selection_vector <- poker_vector > 0 to find the days on which you had a positive poker return. Now, you would like to know not only the days on which you won, but also how much you won on those days.`}</p>\n    <p>{`You can select the desired elements, by putting selection_vector between the square brackets that follow poker_vector:`}</p>\n    <p>{`poker_vector`}{`[selection_vector]`}{`\nR knows what to do when you pass a logical vector in square brackets: it will only select the elements that correspond to TRUE in selection_vector.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Poker and roulette winnings from Monday to Friday:\n> poker_vector <- c(140, -50, 20, -120, 240)\n> roulette_vector <- c(-24, -50, 100, -350, 10)\n> days_vector <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n> names(poker_vector) <- days_vector\n> names(roulette_vector) <- days_vector\n>\n# Which days did you make money on poker?\n> selection_vector <- poker_vector > 0\n>\n# Select from poker_vector these days\n> poker_winning_days <- poker_vector[selection_vector]\n> poker_winning_days\n   Monday Wednesday    Friday\n      140        20       240\n`}</code></pre>\n    <div id=\"matrix\"></div>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"r-3-matrices\"\n    }}>{`R-3: Matrices`}</h2>\n    <p>{`In R, a matrix is a collection of elements of the same data type (numeric, character, or logical) arranged into a fixed number of rows and columns. Since you are only working with rows and columns, a matrix is called two-dimensional.`}</p>\n    <p>{`You can construct a matrix in R with the matrix() function. Consider the following example:`}</p>\n    <p>{`matrix(1:9, byrow = TRUE, nrow = 3)\nIn the matrix() function:`}</p>\n    <p>{`The first argument is the collection of elements that R will arrange into the rows and columns of the matrix. Here, we use 1:9 which is a shortcut for c(1, 2, 3, 4, 5, 6, 7, 8, 9).`}</p>\n    <p>{`The argument byrow indicates that the matrix is filled by the rows. If we want the matrix to be filled by the columns, we just place byrow = FALSE.\nThe third argument nrow indicates that the matrix should have three rows.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Construct a matrix with 3 rows that contain the numbers 1 up to 9\n> matrix(1:9, byrow = TRUE, nrow = 3)\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n> matrix\nfunction (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)\n{\n    if (is.object(data) || !is.atomic(data))\n        data <- as.vector(data)\n    .Internal(matrix(data, nrow, ncol, byrow, dimnames, missing(nrow),\n        missing(ncol)))\n}\n<bytecode: 0xdabe30>\n<environment: namespace:base>\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Creating a matrix using variables`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Box office Star Wars (in millions!)\n> new_hope <- c(460.998, 314.4)\n> empire_strikes <- c(290.475, 247.900)\n> return_jedi <- c(309.306, 165.8)\n>\n# Create box_office\n> box_office <- c(new_hope, empire_strikes, return_jedi)\n>\n# Construct star_wars_matrix\n> star_wars_matrix <- matrix(box_office, byrow = TRUE, nrow = 3)\n> star_wars_matrix\n        [,1]  [,2]\n[1,] 460.998 314.4\n[2,] 290.475 247.9\n[3,] 309.306 165.8\n`}</code></pre>\n    <div id=\"matrix2\"></div>\n    <h3 {...{\n      \"id\": \"-----naming-a-matrix\"\n    }}>{`---- Naming a matrix`}</h3>\n    <p>{`Similar to vectors, you can add names for the rows and the columns of a matrix`}</p>\n    <p>{`rownames(my_matrix) <- row_names_vector\ncolnames(my_matrix) <- col_names_vector\nWe went ahead and prepared two vectors for you: region, and titles. You will need these vectors to name the columns and rows of star_wars_matrix, respectively.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Box office Star Wars (in millions!)\n> new_hope <- c(460.998, 314.4)\n> empire_strikes <- c(290.475, 247.900)\n> return_jedi <- c(309.306, 165.8)\n>\n# Construct matrix\n> star_wars_matrix <- matrix(c(new_hope, empire_strikes, return_jedi), nrow = 3, byrow = TRUE)\n>\n# Vectors region and titles, used for naming\n> region <- c(\"US\", \"non-US\")\n> titles <- c(\"A New Hope\", \"The Empire Strikes Back\", \"Return of the Jedi\")\n>\n# Name the columns with region\n> colnames(star_wars_matrix) <- region\n>\n# Name the rows with titles\n> rownames(star_wars_matrix) <- titles\n>\n# Print out star_wars_matrix\n> star_wars_matrix\n                             US non-US\nA New Hope              460.998  314.4\nThe Empire Strikes Back 290.475  247.9\nReturn of the Jedi      309.306  165.8\n`}</code></pre>\n    <p>{`In R, the function rowSums() conveniently calculates the totals for each row of a matrix. This function creates a new vector:`}</p>\n    <p><inlineCode parentName=\"p\">{`rowSums(my_matrix)`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Construct star_wars_matrix\n> box_office <- c(460.998, 314.4, 290.475, 247.900, 309.306, 165.8)\n> star_wars_matrix <- matrix(box_office, nrow = 3, byrow = TRUE,\n                             dimnames = list(c(\"A New Hope\", \"The Empire Strikes Back\", \"Return of the Jedi\"),\n                                             c(\"US\", \"non-US\")))\n>\n# Calculate worldwide box office figures\n> worldwide_vector <- rowSums(star_wars_matrix)\n`}</code></pre>\n    <p>{`You can add a column or multiple columns to a matrix with the cbind() function, which merges matrices and/or vectors together by column. For example:`}</p>\n    <p>{`big_matrix <- cbind(matrix1, matrix2, vector1 ...)`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Construct star_wars_matrix\n> box_office <- c(460.998, 314.4, 290.475, 247.900, 309.306, 165.8)\n> star_wars_matrix <- matrix(box_office, nrow = 3, byrow = TRUE,\n                             dimnames = list(c(\"A New Hope\", \"The Empire Strikes Back\", \"Return of the Jedi\"),\n                                             c(\"US\", \"non-US\")))\n>\n# The worldwide box office figures\n> worldwide_vector <- rowSums(star_wars_matrix)\n>\n# Bind the new variable worldwide_vector as a column to star_wars_matrix\n> all_wars_matrix <- cbind(star_wars_matrix, worldwide_vector)\n`}</code></pre>\n    <div id=\"addrow\"></div>\n    <h3 {...{\n      \"id\": \"-----adding-a-row\"\n    }}>{`---- Adding a Row`}</h3>\n    <p>{`Just like every action has a reaction, every cbind() has an rbind(). (We admit, we are pretty bad with metaphors.)`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# star_wars_matrix and star_wars_matrix2 are available in your workspace\n> star_wars_matrix  \n                           US non-US\nA New Hope              461.0  314.4\nThe Empire Strikes Back 290.5  247.9\nReturn of the Jedi      309.3  165.8\n> star_wars_matrix2\n                        US non-US\nThe Phantom Menace   474.5  552.5\nAttack of the Clones 310.7  338.7\nRevenge of the Sith  380.3  468.5\n>\n# Combine both Star Wars trilogies in one matrix\n> all_wars_matrix <- rbind(star_wars_matrix, star_wars_matrix2)\n> all_wars_matrix\n                           US non-US\nA New Hope              461.0  314.4\nThe Empire Strikes Back 290.5  247.9\nReturn of the Jedi      309.3  165.8\nThe Phantom Menace      474.5  552.5\nAttack of the Clones    310.7  338.7\nRevenge of the Sith     380.3  468.5\n`}</code></pre>\n    <div id=\"newSection\"></div>\n    <h3 {...{\n      \"id\": \"-----all-functions-for-combining\"\n    }}>{`---- All functions for combining`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`cbind()\nrbind()\ncolSums()\nrowSums()\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`> all_wars_matrix\n                           US non-US\nA New Hope              461.0  314.4\nThe Empire Strikes Back 290.5  247.9\nReturn of the Jedi      309.3  165.8\nThe Phantom Menace      474.5  552.5\nAttack of the Clones    310.7  338.7\nRevenge of the Sith     380.3  468.5\n>\n# Total revenue for US and non-US\n> total_revenue_vector <- colSums(all_wars_matrix)\n>\n# Print out total_revenue_vector\n> total_revenue_vector\n    US non-US\n2226.3 2087.8\n`}</code></pre>\n    <div id=\"matrixElements\"></div>\n    <h3 {...{\n      \"id\": \"-----selection-of-matrix-elements\"\n    }}>{`---- Selection of Matrix Elements`}</h3>\n    <p>{`Similar to vectors, you can use the square brackets `}{`[ ]`}{` to select one or multiple elements from a matrix. Whereas vectors have one dimension, matrices have two dimensions. You should therefore use a comma to separate that what to select from the rows from that what you want to select from the columns. For example:`}</p>\n    <p>{`my_matrix`}{`[1,2]`}{` selects the element at the first row and second column.\nmy_matrix`}{`[1:3,2:4]`}{` results in a matrix with the data on the rows 1, 2, 3 and columns 2, 3, 4.\nIf you want to select all elements of a row or a column, no number is needed before or after the comma, respectively:`}</p>\n    <p>{`my_matrix`}{`[,1]`}{` selects all elements of the first column.\nmy_matrix`}{`[1,]`}{` selects all elements of the first row.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> all_wars_matrix\n                           US non-US\nA New Hope              461.0  314.4\nThe Empire Strikes Back 290.5  247.9\nReturn of the Jedi      309.3  165.8\nThe Phantom Menace      474.5  552.5\nAttack of the Clones    310.7  338.7\nRevenge of the Sith     380.3  468.5\n>\n# Select the non-US revenue for all movies\n> non_us_all <- all_wars_matrix[,2]\n>\n# Average non-US revenue\n> mean(non_us_all)\n[1] 347.9667\n>\n# Select the non-US revenue for first two movies\n> non_us_some <- all_wars_matrix[1:2,2]\n>\n# Average non-US revenue for first two movies\n> mean(non_us_some)\n[1] 281.15\n`}</code></pre>\n    <div id=\"matrixArithmetic\"></div>\n    <h3 {...{\n      \"id\": \"-----matrix-arithmetic\"\n    }}>{`---- Matrix Arithmetic`}</h3>\n    <p>{`Basic arithmetic also works`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> all_wars_matrix\n                           US non-US\nA New Hope              461.0  314.4\nThe Empire Strikes Back 290.5  247.9\nReturn of the Jedi      309.3  165.8\nThe Phantom Menace      474.5  552.5\nAttack of the Clones    310.7  338.7\nRevenge of the Sith     380.3  468.5\n>\n# Estimate the visitors\n> visitors <- all_wars_matrix / 5\n>\n# Print the estimate to the console\n> visitors\n                           US non-US\nA New Hope              92.20  62.88\nThe Empire Strikes Back 58.10  49.58\nReturn of the Jedi      61.86  33.16\nThe Phantom Menace      94.90 110.50\nAttack of the Clones    62.14  67.74\nRevenge of the Sith     76.06  93.70\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`> all_wars_matrix\n                           US non-US\nA New Hope              461.0  314.4\nThe Empire Strikes Back 290.5  247.9\nReturn of the Jedi      309.3  165.8\nThe Phantom Menace      474.5  552.5\nAttack of the Clones    310.7  338.7\nRevenge of the Sith     380.3  468.5\n> ticket_prices_matrix\n                         US non-US\nA New Hope              5.0    5.0\nThe Empire Strikes Back 6.0    6.0\nReturn of the Jedi      7.0    7.0\nThe Phantom Menace      4.0    4.0\nAttack of the Clones    4.5    4.5\nRevenge of the Sith     4.9    4.9\n>\n# Estimated number of visitors\n> visitors <- all_wars_matrix / ticket_prices_matrix\n>\n# US visitors\n> us_visitors <- visitors[,1]\n>\n# Average number of US visitors\n> mean(us_visitors)\n[1] 75.01401\n`}</code></pre>\n    <p>{`Those who are familiar with matrices should note that this is not the standard matrix multiplication for which you should use `}<inlineCode parentName=\"p\">{`%*%`}</inlineCode>{` in R.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> all_wars_matrix[,1] %*% ticket_prices_matrix[,1]\n         [,1]\n[1,] 11372.72\n`}</code></pre>\n    <div id=\"factors\"></div>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"factors-in-r\"\n    }}>{`Factors in R`}</h2>\n    <p>{`The term factor refers to a statistical data type used to store categorical variables. The difference between a categorical variable and a continuous variable is that a categorical variable can belong to a limited number of categories. A continuous variable, on the other hand, can correspond to an infinite number of values.`}</p>\n    <p>{`It is important that R knows whether it is dealing with a continuous or a categorical variable, as the statistical models you will develop in the future treat both types differently. (You will see later why this is the case.)`}</p>\n    <p>{`A good example of a categorical variable is the variable 'Gender'. A human individual can either be \"Male\" or \"Female\", making abstraction of inter-sexes. So here \"Male\" and \"Female\" are, in a simplified sense, the two values of the categorical variable \"Gender\", and every observation can be assigned to either the value \"Male\" of \"Female\".`}</p>\n    <p>{`To create factors in R, you make use of the function factor(). First thing that you have to do is create a vector that contains all the observations that belong to a limited number of categories. For example, gender_vector contains the sex of 5 different individuals:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`gender_vector <- c(\"Male\",\"Female\",\"Female\",\"Male\",\"Male\")\n`}</code></pre>\n    <p>{`It is clear that there are two categories, or in R-terms 'factor levels', at work here: \"Male\" and \"Female\".`}</p>\n    <p>{`The function factor() will encode the vector as a factor:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`factor_gender_vector <- factor(gender_vector)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Gender vector\n> gender_vector <- c(\"Male\", \"Female\", \"Female\", \"Male\", \"Male\")\n>\n# Convert gender_vector to a factor\n> factor_gender_vector <- factor(gender_vector)\n>\n# Print out factor_gender_vector\n> factor_gender_vector\n[1] Male   Female Female Male   Male  \nLevels: Female Male\n> gender_vector\n[1] \"Male\"   \"Female\" \"Female\" \"Male\"   \"Male\"\n`}</code></pre>\n    <p>{`There are two types of categorical variables: a nominal categorical variable and an ordinal categorical variable.`}</p>\n    <p>{`A nominal variable is a categorical variable without an implied order. This means that it is impossible to say that 'one is worth more than the other'. For example, think of the categorical variable animals_vector with the categories \"Elephant\", \"Giraffe\", \"Donkey\" and \"Horse\". Here, it is impossible to say that one stands above or below the other. (Note that some of you might disagree ;-) ).`}</p>\n    <p>{`In contrast, ordinal variables do have a natural ordering. Consider for example the categorical variable temperature_vector with the categories: \"Low\", \"Medium\" and \"High\". Here it is obvious that \"Medium\" stands above \"Low\", and \"High\" stands above \"Medium\".`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Animals\n> animals_vector <- c(\"Elephant\", \"Giraffe\", \"Donkey\", \"Horse\")\n> factor_animals_vector <- factor(animals_vector)\n> factor_animals_vector\n[1] Elephant Giraffe  Donkey   Horse\nLevels: Donkey Elephant Giraffe Horse\n>\n# Temperature\n> temperature_vector <- c(\"High\", \"Low\", \"High\",\"Low\", \"Medium\")\n> factor_temperature_vector <- factor(temperature_vector, order = TRUE, levels = c(\"Low\", \"Medium\", \"High\"))\n> factor_temperature_vector\n[1] High   Low    High   Low    Medium\nLevels: Low < Medium < High\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`levels()`}</inlineCode>{` function allows you to change the levels later.`}</p>\n    <p>{`Watch out: the order with which you assign the levels is important. R would assign them alphabetically by default.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Code to build factor_survey_vector\n> survey_vector <- c(\"M\", \"F\", \"F\", \"M\", \"M\")\n> factor_survey_vector <- factor(survey_vector)\n>\n# Specify the levels of factor_survey_vector\n> levels(factor_survey_vector) <- c(\"Female\", \"Male\")\n>\n> factor_survey_vector\n[1] Male   Female Female Male   Male  \nLevels: Female Male\n`}</code></pre>\n    <div id=\"factorSummary\"></div>\n    <h3 {...{\n      \"id\": \"-----summarizing-a-factor\"\n    }}>{`---- Summarizing a factor`}</h3>\n    <p><inlineCode parentName=\"p\">{`summary(my_var)`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{}}>{`> survey_vector <- c(\"M\", \"F\", \"F\", \"M\", \"M\")\n> factor_survey_vector <- factor(survey_vector)\n> levels(factor_survey_vector) <- c(\"Female\", \"Male\")\n> factor_survey_vector\n[1] Male   Female Female Male   Male  \nLevels: Female Male\n>\n# Generate summary for survey_vector\n> summary(survey_vector)\n   Length     Class      Mode\n        5 character character\n>\n# Generate summary for factor_survey_vector\n> summary(factor_survey_vector)\nFemale   Male\n     2      3\n`}</code></pre>\n    <p>{`Gender Neutral`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Build factor_survey_vector with clean levels\n> survey_vector <- c(\"M\", \"F\", \"F\", \"M\", \"M\")\n> factor_survey_vector <- factor(survey_vector)\n> levels(factor_survey_vector) <- c(\"Female\", \"Male\")\n>\n# Male\n> male <- factor_survey_vector[1]\n>\n# Female\n> female <- factor_survey_vector[2]\n>\n# Battle of the sexes: Male 'larger' than female?\n> male > female\nWarning message: '>' not meaningful for factors\n[1] NA\n`}</code></pre>\n    <div id=\"orderedFactors\"></div>\n    <h3 {...{\n      \"id\": \"-----ordered-factors\"\n    }}>{`---- Ordered Factors`}</h3>\n    <p>{`Since \"Male\" and \"Female\" are unordered (or nominal) factor levels, R returns a warning message, telling you that the greater than operator is not meaningful. As seen before, R attaches an equal value to the levels for such factors.`}</p>\n    <p>{`But this is not always the case! Sometimes you will also deal with factors that do have a natural ordering between its categories. If this is the case, we have to make sure that we pass this information to R...`}</p>\n    <p>{`Let us say that you are leading a research team of five data analysts and that you want to evaluate their performance. To do this, you track their speed, evaluate each analyst as \"slow\", \"fast\" or \"insane\", and save the results in speed_vector.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Create speed_vector\n> speed_vector <- c(\"fast\", \"slow\", \"slow\", \"fast\", \"insane\")\n>\n# Convert speed_vector to ordered factor vector\n> factor_speed_vector <- factor(speed_vector, ordered=TRUE, levels = c(\"slow\", \"fast\", \"insane\"))\n>\n# Print factor_speed_vector\n> factor_speed_vector\n[1] fast   slow   slow   fast   insane\nLevels: slow < fast < insane\n> summary(factor_speed_vector)\n  slow   fast insane\n     2      2      1\n`}</code></pre>\n    <p>{`Then as an example of comparing Ordered Factors`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Create factor_speed_vector\n> speed_vector <- c(\"fast\", \"slow\", \"slow\", \"fast\", \"insane\")\n> factor_speed_vector <- factor(speed_vector, ordered = TRUE, levels = c(\"slow\", \"fast\", \"insane\"))\n>\n# Factor value for second data analyst\n> da2 <- factor_speed_vector[2]\n>\n# Factor value for fifth data analyst\n> da5 <- factor_speed_vector[5]\n>\n# Is data analyst 2 faster than data analyst 5?\n> da2 > da5\n[1] FALSE\n`}</code></pre>\n    <div id=\"dataFrames\"></div>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"data-frames\"\n    }}>{`Data Frames`}</h2>\n    <p>{`When doing a market research survey, you often have questions such as:`}</p>\n    <p>{`'Are your married?' or 'yes/no' questions (logical)\n'How old are you?' (numeric)\n'What is your opinion on this product?' or other 'open-ended' questions (character)\n...\nThe output, namely the respondents' answers to the questions formulated above, is a data set of different data types. You will often find yourself working with data sets that contain different data types instead of only one.`}</p>\n    <p>{`A data frame has the variables of a data set as columns and the observations as rows. This will be a familiar concept for those coming from different statistical software packages such as SAS or SPSS.`}</p>\n    <p>{`Working with large data sets is not uncommon in data analysis. When you work with (extremely) large data sets and data frames, your first task as a data analyst is to develop a clear understanding of its structure and main elements. Therefore, it is often useful to show only a small part of the entire data set.`}</p>\n    <p>{`So how to do this in R? Well, the function head() enables you to show the first observations of a data frame. Similarly, the function tail() prints out the last observations in your data set.`}</p>\n    <p>{`Both head() and tail() print a top line called the 'header', which contains the names of the different variables in your data set. This is similar to the unix command.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> head(mtcars)\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n`}</code></pre>\n    <p>{`Another method that is often used to get a rapid overview of your data is the function str(). The function str() shows you the structure of your data set. For a data frame it tells you:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`The total number of observations (e.g. 32 car types)`}</li>\n      <li parentName=\"ul\">{`The total number of variables (e.g. 11 car features)`}</li>\n      <li parentName=\"ul\">{`A full list of the variables names (e.g. mpg, cyl ... )`}</li>\n      <li parentName=\"ul\">{`The data type of each variable (e.g. num)`}</li>\n      <li parentName=\"ul\">{`The first observations`}</li>\n    </ul>\n    <p>{`Applying the str() function will often be the first thing that you do when receiving a new data set or data frame. It is a great way to get more insight in your data set before diving into the real analysis.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Investigate the structure of mtcars\n> str(mtcars)\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n# Check the structure of planets_df\n> str(planets_df)\n'data.frame':   8 obs. of  5 variables:\n $ name    : Factor w/ 8 levels \"Earth\",\"Jupiter\",..: 4 8 1 3 2 6 7 5\n $ type    : Factor w/ 2 levels \"Gas giant\",\"Terrestrial planet\": 2 2 2 2 1 1 1 1\n $ diameter: num  0.382 0.949 1 0.532 11.209 ...\n $ rotation: num  58.64 -243.02 1 1.03 0.41 ...\n $ rings   : logi  FALSE FALSE FALSE FALSE TRUE TRUE ...\n`}</code></pre>\n    <div id=\"selectionFrameElements\"></div>\n    <h3 {...{\n      \"id\": \"-----selection-of-data-frame-elements\"\n    }}>{`---- Selection of data frame elements`}</h3>\n    <p>{`Similar to vectors and matrices, you select elements from a data frame with the help of square brackets `}{`[ ]`}{`. By using a comma, you can indicate what to select from the rows and the columns respectively. For example:`}</p>\n    <p>{`my_df`}{`[1,2]`}{` selects the value at the first row and select element in my_df.\nmy_df`}{`[1:3,2:4]`}{` selects rows 1, 2, 3 and columns 2, 3, 4 in my_df.\nSometimes you want to select all elements of a row or column. For example, my_df`}{`[1, ]`}{` selects all elements of the first row. Let us now apply this technique on planets_df!`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> planets_df\n     name               type diameter rotation rings\n1 Mercury Terrestrial planet    0.382    58.64 FALSE\n2   Venus Terrestrial planet    0.949  -243.02 FALSE\n3   Earth Terrestrial planet    1.000     1.00 FALSE\n4    Mars Terrestrial planet    0.532     1.03 FALSE\n5 Jupiter          Gas giant   11.209     0.41  TRUE\n6  Saturn          Gas giant    9.449     0.43  TRUE\n7  Uranus          Gas giant    4.007    -0.72  TRUE\n8 Neptune          Gas giant    3.883     0.67  TRUE\n\n# Print out diameter of Mercury (row 1, column 3)\n> planets_df[1,3]\n[1] 0.382\n>\n# Print out data for Mars (entire fourth row)\n> planets_df[4, ]\n  name               type diameter rotation rings\n4 Mars Terrestrial planet    0.532     1.03 FALSE\n\n# Select first 5 values of diameter column\n> planets_df[1:5, \"diameter\"]\n[1]  0.382  0.949  1.000  0.532 11.209\n\n# Select the rings variable from planets_df\n> rings_vector <- planets_df[,\"rings\"]\n>\n# Print out rings_vector\n> rings_vector\n[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n# Adapt the code to select all columns for planets with rings\n> planets_df[rings_vector, ]\n     name      type diameter rotation rings\n5 Jupiter Gas giant   11.209     0.41  TRUE\n6  Saturn Gas giant    9.449     0.43  TRUE\n7  Uranus Gas giant    4.007    -0.72  TRUE\n8 Neptune Gas giant    3.883     0.67  TRUE\n`}</code></pre>\n    <div id=\"subsets\"></div>\n    <h3 {...{\n      \"id\": \"-----subsets\"\n    }}>{`---- Subsets`}</h3>\n    <p>{`You should see the subset() function as a short-cut to do exactly the same as what you did in the previous exercises.`}</p>\n    <p>{`subset(my_df, subset = some_condition)\nThe first argument of subset() specifies the data set for which you want a subset. By adding the second argument, you give R the necessary information and conditions to select the correct subset.`}</p>\n    <p>{`The code below will give the exact same result as you got in the previous exercise, but this time, you didn't need the rings_vector!`}</p>\n    <p>{`subset(planets_df, subset = rings)`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Select planets with diameter < 1\n> subset(planets_df, subset = diameter < 1)\n     name               type diameter rotation rings\n1 Mercury Terrestrial planet    0.382    58.64 FALSE\n2   Venus Terrestrial planet    0.949  -243.02 FALSE\n4    Mars Terrestrial planet    0.532     1.03 FALSE\n\n> subset(planets_df, subset = diameter > 1)\n     name      type diameter rotation rings\n5 Jupiter Gas giant   11.209     0.41  TRUE\n6  Saturn Gas giant    9.449     0.43  TRUE\n7  Uranus Gas giant    4.007    -0.72  TRUE\n8 Neptune Gas giant    3.883     0.67  TRUE\n`}</code></pre>\n    <div id=\"sorting\"></div>\n    <h3 {...{\n      \"id\": \"-----sorting\"\n    }}>{`---- Sorting`}</h3>\n    <p>{`In data analysis you can sort your data according to a certain variable in the data set. In R, this is done with the help of the function order().`}</p>\n    <p>{`order() is a function that gives you the ranked position of each element when it is applied on a variable, such as a vector for example:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> a <- c(100, 10, 1000)\n> order(a)\n[1] 2 1 3\n`}</code></pre>\n    <p>{`10, which is the second element in a, is the smallest element, so 2 comes first in the output of order(a). 100, which is the first element in a is the second smallest element, so 1 comes second in the output of order(a).`}</p>\n    <p>{`This means we can use the output of order(a) to reshuffle a:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> a <- c(10, 30, 100)\n> order(a)\n[1] 1 2 3\n> b <- c(100, 300, 20)\n> order(b)\n[1] 3 1 2\n> c <- a + b\n> order(c)\n[1] 1 3 2\n> c[order(c)]\n[1] 110 120 330\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# planets_df is pre-loaded in your workspace\n> planets_df$diameter\n[1]  0.382  0.949  1.000  0.532 11.209  9.449  4.007  3.883\n\n# Use order() to create positions\n> positions <- order(planets_df$diameter)\n> planets_df\n     name               type diameter rotation rings\n1 Mercury Terrestrial planet    0.382    58.64 FALSE\n2   Venus Terrestrial planet    0.949  -243.02 FALSE\n3   Earth Terrestrial planet    1.000     1.00 FALSE\n4    Mars Terrestrial planet    0.532     1.03 FALSE\n5 Jupiter          Gas giant   11.209     0.41  TRUE\n6  Saturn          Gas giant    9.449     0.43  TRUE\n7  Uranus          Gas giant    4.007    -0.72  TRUE\n8 Neptune          Gas giant    3.883     0.67  TRUE\n\n# Use positions to sort planets_df\n> planets_df[positions, ]\n     name               type diameter rotation rings\n1 Mercury Terrestrial planet    0.382    58.64 FALSE\n4    Mars Terrestrial planet    0.532     1.03 FALSE\n2   Venus Terrestrial planet    0.949  -243.02 FALSE\n3   Earth Terrestrial planet    1.000     1.00 FALSE\n8 Neptune          Gas giant    3.883     0.67  TRUE\n7  Uranus          Gas giant    4.007    -0.72  TRUE\n6  Saturn          Gas giant    9.449     0.43  TRUE\n5 Jupiter          Gas giant   11.209     0.41  TRUE\n\n> planets_df\n     name               type diameter rotation rings\n1 Mercury Terrestrial planet    0.382    58.64 FALSE\n2   Venus Terrestrial planet    0.949  -243.02 FALSE\n3   Earth Terrestrial planet    1.000     1.00 FALSE\n4    Mars Terrestrial planet    0.532     1.03 FALSE\n5 Jupiter          Gas giant   11.209     0.41  TRUE\n6  Saturn          Gas giant    9.449     0.43  TRUE\n7  Uranus          Gas giant    4.007    -0.72  TRUE\n8 Neptune          Gas giant    3.883     0.67  TRUE\n`}</code></pre>\n    <div id=\"lists\"></div>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"lists\"\n    }}>{`Lists`}</h2>\n    <p><strong parentName=\"p\">{`Recap so far`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Vectors (one dimensional array): can hold numeric, character or logical values. The elements in a vector all have the same data type.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Matrices (two dimensional array): can hold numeric, character or logical values. The elements in a matrix all have the same data type.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Data frames (two-dimensional objects): can hold numeric, character or logical values. Within a column all elements have the same data type, but different columns can be of different data type.`}</p>\n      </li>\n    </ul>\n    <p><strong parentName=\"p\">{`Lists`}</strong></p>\n    <p>{`A list in R is similar to your to-do list at work or school: the different items on that list most likely differ in length, characteristic, type of activity that has to do be done, ...`}</p>\n    <p>{`A list in R allows you to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related to each other in any way.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list <- list(comp1, comp2, ...)\n`}</code></pre>\n    <p>{`The arguments to the list function are the list components.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Vector with numerics from 1 up to 10\n> my_vector <- 1:10\n>\n# Matrix with numerics from 1 up to 9\n> my_matrix <- matrix(1:9, ncol = 3)\n>\n# First 10 elements of the built-in data frame mtcars\n> my_df <- mtcars[1:10,]\n>\n# Construct list with these different elements:\n> my_list <- list(my_vector, my_matrix, my_df)\n> my_list\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n[[3]]\n                   mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Naming a List`}</strong></p>\n    <p>{`We can use the name() function to get around this.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list <- list(name1 = your_comp1,\n                name2 = your_comp2)\n`}</code></pre>\n    <p>{`We also alter names later like so...`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list <- list(your_comp1, your_comp2)\nnames(my_list) <- c(\"name1\", \"name2\")\n`}</code></pre>\n    <p>{`Continuing on from the above exampe...`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> names(my_list) <- c(\"vec\", \"mat\", \"df\")\n>\n> # Print out my_list\n> my_list\n$vec\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$mat\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n$df\n                   mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360        14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n`}</code></pre>\n    <p>{`Another example of naming List components.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> shining_list <- list(moviename = mov, actors = act, reviews = rev)\n> shining_list\n$moviename\n[1] \"The Shining\"\n\n$actors\n[1] \"Jack Nicholson\"   \"Shelley Duvall\"   \"Danny Lloyd\"      \"Scatman Crothers\"\n[5] \"Barry Nelson\"\n\n$reviews\n  scores sources                                              comments\n1    4.5   IMDb1                     Best Horror Film I Have Ever Seen\n2    4.0   IMDb2 A truly brilliant and scary film from Stanley Kubrick\n3    5.0   IMDb3                 A masterpiece of psychological horror\n`}</code></pre>\n    <div id=\"listelements\"></div>\n    <h3 {...{\n      \"id\": \"-----selecting-elements-from-a-list\"\n    }}>{`---- Selecting Elements from a List`}</h3>\n    <p>{`Your list will often be built out of numerous elements and components. Therefore, getting a single element, multiple elements, or a component out of it is not always straightforward.`}</p>\n    <p>{`One way to select a component is using the numbered position of that component. For example, to \"grab\" the first component of shining_list you type`}</p>\n    <p><inlineCode parentName=\"p\">{`shining_list[[1]]`}</inlineCode></p>\n    <p>{`A quick way to check this out is typing it in the console. Important to remember: to select elements from vectors, you use single square brackets: `}{`[ ]`}{`. Don't mix them up!`}</p>\n    <p>{`You can also refer to the names of the components, with [`}{`[ ]`}{`] or with the $ sign. Both will select the data frame representing the reviews:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`shining_list[[\"reviews\"]]\nshining_list$reviews\n`}</code></pre>\n    <p>{`Besides selecting components, you often need to select specific elements out of these components. For example, with `}<inlineCode parentName=\"p\">{`shining_list[[2]][1]`}</inlineCode>{` you select from the second component, actors (`}<inlineCode parentName=\"p\">{`shining_list[[2]]`}</inlineCode>{`), the first element (`}<inlineCode parentName=\"p\">{`[1]`}</inlineCode>{`). When you type this in the console, you will see the answer is Jack Nicholson.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Print out the vector representing the actors\n> shining_list$actors\n[1] \"Jack Nicholson\"   \"Shelley Duvall\"   \"Danny Lloyd\"      \"Scatman Crothers\"\n[5] \"Barry Nelson\"\n>\n# Print the second element of the vector representing the actors\n> shining_list[[\"actors\"]][2]\n[1] \"Shelley Duvall\"\n`}</code></pre>\n    <div id=\"addingelems\"></div>\n    <h3 {...{\n      \"id\": \"-----adding-more-components-to-a-list\"\n    }}>{`---- Adding more components to a list`}</h3>\n    <p>{`To conveniently add elements to lists you can use the c() function, that you also used to build vectors:`}</p>\n    <p><inlineCode parentName=\"p\">{`ext_list <- c(my_list , my_val)`}</inlineCode></p>\n    <p>{`This will simply extend the original list, `}<inlineCode parentName=\"p\">{`my_list`}</inlineCode>{`, with the component `}<inlineCode parentName=\"p\">{`my_val`}</inlineCode>{`. This component gets appended to the end of the list. If you want to give the new list item a name, you just add the name as you did before:`}</p>\n    <p><inlineCode parentName=\"p\">{`ext_list <- c(my_list, my_name = my_val)`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# We forgot something; add the year to shining_list\n> shining_list_full <- c(shining_list, year = 1980)\n>\n# Have a look at shining_list_full\n> str(shining_list_full)\nList of 4\n $ moviename: chr \"The Shining\"\n $ actors   : chr [1:5] \"Jack Nicholson\" \"Shelley Duvall\" \"Danny Lloyd\" \"Scatman Crothers\" ...\n $ reviews  :'data.frame':  3 obs. of  3 variables:\n  ..$ scores  : num [1:3] 4.5 4 5\n  ..$ sources : Factor w/ 3 levels \"IMDb1\",\"IMDb2\",..: 1 2 3\n  ..$ comments: Factor w/ 3 levels \"A masterpiece of psychological horror\",..: 3 2 1\n $ year     : num 1980\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}