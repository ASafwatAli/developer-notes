{"remainingRequest":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/okeeffe_d/Project-Imposter/developer-notes/manual/JavaScript/JS-RxJS.md","dependencies":[{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/manual/JavaScript/JS-RxJS.md","mtime":1554258118587},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1561535530324},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1560300163820},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1561535530532},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1548285283521}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9va2VlZmZlX2QvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbm9kZV9tb2R1bGVzL2JhYmVsLXByZXNldC1yZWFjdC1hcHAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIjsvKiBAanN4IG1keCAqL2ltcG9ydCBSZWFjdCBmcm9tJ3JlYWN0JztpbXBvcnR7bWR4fWZyb20nQG1keC1qcy9yZWFjdCc7LyogQGpzeCBtZHggKi92YXIgbWFrZVNob3J0Y29kZT1mdW5jdGlvbiBtYWtlU2hvcnRjb2RlKG5hbWUpe3JldHVybiBmdW5jdGlvbiBNRFhEZWZhdWx0U2hvcnRjb2RlKHByb3BzKXtjb25zb2xlLndhcm4oIkNvbXBvbmVudCAiK25hbWUrIiB3YXMgbm90IGltcG9ydGVkLCBleHBvcnRlZCwgb3IgcHJvdmlkZWQgYnkgTURYUHJvdmlkZXIgYXMgZ2xvYmFsIHNjb3BlIik7cmV0dXJuIG1keCgiZGl2Iixwcm9wcyk7fTt9O3ZhciBsYXlvdXRQcm9wcz17fTt2YXIgTURYTGF5b3V0PSJ3cmFwcGVyIjtleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KF9yZWYpe3ZhciBjb21wb25lbnRzPV9yZWYuY29tcG9uZW50cyxwcm9wcz1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZixbImNvbXBvbmVudHMiXSk7cmV0dXJuIG1keChNRFhMYXlvdXQsT2JqZWN0LmFzc2lnbih7fSxsYXlvdXRQcm9wcyxwcm9wcyx7Y29tcG9uZW50czpjb21wb25lbnRzLG1keFR5cGU6Ik1EWExheW91dCJ9KSxtZHgoImgxIix7ImlkIjoicnhqcyJ9LCJSeEpTIiksbWR4KCJoMiIseyJpZCI6IjEwLWEtYnJpZWYtcmVjYXAtb2YtcHJvZ3JhbW1pbmctcGFyYWRpZ21zIn0sIjEuMCBBIEJyaWVmIFJlY2FwIG9mIFByb2dyYW1taW5nIFBhcmFkaWdtcyIpLG1keCgiaDMiLHsiaWQiOiJwcm9jZWR1cmFsLXByb2dyYW0ifSwiUHJvY2VkdXJhbCBQcm9ncmFtIiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiVGhlIGlkZWFzIHRoYXQgcHJvZ3JhbXMgYXJlIGEgc2Vuc2Ugb2YgZnVuY3Rpb25zIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkdvZXMgZnJvbSB0b3AgdG8gYm90dG9tIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlJlbGllcyBoZWF2aWx5IG9uIGdsb2JhbCBzdGF0ZSwgYnV0IGFueSBsaW5lIGNhbiBjaGFuZ2UgdGhlIGdsb2JhbCBzdGF0ZSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDIGJlaW5nIGEgcHJvY2VkdXJhbCBsYW5ndWFnZSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJcIkltcGVyYXRpdmVcIiBleGVjdXRpb24iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiRWFzeSB0byB3cml0ZSwgZGlmZmljdWx0IHRvIG1haW50YWluIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlByb25lIHRvIGRpZmZpY3VsdCBidWdzIikpLG1keCgiaDMiLHsiaWQiOiJvYmplY3Qtb3JpZW50ZWQifSwiT2JqZWN0IE9yaWVudGVkIiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQmFzZWQgYXJvdW5kIGEgUHJpbWl0aXZlOiBvYmplY3QiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiT2JqZWN0cyBoYXZlIHdlbGwgZGVmaW5lZCBpbnRlcmZhY2VzIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkxvY2FsaXNlZCBiZWhhdmlvdXIiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiT2JqZWN0cyBjb250cm9sIHN0YXRlIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkNvbXBvc2l0aW9uIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkNvZGUgaXMgc3RpbGwgaW1wZXJhdGl2ZSAtIHBybyBBTkQgY29uISAtIFN0aWxsIHRlbGxpbmcgdGhlIGNvbXB1dGVyIEVYQUNUTFkgd2hhdCB0byBkby4iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ2FuIGJlIG1vcmUgdmVyYm9zZSIpKSxtZHgoImgzIix7ImlkIjoiZGVjbGFyYXRpdmUifSwiRGVjbGFyYXRpdmUiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJEZXNjcmliaW5nIHdoYXQgeW91IHdhbnQgdG8gaGFwcGVuLCBidXQgbm90IHRlbGxpbmcgdGhlIGNvbXB1dGVyIGhvdyB0byBkbyBpdCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJFZy4gU1FMLCBSZWdleCwgSFRNTCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJEYXRhIGlzIHNlbGYtZGVzY3JpYmluZyIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJBcyBwb3dlcmZ1bCBhcyB0aGUgaW50ZXJwcmV0ZXIgYWxsb3dzIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkFzIGxpbWl0aW5nIGFzIHRoZSBpbnRlcnByZXRlciBhbGxvd3MgLSBZb3Ugd2FudCBidWlsZCBhIGdhbWUgaW4gU1FMIGV0Yy4iKSksbWR4KCJoMyIseyJpZCI6ImZ1bmN0aW9uYWwifSwiRnVuY3Rpb25hbCIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIldoYXQgd2Ugd2FudCB0byBoYXBwZW4gYnV0IG5vdCBob3ciKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiTGl0dGxlIHN0YXRlIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkZldyBzaWRlIGVmZmVjdHMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiRWFzeSB0byByZWFzb24gYWJvdXQiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ29tcG9zaXRpb24iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiRXhwcmVzc2l2ZSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJXb3JrcyBncmVhdCB3aXRoIE9PIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkJhc2lzIGluIGhpZ2hlciBtYXRoIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkNvbnMgdG8gdGhpbmsgZGlmZmVyZW50bHkiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiTm90IGFsd2F5cyB0aGUgYmVzdCBjaG9pY2UiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiTm8gbG9vcHMsIG5vIGNvbnRyb2wgbG9naWMgLSBKdXN0IHRlbGxpbmcgaXQgd2hhdCB3ZSB3YW50IHRvIGhhcHBlbiIpKSxtZHgoImgzIix7ImlkIjoicmVhY3RpdmUifSwiUmVhY3RpdmUiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJQcmltaXRpdmU6IE9ic2VydmFibGUiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiSW5zdGVhZCBvZiBkZXNjcmliaW5nIGRhdGEgaW4gdGVybXMgb2Ygb3RoZXIgZGF0YSwgd2UgZGVzY3JpYmUgaXQgaW4gdGVybXMgb2Ygc3RyZWFtcyBvZiBldmVudHMgLSBGcm9tIHRoaXMsIHdlIGNyZWF0ZSBhIHBpcGVsaW5lIHN1Y2ggdGhhdCB3ZSBjZXJ0YWluIGRhdGEgY2hhbmdlcywgYSBsb3QgaXMgcHJvY2Vzc2VkIGFuZCBjaGFuZ2VkIC0gRXhhbXBsZTogc3ByZWFkc2hlZXRzISIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDb21wb3NpdGlvbiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJFeHByZXNzaXZlIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkRhdGEgZmxvd3MgdW5pZGlyZWN0aW9uYWxseSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJUb3VnaCB0byB0aGluayBkaWZmZXJlbnRseSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJTdWJzY3JpcHRpb25zIGhlbHAgY2hhbmdlIHRoZSBkYXRhIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJjb25zdCBjZWxsQzIkID0gY2VsbEEyJFxuICAuY29tYmluZUxhdGVzdChjZWxsQjIkKVxuICAubWFwKChjZWxscykgPT4gY2VsbHNbMF0gKyBjZWxsc1sxXSk7XG5cbmNlbGxDMiQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICBjb25zb2xlLmxvZyh2YWx1ZSk7XG59KTtcbiIpKSxtZHgoImgyIix7ImlkIjoiMTEtY29yZS1yZWFjdGl2ZS1jb25jZXB0cyJ9LCIxLjE6IENvcmUgUmVhY3RpdmUgQ29uY2VwdHMiKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIkNvcmUgQ29uY2VwdCAxOiBQdWxsIG1vZGVsIHZzIFB1c2ggbW9kZWwiKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiYW55IGRhdGEgc2l0dGluZyB0aGVyZSB0aGF0IHlvdSBcImFza1wiIGZvciBhdCBzb21lIHBvaW50IC0gZXhhbXBsZSByZWZyZXNoIGJ1dHRvbiAtIG1hbnVhbCBidXR0b24gdHJpZ2dlciAtIHRpbWUgaW50ZXJ2YWwiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwib2JzZXJ2YWJsZSAoc3RyZWFtKSB3aGljaCBpcyBhIHJlYWN0aXZlIGRhdGEgc291cmNlIC0gcHJvZHVjZXMgaXRlbXMgb3ZlciBhIHBlcmlvZCBvZiB0aW1lIHRoYXQgd2lsbCBlaXRoZXIgZXJyb3IsIGNvbXBsZXRlLCBvciBuZXZlciBjb21wbGV0ZSB1bnRpbCBhIHBhZ2UgY2xvc2VzIC0gbm90IHRlbGxpbmcgdGhlIHN0cmVhbSB3aGVuIHRvIGdldCBkYXRhLCBpdCBoYXMgaW5idWlsdCBsb2dpYyBvbiBob3cgdG8gZ2V0IGRhdGEgLSB3ZSBtYXkgdHJhbnNmb3JtIHRoaXMgZGF0YSAtIHRoZSBkaXNwbGF5IG9mIHRoZSBkYXRhIGlzIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGRlc2NyaXB0aW9uIikpLG1keCgicCIsbnVsbCwiQW4gYW4gZXhhbXBsZSBmb3IgYSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwicHVsbCIpLCIgYmFzZWQgY29kZSwgd2UgY2FuIHRoaW5rIG9mIGEgd2luZG93LnNldEludGVydmFsKCkgdGhhdCBmaXJlcyBldmVyeSA1MDAwIHNlY29uZHMuIiksbWR4KCJwIixudWxsLCJBbiBleGFtcGxlIG9mIGEgcHVzaCB3b3VsZCBiZSB0byBoYXZlIGEgZnVuY3Rpb24gZmlyZSBhbmQgdGhlbiB0aGUgcmV0dXJuIGNvbnRpbnV0ZXMgdG8gZmlsdGVyLCBmbGF0TWFwLCBtYXAgYW5kIHN1YnNjcmliZS4iKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIkNvcmUgQ29uY2VwdCAyOiBFdmVyeXRoaW5nIGlzIGEgZGF0YWJhc2UiKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwibW91c2UgbW92ZW1lbnRzIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sImN1cnJlbnQgdXNlciIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJ3ZWIgcmVxdWVzdHMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiaW5wdXQgYm94ZXMiKSksbWR4KCJoMiIseyJpZCI6IjEyLWNvbXBhcmluZy10aGUtYXV0b2NvbXBsZXRlLWZ1bmN0aW9uLXVzaW5nLWpzLXZzLXJ4anMifSwiMS4yOiBDb21wYXJpbmcgdGhlIEF1dG9jb21wbGV0ZSBmdW5jdGlvbiB1c2luZyBKUyB2cyBSeEpTIiksbWR4KCJwIixudWxsLCJJbiB0aGUgY29tcGFyaXNvbiB3aGVyZSB0aGUgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sIiR0aXRsZS5vbigna2V5dXAnLCAoKSA9PiB7fSkiKSwiIHJ1bnMgd2l0aCBhIHByb21pc2UgcmV0dXJuZWQuIFRoZSBxdWVyeSBjYW4gcnVuIGludG8gcmFjZSBjb25kaXRpb25zLiIpLG1keCgicCIsbnVsbCwiQWxzbyBub3RlIHRoYXQgZXZlcnkgc2luZ2xlIHJlc3VsdCBhbHNvIGZpcmVzLiIpLG1keCgicCIsbnVsbCwiVGhlIGlzc3VlczoiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLy8gRml4IHVwIGFuZCBkb3duIGFycm93XG4vLyBTdG9wIGFsd2F5cyBxdWVyeWluZ1xuLy8gR2V0dGluZyByYWNlIGNvbmRpdGlvblxuIikpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiQmFkIHdheXMiKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiZ2VuZXJhbGx5ICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToibGkifSwiaWYgbGFzdCBxdWVyeSA9PSBjdXJyZW50VGl0bGUgcmV0dXJuIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJ1c2luZyBzZXRUaW1lb3V0IHRvIHJlZHVjZSBudW1iZXIgb2YgcXVlcmllcyIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJSYWNlIGNvbmRpdGlvbiBzdGlsbCBoYXBwZW5pbmcsIGJ1dCBiYWQgYXR0ZW1wdHMgbWF5IGJlIGluY3JlYXNpbmcgdGhlIHRpbWVvdXQgLSBDb3VsZCBhbHNvIHVzZSBhIGN1cnJlbnQgaWQgY29tcGFyZWQgdG8gbmV4dCBxdWVyeSBpZCBhbmQgdGhlbiByZXR1cm5pbmcgYmVmb3JlIHRoZSBjYWxsYmFjayBvY2N1cnMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQSBsb3Qgb2Ygc3RhdGUgYWNyb3NzIHRoZSBtb2R1bGUgYmVpbmcgY2hhbmdlZCIpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIlRoZSBSeCB3YXkiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIi8vIG5wbSBpbnN0YWxsIHJ4anMtZXMgZm9yIGVzNlxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBSeCBmcm9tICdyeGpzL1J4JztcblxuY29uc3QgJHRpdGxlID0gJCgnI3RpdGxlJyk7XG5jb25zdCAkcmVzdWx0cyA9ICQoJyNyZXN1bHRzJyk7XG5cbmNvbnN0IGtleVVwcyQgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudCgkdGl0bGUsIFwia2V5dXBcIik7XG5jb25zdCBxdWVyaWVzJCA9IGtleVVwcyRcbiAgICAubWFwKGUgPT4gZS50YXJnZXQudmFsdWUpXG4gICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAuZGVib3VuY2VUaW1lKDI1MClcbiAgICAuc3dpdGNoTWFwKGdldEl0ZW1zKTsgICAvLyBzaW1pbGFyIHRvIG1lcmdlLCBidXQgaWYgbmV3IHF1ZXJ5IGNvbWVzIGluLCBkaXNjYXJkIHRoZSBvbGQgZGF0YVxuICAgIC8vLm1lcmdlTWFwKGdldEl0ZW1zKTsgIC8vIGFsaWFzIGZvciBmbGF0TWFwXG5cbnF1ZXJpZXMkLnN1YnNjcmliZShxdWVyeSA9PiB7XG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgcHJvbWlzZSB3aWxsIHN0b3AgcmFjZSBjb25kaXRpb25cbiAgICAkcmVzdWx0cy5lbXB0eSgpO1xuICAgICRyZXN1bHRzLmFwcGVuZChpdGVtcy5tYXAoIHIgPT4gJChgPGxpIC8+YCkudGV4dChyKSkpO1xufSlcblxuPCEtLSBxdWVyaWVzJC5zdWJzY3JpYmUocXVlcnkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUpOyAvLyBwcmludHMgb3V0IGV2ZW50XG4gICAgZ2V0SXRlbXMocXVlcnkpXG4gICAgICAgIC50aGVuKGl0ZW1zID0+IHtcbiAgICAgICAgICAgICRyZXN1bHRzLmVtcHR5KCk7XG4gICAgICAgICAgICAkcmVzdWx0cy5hcHBlbmQoaXRlbXMubWFwKCByID0+ICQoYDxsaSAvPmApLnRleHQocikpKTtcbiAgICAgICAgfSk7XG59KSAtLT5cbiIpKSxtZHgoInAiLG51bGwsIkFuIGV2ZW4gYmV0dGVyIHdheS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBSeCBmcm9tICdyeGpzL1J4JztcblxuY29uc3QgJHRpdGxlID0gJCgnI3RpdGxlJyk7XG5jb25zdCAkcmVzdWx0cyA9ICQoJyNyZXN1bHRzJyk7XG5cblJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KCR0aXRsZSwgJ2tleXVwJylcbiAgLm1hcCgoZSkgPT4gZS50YXJnZXQudmFsdWUpXG4gIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gIC5kZWJvdW5jZVRpbWUoNTAwKVxuICAuc3dpdGNoTWFwKGdldEl0ZW1zKVxuICAuc3Vic2NyaWJlKChpdGVtcykgPT4ge1xuICAgICRyZXN1bHRzLmVtcHR5KCk7XG4gICAgJHJlc3VsdHMuYXBwZW5kKGl0ZW1zLm1hcCgocikgPT4gJChgPGxpIC8+YCkudGV4dChyKSkpO1xuICB9KTtcbiIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJBbGwgdGhlIFJ4IGhhcyBubyBleHRlcm5hbCBzdGF0ZSwgd2hlcmVhcyB0aGUgb3RoZXIgY29kZSBkb2VzLiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJSeCBkb2Vzbid0IGhhdmUgdG8gd2FpdCBmb3IgdXMgdG8gdGVsbCBpdCB3aGVuIHRvIGRvIGl0LiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoiMy10aGUtY29yZS1vZi1yZWFjdGl2ZS1leHRlbnNpb25zIn0sIjM6IFRoZSBDb3JlIG9mIFJlYWN0aXZlIEV4dGVuc2lvbnMiKSxtZHgoImgyIix7ImlkIjoiMzEtb2JlcnZhYmxlcy1vcGVyYXRvcnMtYW5kLXN1YnNjcmlwdGlvbnMifSwiMy4xOiBPYmVydmFibGVzLCBPcGVyYXRvcnMgYW5kIFN1YnNjcmlwdGlvbnMiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJPYnNlcnZhYmxlOiBTb21ldGhpbmcgdGhhdCBjYW4gYmUgb2JzZXJ2ZWQgd2hpY2ggcHJvZHVjZXMgdmFsdWVzIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIk9wZXJhdG9yOiBJdCdzIGFuIG9wZXJhdGlvbiB0aGF0IG1vZGlmaWVzIHRoZSBkYXRhIGJlaW5nIHB1c2hlZCBpbiBmcm9tIHRoZSBvYnNlcnZhYmxlIC0gVGhleSBkb24ndCBwcm9kdWNlIHZhbHVlcyBpbiBhbmQgb2YgdGhlbXNlbHZlcywgYnV0IG1vdmUgdGhlbSB0aHJvdWdoIHRoZSBwaXBlbGluZS4iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiU3Vic2NyaXB0aW9uczogUGllY2Ugb2YgY29kZSB0aGF0IHdpbGwgZG8gc29tZXRoaW5nIHdpdGggdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgb3BlcmF0b3JzIikpLG1keCgicCIsbnVsbCwiTm90ZSwgeW91IGNhbiBtb2RlbCBhbnl0aGluZyBpbiBhIHJlYWN0aXZlIGNvbnRleHQgYnkgdGhpbmtpbmcgYSBsaXR0bGUgYml0IGRpZmZlcmVudGx5LiIpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiV2ViIEFQSSBSZXF1ZXN0IEV4YW1wbGUiKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiUmVhY3RpdmUgY2FuIHN0aWxsIGNvbXBsZXRlLCBvciBpdCBjYW4gZXJyb3Igb3V0IGFuZCByZXRyeS4iKSksbWR4KCJoMiIseyJpZCI6IjMyLWNyZWF0aW5nLW9ic2VydmFibGVzIn0sIjMuMiBDcmVhdGluZyBPYnNlcnZhYmxlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJpbXBvcnQgUnggZnJvbSAncnhqcy9SeCc7XG5cbiMgcHJvbWlzZSB3aWxsIGFsd2F5cyBleGVjdXRlIC0gbm90IGxhenlcbmNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJJbiBwcm9taXNlXCIpO1xuICAgIHJlc29sdmUoXCJoZXlcIik7XG59KTtcblxucHJvbWlzZS50aGVuKGl0ZW0gPT4gY29uc29sZS5sb2coaXRlbSkpO1xuXG4jIHRoaXMgZG9lc24ndCBnaXZlIGFueSBvdXRwdXQhXG4jIG9ic2VydmFibGVzIGFyZSBsYXp5IVxuIyB3b24ndCBydW4gd2l0aG91dCBhIHN1YnNjcmlwdGlvblxuY29uc3Qgc2ltcGxlJCA9IG5ldyBSeC5PYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIkdlbmVyYXRpbmcgb2JzZXJ2YWJsZVwiKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChcIkFuIGl0ZW1zIVwiKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KFwiQW5vdGhlciBpdGVtIVwiKTtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH0sIDEwMDApO1xufSk7XG5cbiMgY3JlYXRpbmcgYSBzdWJzY3JpcHRpb25cbiMgZmlyc3QgYXJnIGlzIHRoZSBuZXh0IGZ1bmN0aW9uXG4jIHNlY29uZCBhcmcgaXMgZXJyb3JcbiMgdGhpcmQgYXJnIGlzIGNvbXBsZXRlXG5zaW1wbGUkLnN1YnNjcmliZShcbiAgICBpdGVtID0+IGNvbnNvbGUubG9nKGBvbmUubmV4dCAke2l0ZW19YCksXG4gICAgZXJyb3IgPT4gY29uc29sZS5sb2coYG9uZS5lcnJvciAke2l0ZW19YCksXG4gICAgKCkgPT4gY29uc29sZS5sb2coXCJvbmUuY29tcGxldGVcIilcbik7XG5cbiMgR2VuZXJhdGluZyBvYnNlcnZhYmxlXG4jIG9uZS5uZXh0IEFuIGl0ZW0hXG4jIG9uZS5uZXh0IEFub3RoZXIgaXRlbSFcbiMgb25lLmNvbXBsZXRlXG5cbnNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHNpbXBsZSQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogaXRlbSA9PiBjb25zb2xlLmxvZyhgdHdvLm5leHQgJHtpdGVtfWApLFxuICAgICAgICBlcnJvcjogZXJyb3IgPT4gY29uc29sZS5sb2coYHR3by5lcnJvciAke2l0ZW19YCksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZyhcInR3by5jb21wbGV0ZVwiKVxuICAgIH0pO1xufSwgMzAwMClcbiIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJSZS1zdWJzY3JpYmluZyB0byBhbiBvYnNlcnZhYmxlIGFsbG93cyB5b3UgdG8gcnVuIHRoYXQgZ2VuZXJhdG9yIGFnYWluIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJmdW5jdGlvbiBjcmVhdGVJbnRlcnZhbCh0aW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSeC5PYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpbmRleCsrKTtcbiAgICAgICAgfSwgdGltZSk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdpbGwgcnVuIHdoZW4gd2UgdW5zdWJzY3JpYmVcbiAgICAgICAgICAgIGNsZWFybkludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlcih0YWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0KGl0ZW0pIHsgY29uc29sZS5sb2coYCR7dGFnfS5uZXh0ICR7aXRlbX1gKTsgfSxcbiAgICAgICAgZXJyb3IoZXJyb3IpIHsgY29uc29sZS5sb2coYCR7dGFnfS5lcnJvciAke2Vycm9yLnN0YWNrIHx8IGVycm9yIH1gKTsgfSxcbiAgICAgICAgY29tcGxldGUoKSB7IGNvbnNvbGUubG9nKGAke3RhZ30uY29tcGxldGVgKTsgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRha2Uob2JzZXJ2YWJsZSwgYW1vdW50KSB7XG4gICAgcmV0dXJuIG5ldyBSeC5PYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcblxuICAgIH0pO1xufVxuXG4vLyB0aGlzIGlzIHRoZSBjb3JlIG9mIHN1YnNjcmlwdGlvbnNcbmZ1bmN0aW9uIHRha2Uoc291cmNlT2JzZXJ2YWJsZSwgYW1vdW50KSB7XG4gICAgcmV0dXJuIG5ldyBSeC5PYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlT2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dChpdGVtKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA+PSBhbW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3IoZXJyb3IpIHsgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpOyB9LFxuICAgICAgICAgICAgY29tcGxldGUoKSB7IG9ic2VydmVyLmNvbXBsZXRlKCk7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xufVxuXG5jb25zdCBldmVyeVNlY29uZF8gPSBjcmVhdGVJbnRlcnZhbCgxMDAwKTtcbmNvbnN0IGZpcnN0Rml2ZVNlY29uZHMgPSB0YWtlKGV2ZXJ5U2Vjb25kXywgNSk7XG5jb25zdCBzdWJzY3JpcHRpb24gPSBldmVyeVNlY29uZF8uc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJvbmVcIikpO1xuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG59LCAzNTAwKTtcbiIpKSxtZHgoInAiLG51bGwsIlRoaXMgc3Vic2NyaXB0aW9uIHdpbGwgY29uc29sZS5sb2cgb3V0IGZvcmV2ZXIgYW5kIGV2ZXIgYW5kIGV2ZXIuLi4gLSB1bmxlc3MsIHdlIGRpc3Bvc2Ugb2YgYSBkZXNjcmlwdGlvbiIpLG1keCgicCIsbnVsbCwiSG93IGRvIG9wZXJhdG9ycyBjb21lIGludG8gcGxheT8iKSxtZHgoInAiLG51bGwsIldlIGNvdWxkIHJ1biBzb21ldGhpbmcgbGlrZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiY29uc3Qgc3Vic2NyaXB0aW9uID0gZXZlcnlTZWNvbmRfLnRha2UoMylzdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9uZVwiKSk7IikpLG1keCgicCIsbnVsbCwiVGhlIHN0ZXBzIGZvciBpdCBhcmUgdGhhdCBpdCBsaXN0ZW5zIGZvciBhIHNvdXJjZSBhbmQgZW1pdHMgYSB0cmFuc2Zvcm1hdGlvbiEiKSxtZHgoImgyIix7ImlkIjoiMzMtYnVpbHQtaW4tb2JzZXJ2YWJsZXMifSwiMy4zOiBCdWlsdCBpbiBPYnNlcnZhYmxlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJpbXBvcnQgUnggZnJvbSAncnhqcy9SeCc7XG5cblxuUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApXG4gICAgLnRha2UoNSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJpbnRlcnZhbFwiKSk7XG5cblJ4Lk9ic2VydmFibGUudGltZXIoMTAwMCwgNTAwKVxuICAgIC50YWtlKDMpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwidGltZXJcIik7XG5cbi8vIG5vdGUsIGFycmF5IGRvZXNuJ3Qgd29yayAtIHVzZSBmcm9tXG5SeC5PYnNlcnZhYmxlLm9mKFwiSGVsbG8gd29ybGQhXCIsIDQyLCBcIndob2FcIilcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJvZlwiKSk7XG5cblJ4Lk9ic2VydmFibGUuZnJvbShbXCJIZWxsbyB3b3JsZCFcIiwgNDIsIFwid2hvYVwiXSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJvZlwiKSk7XG5cblJ4Lk9ic2VydmFibGUuZnJvbShnZW5lcmF0ZSgpKVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9mXCIpKTtcblxuXG5SeC5PYnNlcnZhYmxlLmZyb20oXCJoZWxsbyB3b3JsZCFcIilcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJvZlwiKSk7XG5cbi8vIGl0IGNhbiBhbHNvIHRha2UgaW4gYSBnZW5lcmF0b3IgZnVuY3Rpb24hXG5cbmZ1bmN0aW9uKiBnZW5lcmF0ZSgpIHtcbiAgICB5aWVsZCAxO1xuICAgIHlpZWxkIDU7XG4gICAgeWllbGQgXCJIRVlcIjtcbn1cblxuUnguT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoXCJIZXlcIikpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiZXJyb3JcIikpO1xuXG4vLyBlbXB0eVxuUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiZW1wdHlcIikpO1xuXG4vLyBkZWZlclxubGV0IHNpZGVFZmZlY3QgPSAwO1xuY29uc3QgZGVmZXIgPSBSeC5PYnNlcnZhYmxlLmRlZmVyKCgpID0+IHtcbiAgICBzaWRlRWZmZWN0Kys7XG4gICAgcmV0dXJuIFJ4Lk9ic2VyYWJsZS5vZihzaWRlRWZmZWN0KTtcbn0pO1xuXG5kZWZlci5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcImRlZmVyLm9uZVwiKSk7XG5kZWZlci5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcImRlZmVyLnR3b1wiKSk7XG5kZWZlci5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcImRlZmVyLnRocmVlXCIpKTtcblxuUnguT2JzZXJ2YWJsZS5uZXZlcigpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwibmV2ZXJcIikpO1xuXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEwLCAzMClcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJyYW5nZVwiKSk7XG4iKSksbWR4KCJwIixudWxsLCJCZW5lZml0cyBvZiB0aGUgaXRlcmFibGUgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImZyb20iKSwiPyIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkZvciBldmVyeSBpdGVyYWJsZSwgd2UgY291bGQgbWFwIGV2ZXJ5IGVsZW1lbnQuIikpLG1keCgiaDIiLHsiaWQiOiIzNC11c2luZy1yeGpzLXdpdGgtbm9kZS1qcXVlcnktYW5kLXByb21pc2VzIn0sIjMuNDogVXNpbmcgUnhKUyB3aXRoIE5vZGUsIGpRdWVyeSBhbmQgUHJvbWlzZXMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoJHRpdGxlLCAna2V5dXAnKVxuICAubWFwKChlKSA9PiBlLnRhcmdldC52YWx1ZSlcbiAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgLmRlYm91bmNlVGltZSg1MDApXG4gIC5zd2l0Y2hNYXAoZ2V0SXRlbXMpXG4gIC5zdWJzY3JpYmUoKGl0ZW1zKSA9PiB7XG4gICAgJHJlc3VsdHMuZW1wdHkoKTtcbiAgICAkcmVzdWx0cy5hcHBlbmQoaXRlbXMubWFwKChpKSA9PiAkKCc8bGkgLz4nKS50ZXh0KGkpKSk7XG4gIH0pO1xuIikpLG1keCgicCIsbnVsbCwiTk9URTogV2l0aG91dCB0aGUgc3Vic2NyaWJlLCBpdCB3aWxsIG5ldmVyIGJlIHN1YnNjcmliZWQgdG8gdGhlIGRvbSEiKSxtZHgoInAiLG51bGwsIklmIHdlIGhhdmUgdGhlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCIudGFrZSgxMCkiKSwiIC0gaXQgd291bGQgY29tcGxldGUgYWZ0ZXIgdGFraW5nIDEwIGFuZCB0aGVuIGZ1cnRoZXJtb3JlIHVuc3Vic2NyaWJlIGFuZCBiZSBncmVhdCBmb3IgcGVyZm9ybWFuY2UhIiksbWR4KCJwIixudWxsLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiZnJvbUV2ZW50IiksIiBjYWxscyBmcm9tICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJhZGRFdmVudExpc3RlbmVyIiksIiwgc28gaXQgY2FuIGRvIHBvd2VyZnVsIHRoaW5ncyBsaWtlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJrZXl1cCIpLCIgZm9yIHRob3NlIHRoYXQgZG9uJ3QgaW5pdGlhbGx5IHN1cHBvcnQgaXQuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksImltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmZzLnJlYWRkaXIoJy4vc3JjL3NlcnZlcicsIChlcnIsIGl0ZW1zKSA9PiB7XG4gIGlmIChlcnIpIGNvbnNvbGUubG9nKGVycik7XG4gIGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGl0ZW1zKTtcbiAgfVxufSk7XG5cbi8vIGFsdGVybmF0aXZlXG5jb25zdCByZWFkZGlyID0gUnguT2JzZXJ2YWJsZS5iaW5kTm9kZUNhbGxCYWNrKGZzLnJlYWRkaXIpO1xuXG5yZWFkZGlyKCcuL3NyYy9zZXJ2ZXInKVxuICAvLyBtZXJnZU1hcCBjcmVhdGVzIGl0ZXJhYmxlIGNvbnZlcnRlZCBmcm9tIGFycmF5XG4gIC5tZXJnZU1hcCgoZmlsZXMpID0+IFJ4Lk9ic2VydmFibGUuZnJvbShmaWxlcykpXG4gIC5tYXAoKGZpbGUpID0+IGBNQU5JUFVMQVRFRCAke2ZpbGV9YClcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdyZWFkZGlyJykpO1xuXG4vLyBwcm9taXNlc1xuXG5mdW5jdGlvbiBnZXRJdGVtKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgnSGVsbG8nKTtcbiAgICB9LCAxMDAwKTtcbiAgfSk7XG59XG5cblJ4Lk9ic2VydmFibGUuZnJvbVByb21pc2UoZ2V0SXRlbSgpKS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigncHJvbWlzZScpKTtcbiIpKSxtZHgoImgyIix7ImlkIjoiMzUtc3ViamVjdHMifSwiMy41OiBTdWJqZWN0cyIpLG1keCgicCIsbnVsbCwiU3ViamVjdHMgYXJlIGFub3RoZXIgUnggcHJpbWl0aXZlLiBUaGV5IGFyZSBib3RoIGFuIG9ic2VydmFibGUgYW5kIGEgb2JzZXJ2ZXIhIFVzZWQgdG8gYnJpZGdlIG5vbi1yZWFjdGl2ZSBjb2RlIHdpdGggcmVhY3RpdmUgY29kZS4iKSxtZHgoInAiLG51bGwsIkJlaGF2aW91ciwgcmVwbGF5IHN1YmplY3RzIGV0Yy4iKSxtZHgoInAiLG51bGwsbWR4KCJlbSIse3BhcmVudE5hbWU6InAifSwiV2FybmluZyIpLCI6IHlvdSBzaG91bGQgb25seSByZWFsbHkgY29uc2lkZXIgdGhlbSBhcyBhIGxhc3QgcmVzb3J0IHdoZW4gYnJpZGdpbmcgbm9uLXJlYWN0aXZlIGFuZCByZWFjdGl2ZSBjb2RlLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJjb25zdCBzaW1wbGUgPSBuZXcgUnguU3ViamVjdCgpO1xuXG5zaW1wbGUuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NpbXBsZScpKTtcblxuc2ltcGxlLm5leHQoJ0hlbGxvJyk7XG5zaW1wbGUubmV4dCgnV29ybGQnKTtcbnNpbXBsZS5jb21wbGV0ZSgpO1xuXG5jb25zdCBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg1KTtcbmNvbnN0IGludGVydmFsU3ViamVjdCA9IG5ldyBSeC5TdWJqZWN0KCk7XG5pbnRlcnZhbFN1YmplY3Quc3Vic2NyaWJlKGludGVydmFsKTtcblxuaW50ZXJ2YWxTdWJqZWN0LnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdzdWIxJykpO1xuaW50ZXJ2YWxTdWJqZWN0LnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdzdWIyJykpO1xuaW50ZXJ2YWxTdWJqZWN0LnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdzdWIzJykpO1xuXG4vLyBzdWJzY3JpYmVzIGFmdGVyIHRocmVlIHNlY29uZHNcbnNldFRpbWVvdXQoKCkgPT4ge1xuICBpbnRlcnZhbFN1YmplY3Quc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ0xPT0sgQVQgTUUnKSk7XG59LCAzMDAwKTtcbiIpKSxtZHgoInAiLG51bGwsIkJlZm9yZSwgd2UgaGFkIHRvIGludm9rZSBhIGZ1bmN0aW9uIHRoYXQgY2FsbCAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwibmV4dCIpLCIgYW5kICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJjb21wbGV0ZSIpLCIuIiksbWR4KCJwIixudWxsLCJJbiB0aGUgYWJvdmUgZXhhbXBsZSwgaW50ZXJ2YWxTdWJqZWN0IGlzIGFjdGluZyBhcyBhIHByb3h5IHRvIGFub3RoZXIgb2JzZXJ2YWJsZS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiLy8gbmVlZHMgaW5pdCBzdGF0ZSBwYXJhbWV0ZXJcbmNvbnN0IGN1cnJlbnRVc2VyID0gbmV3IFJ4LkJlaGF2aW9yU3ViamVjdCh7IGlzTG9nZ2VkSW46IGZhbHNlIH0pO1xuY29uc3QgaXNMb2dnZWRJbiA9IGN1cnJlbnRVc2VyLm1hcCgodSkgPT4gdS5pc0xvZ2dlZEluKTtcblxuY3VycmVudFVzZXIubmV4dCh7IGlzTG9nZ2VkSW46IGZhbHNlIH0pO1xuaXNMb2dnZWRJbi5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignaXNMb2dnZWRJbicpKTtcblxuc2V0VGltZW91dCgoKSA9PiB7XG4gIGN1cnJlbnRVc2VyLm5leHQoeyBpc0xvZ2dlZEluOiB0cnVlLCBuYW1lOiAnbmVsc29uJyB9KTtcbn0sIDMwMDApO1xuXG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgaXNMb2dnZWQuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmlwdGlvbignZGVsYXllZCcpKTtcbn0sIDE1MDApO1xuIikpLG1keCgicCIsbnVsbCwiSG93IGRvIHlvdSByZW1lbWJlciBtdWx0aXBsZSBzdGF0ZXM/IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksImNvbnN0IHJlcGxheSA9IG5ldyBSeC5SZXBsYXlTdWJqZWN0KDMpO1xucmVwbGF5Lm5leHQoMSk7XG5yZXBsYXkubmV4dCgyKTtcblxucmVwbGF5LnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwib25lXCIpKTtcblxucmVwbGF5Lm5leHQoMyk7XG5yZXBsYXkubmV4dCg0KTtcbnJlcGxheS5uZXh0KDUpO1xuXG4vLyB0aGlzIHN1YnNjcmlwdGlvbiBvbmx5IGdldHMgdGhlIHByZXZpb3VzIHRocmVlIGl0ZW1zXG5yZXBsYXkuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJ0d29cIikpO1xuXG5yZXBsYXkubmV4dCg2KTtcblxuLy8gd2hhdCB5b3Ugc2VlXG5vbmUubmV4dCAxXG5vbmUubmV4dCAyXG5vbmUubmV4dCAzXG5vbmUubmV4dCA0XG5vbmUubmV4dCA1XG50d28ubmV4dCAzXG50d28ubmV4dCA0XG50d28ubmV4dCA1XG5vbmUubmV4dCA2XG50d28ubmV4dCA2XG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJBc3luYyBTdWJqZWN0cyIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiY29uc3QgYXBpQ2FsbCA9IG5ldyBSeC5Bc3luY1N1YmplY3QoKTtcbmFwaUNhbGwubmV4dCgxKTtcblxuYXBpQ2FsbC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9uZVwiKSk7XG5hcGlDYWxsLm5leHQoMik7XG5cbi8vIG9ubHkgd2lsbCBlbWl0IHRoZSBmaW5hbCBpdGVtIGJlZm9yZSBpdCBpcyBjb21wbGV0ZVxuYXBpQ2FsbC5jb21wbGV0ZSgpO1xuXG4vLyBpZiB5b3Ugc3Vic2NyaWJlIHRvIGl0IGFnYWluLCB0aGF0IGZpbmFsIHZhbHVlIHdpbGwgYmUgZW1pdHRlZFxuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgYXBpQ2FsbC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcInR3b1wiKSk7XG59LCAyMDAwKTtcblxuLy8gb3V0cHV0XG5vbmUubmV4dCAyXG5vbmUuY29tcGxldGVcbnR3by5uZXh0IDJcbnR3by5jb21wbGV0ZVxuIikpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiU3ViamVjdCBTdW1tYXJ5IikpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sImlmIHlvdSBjYW4gZ2V0IGFyb3VuZCBpdCwgZG9uJ3QgdXNlIHN1YmplY3RzIHVubGVzcyB5b3UgaGF2ZSB0byIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJ5b3Ugc2hvdWxkIHVzZSBhbiBvYnNlcnZhYmxlIHdvcmtmbG93IHdoZXJlIHBvc3NpYmxlIikpLG1keCgiaDIiLHsiaWQiOiIzNi1yeGpzLXJlc291cmNlcy1hbmQtZG9jdW1lbnRhdGlvbiJ9LCIzLjY6IFJ4SlMgUmVzb3VyY2VzIGFuZCBEb2N1bWVudGF0aW9uIiksbWR4KCJwIixudWxsLCJTb3VyY2VzOiIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6Imh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdGl2ZVgvcnhqcyJ9KSwiUnhKUyBHaXRodWIiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6Imh0dHA6Ly9yeG1hcmJsZXMuY29tLyJ9KSwiUnhNYXJibGVzIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiJodHRwOi8vamFyZWRmb3JzeXRoLmNvbS9yeHZpc2lvbi9leGFtcGxlcy9wbGF5Z3JvdW5kLyJ9KSwiUnhWaXNpb24gUGxheWdyb3VuZCIpKSksbWR4KCJoMiIseyJpZCI6IjM3LXNoYXJpbmctb2JzZXJ2YWJsZS1zZXF1ZW5jZXMifSwiMy43OiBTaGFyaW5nIE9ic2VydmFibGUgU2VxdWVuY2VzIiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiSG90IE9ic2VydmFibGU6IEl0IHdpbGwgcHJvZHVjZSBldmVudHMgcmVnYXJkbGVzcyBvZiBpZiB5b3UncmUgbGlzdGVuaW5nIC0gZWcuIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJsaSJ9LCJmcm9tRXZlbnQoJHRpdGxlLCAna2V5dXAnKSIpKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ29sZCBPYnNlcmFibGU6IFN0YXJ0cyBvbmNlIHlvdSBzdWJzY3JpYmUgLSBJbnRlcnZhbCBPYnNlcnZhYmxlcyBhcmUgYWN0dWFsbHkgY29sZCBvYnNlcnZhYmxlcyIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiLy8gdGhpcyBleGFtcGxlIHNob3dzIHdoZW4gYm90aCBzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcgZWcgY29sZFxuaW1wb3J0IFJ4IGZyb20gJ3J4anMvUngnO1xuXG5jb25zdCBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG5cbnNldFRpbWVvdXQoKCkgPT4ge1xuICBpbnRlcnZhbC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignb25lJykpO1xufSwgMTIwMCk7XG5cbnNldFRpbWVvdXQoKCkgPT4ge1xuICBpbnRlcnZhbC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigndHdvJykpO1xufSwgMzIwMCk7XG5cbi8vIEhPVFxuLy8gY29ubmVjdGFibGUgb2JzZXJ2YWJsZVxuaW1wb3J0IFJ4IGZyb20gJ3J4anMvUngnO1xuXG5jb25zdCBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMClcbiAgLnRha2UoMTApXG4gIC5wdWJsaXNoKCk7XG5cbmludGVydmFsLmNvbm5lY3QoKTtcblxuc2V0VGltZW91dCgoKSA9PiB7XG4gIGludGVydmFsLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdvbmUnKSk7XG59LCAxMjAwKTtcblxuc2V0VGltZW91dCgoKSA9PiB7XG4gIGludGVydmFsLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCd0d28nKSk7XG59LCAzMjAwKTtcblxuLy8gaWYgeW91IGNvbm5lY3QgYWZ0ZXIgYSBzZXQgaW50ZXJ2YWwsIHRoZW4gaXQgYmVnaW5zIGV4ZWN1dGluZyBhbmQgc2hhcmluZyB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJXaHkgd291bGQgeW91IHdhbnQgYSBob3QgdmFyaWFibGU/IikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCIvLyBoZXJlIHN1YnNjcmliZSBjb25zb2xlLmxvZyBydW5zIHR3aWNlXG5jb25zdCBzb2NrZXQgPSB7IG9uOiAoKSA9PiB7fSB9O1xuY29uc3QgY2hhdE1lc3NhZ2UgPSBuZXcgUnguT2JzZXJ2YWJsZSgob2JzZXJ2YWJsZSkgPT4ge1xuICBjb25zb2xlLmxvZygnc3Vic2NyaWJlZCcpO1xuICBzb2NrZXQub24oJ2NoYXQ6bWVzc2FnZScsIChtZXNzYWdlKSA9PiBvYnNlcnZlci5uZXh0KG1lc3NhZ2UpKTtcbn0pO1xuXG5jaGF0TWVzc2FnZS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignb25lJykpO1xuY2hhdE1lc3NhZ2Uuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3R3bycpKTtcblxuLy8gd2l0aG91dCBpdFxuXG5jb25zdCBzb2NrZXQgPSB7IG9uOiAoKSA9PiB7fSB9O1xuY29uc3QgY2hhdE1lc3NhZ2UgPSBuZXcgUnguT2JzZXJ2YWJsZSgob2JzZXJ2YWJsZSkgPT4ge1xuICBjb25zb2xlLmxvZygnc3Vic2NyaWJlZCcpO1xuICBzb2NrZXQub24oJ2NoYXQ6bWVzc2FnZScsIChtZXNzYWdlKSA9PiBvYnNlcnZlci5uZXh0KG1lc3NhZ2UpKTtcbn0pLnB1Ymxpc2goKTtcblxuY2hhdE1lc3NhZ2UuY29ubmVjdCgpO1xuXG5jaGF0TWVzc2FnZS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignb25lJykpO1xuY2hhdE1lc3NhZ2Uuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3R3bycpKTtcblxuLy8gdXNpbmcgcHVibGlzaExhc3QoKVxuY29uc3Qgc2ltcGxlID0gbmV3IFJ4Lk9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gIG9ic2VydmVyLm5leHQoJ29uZScpO1xuICBvYnNlcnZlci5uZXh0KCd0d28nKTtcbiAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbn0pO1xuXG4vLyBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB2YWx1ZVxuY29uc3QgcHVibGlzaGVkID0gc2ltcGxlLnB1Ymxpc2hMYXN0KCk7XG5cbi8vIGV2ZW4gaWYgd2Ugc3Vic2NyaWJlIGJlZm9yZSBjb25uZWN0LCBib3RoIHdpbGwgZ2V0IHRoZSBsYXN0IHZhbHVlXG5wdWJsaXNoZWQuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ29uZScpKTtcbnB1Ymxpc2hlZC5jb25uZWN0KCk7XG5wdWJsaXNoZWQuc3Vic2NyaWJlKGNyZWFTdWJzY3JpYmVyKCd0d28nKSk7XG5cbi8vIHVzaW5nIHB1Ymxpc2hSZXBsYXkoKVxuY29uc3Qgc2ltcGxlID0gbmV3IFJ4Lk9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gIG9ic2VydmVyLm5leHQoJ29uZScpO1xuICBvYnNlcnZlci5uZXh0KCd0d28nKTtcbiAgb2JzZXJ2ZXIubmV4dCgndGhyZWUnKTtcblxuICByZXR1cm4gKCkgPT4gY29uc29sZS5sb2coJ0Rpc3Bvc2VkJyk7XG59KTtcblxuLy8gYWx3YXlzIHJldHVybnMgdGhlIGxhc3QgdmFsdWVcbmNvbnN0IHB1Ymxpc2hlZCA9IHNpbXBsZS5wdWJsaXNoUmVwbGF5KDIpO1xuXG4vLyBldmVuIGlmIHdlIHN1YnNjcmliZSBiZWZvcmUgY29ubmVjdCwgYm90aCB3aWxsIGdldCB0aGUgbGFzdCB2YWx1ZVxuLy8gdG8gZGlzcG9zZSB3aXRob3V0IHJ1bm5pbmcgY29tcGxldGUsIHdlIG5lZWQgdG8gZGlzY29ubmVjdCBieSB1bnN1YnNjcmliaW5nXG5jb25zdCBzdWIxID0gcHVibGlzaGVkLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdvbmUnKSk7XG5jb25zdCBjb25uZWN0aW9uID0gcHVibGlzaGVkLmNvbm5lY3QoKTtcbmNvbnN0IHN1YjIgPSBwdWJsaXNoZWQuc3Vic2NyaWJlKGNyZWFTdWJzY3JpYmVyKCd0d28nKSk7XG5cbnN1YjEudW5zdWJzY3JpYmUoKTtcbnN1YjIudW5zdWJzY3JpYmUoKTtcblxuY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuIikpLG1keCgicCIsbnVsbCwiUmVmY291bnQgaXMgYSB3YXkgdG8gYXV0b21hdGljYWxseSBoYW5kbGUgdGhlIGNvbm5lY3Rpb24gYW5kIHRoZSB1bnN1YnNjcmlwdGlvbiBvZiBhIGNvbm5lY3Rpb24gb2JzZXJ2YWJsZS4iKSxtZHgoInAiLG51bGwsIkl0IHdpbGwgY29ubmVjdCB0byB0aGUgZmlyc3Qgc3Vic2NyaXB0aW9uIGFuZCB0aGVuIGRpc2Nvbm5lY3RlZCBvbiB0aGUgbGFzdCB1bnN1YnNjcmliZS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLy8gdXNpbmcgcmVmQ291bnQoKVxuY29uc3Qgc2ltcGxlID0gbmV3IFJ4Lk9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIG9ic2VydmVyLm5leHQoXCJvbmVcIik7XG4gICAgb2JzZXJ2ZXIubmV4dChcInR3b1wiKTtcbiAgICBvYnNlcnZlci5uZXh0KFwidGhyZWVcIik7XG5cbiAgICByZXR1cm4gKCkgPT4gY29uc29sZS5sb2coXCJEaXNwb3NlZFwiKTtcbn0pO1xuXG4vLyBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB2YWx1ZVxuY29uc3QgcHVibGlzaGVkID0gc2ltcGxlLnB1Ymxpc2hSZXBsYXkoMikucmVmQ291bnQoKTtcblxuLy8gZXZlbiBpZiB3ZSBzdWJzY3JpYmUgYmVmb3JlIGNvbm5lY3QsIGJvdGggd2lsbCBnZXQgdGhlIGxhc3QgdmFsdWVcbi8vIHRvIGRpc3Bvc2Ugd2l0aG91dCBydW5uaW5nIGNvbXBsZXRlLCB3ZSBuZWVkIHRvIGRpc2Nvbm5lY3QgYnkgdW5zdWJzY3JpYmluZ1xuY29uc3Qgc3ViMSA9IHB1Ymxpc2hlZC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9uZVwiKSk7XG5jb25zdCBzdWIyID0gcHVibGlzaGVkLnN1YnNjcmliZShjcmVhU3Vic2NyaWJlcihcInR3b1wiKSk7XG5cbnN1YjEudW5zdWJzY3JpYmUoKTtcbnN1YjIudW5zdWJzY3JpYmUoKTtcbiIpKSxtZHgoInAiLG51bGwsIlRoZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwicHVibGlzaCgpLnJlZkNvdW50KCkiKSwiIGlzIGRvbmUgc28gb2Z0ZW4sIHRoYXQgaXMgaGFzIGJlZW4gdHVybmVkIGluICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJzaGFyZSgpIiksIi4iKSxtZHgoInAiLG51bGwsIlRheGluZyBwcm9jZXNzZXMgdGhhdCB5b3UgZG9uJ3Qgd2FudCB0byByZXBlYXQgYnV0IHlvdSB3YW50IG11bHRpcGxlIHRoaW5ncyB0byBob29rIGludG8gdGhlIHJlc3VsdCwgdGhlbiB0dXJuIGl0IGludG8gYSBob3Qgc3Vic2NyaXB0aW9uLiIpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiI0MC1vcGVyYXRvcnMtdGhhdC1ldmVyeW9uZS1zaG91bGQta25vdyJ9LCI0LjA6IE9wZXJhdG9ycyB0aGF0IGV2ZXJ5b25lIHNob3VsZCBrbm93IiksbWR4KCJwIixudWxsLCJOb3cgd2Ugd2lsbCBqdXN0IHRhbGsgYWJvdXQgdGhlIGRpZmZlcmVudCBwcmltYXJ5IG9wZXJhdG9ycyB0aGF0IHlvdSB3aWxsIHdvcmsgd2l0aC4iKSxtZHgoImgyIix7ImlkIjoiNDEtZG8tLWZpbmFsbHktLXN0YXJ0d2l0aC0tZmlsdGVyIn0sIjQuMTogRG8gLyBGaW5hbGx5IC8gU3RhcnRXaXRoIC8gRmlsdGVyIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIi8vIGRvID0+IGdldCB0aGUgbmV4dCB2YWx1ZSBhbmQgcGFzcyBpdCBiYWNrIHVuY2hhbmdlZFxuLy8gZmluYWxseSA9PiBvbmx5IGNvbXBsZXRlcyBhZnRlciB0aGUgcmFuZ2UgaGFzIGNvbXBsZXRlZCwgcnVucyByaWdodCBhdCB0aGUgZW5kIG9mIHRoZSBmaW5hbCB2YWx1ZVxuLy8gZmlsdGVyID0+IGZpbHRlcnMgb3V0IGdpdmVuIHN0YXRlbWVudFxuLy8gaW50ZXJ2YWwgPT4gY2FsbCB0aW1lb3V0XG4vLyBzdGFydFdpdGggPT4gc2V0IGluaXRpYWwgdmFsdWVcblxuUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMClcbiAgLmRvKChhKSA9PiBjb25zb2xlLmxvZyhgRnJvbSBkbyAke2F9YCkpXG4gIC5tYXAoKGEpID0+IGEgKiBhKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NpbXBsZScpKTtcblxuUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMClcbiAgLmZpbmFsbHkoKCkgPT4gY29uc29sZS5sb2coYEZyb20gZmluYWxseWApKVxuICAubWFwKChhKSA9PiBhICogMilcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdmaW5hbGx5JykpO1xuXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKVxuICAuZmlsdGVyKChhKSA9PiBhIDwgNSlcbiAgLm1hcCgoYSkgPT4gYSAqIDIpXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignZmlsdGVyJykpO1xuXG5SeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApXG4gIC5zdGFydFdpdGgoLTEpXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignaW50ZXJ2YWwnKSk7XG4iKSksbWR4KCJoMiIseyJpZCI6IjQyLW1lcmdlLS1jb25jYXQifSwiNC4yOiBNZXJnZSAvIENvbmNhdCIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCIvLyBtZXJnZSAtIG1lcmdlIG1hbnkgb2JzZXJ2YWJsZXMgdG9nZXRoZXJzXG4vLyBjb25jYXQgLSB0aGlzIGNvbmNhdGVuYXRlcyBvYnNlcnZhYmxlcyB0byB0aGUgZW5kIG9mIGFub3RoZXIsIGNhbiBhbHNvIHRha2UgYSBsaXN0IG9mIE9ic2VydmFibGVzXG5cblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMClcbiAgICAubWVyZ2UoUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApKVxuICAgIC50YWtlKDUpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwibWVyZ2UxXCIpKTtcblxuUnguT2JzZXJ2YWJsZS5tZXJnZShcbiAgICBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLm1hcChpID0+IGAke2l9IHNlY29uZHMpLFxuICAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS5tYXAoaSA9PiBgJHtpfSBoYWxmIHNlY29uZHMpKVxuICAgIC50YWtlKDUpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdtZXJnZTInKSk7XG5cbi8vIGRpZmZlcmVudCBldmVudHMgZm9yIG1lcmdlZCBvYnNlcnZhYmxlc1xuUnguT2JzZXJ2YWJsZS5tZXJnZShcbiAgICBzb2NrZXQub24kKFwibG9naW5cIikubWFwKHVzZXIgPT4gcHJvY2Vzc1VzZXIodXNlciksXG4gICAgc29ja2V0Lm9uJChcImxvZ291dFwiKS5tYXAoKCkgPT4gbnVsbCkpO1xuXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDUpXG4gICAgLmNvbmNhdChSeC5PYnNlcnZhYmxlLnJhbmdlKDEwLDMpKVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcImNvbmNhdDFcIikpO1xuIikpLG1keCgiaDIiLHsiaWQiOiI0My1tYXAtLW1lcmdlbWFwLS1zd2l0Y2htYXAifSwiNC4zOiBNYXAgLyBNZXJnZU1hcCAvIFN3aXRjaE1hcCIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCIvLyBtYXAgLSBhIHByb2plY3Rpb24gb24gZXZlcnkgaXRlbSB0aGF0IGNvbWVzIGluXG4vLyBtZXJnZU1hcCAtIHNlbGVjdCBtYW55LCBkb2VzIHByb2plY3Rpb24gYW5kIHRoZW4gaGFzIGFub3RoZXIgdGhpbmcgdGhhdCB3ZSB3aWxsIHdvcmsgb25cbi8vIHN3aXRjaE1hcCAtIHNpbWlsYXIgdG8gbWVyZ2VNYXAgYnV0IHJlcGxhY2VzIHdpdGggdGhlIGxhdGVzdCB2YWx1ZSBpZiBhbm90aGVyIGVtaXNzaW9uIGNvbWVzIGluXG5cbmZ1bmN0aW9uIGFycmF5TWFwKGFyciwgcHJvaikge1xuICBsZXQgcmV0dXJuQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSBvZiBhcnIpIHtcbiAgICByZXR1cm5BcnJheS5wdXNoKHByb2ooaXRlbSkpO1xuICB9XG5cbiAgcmV0dXJuIHJldHVybkFycmF5O1xufVxuXG5hcnJheU1hcChbMSwgMiwgM10sIChhKSA9PiBhICogYSk7XG5cbi8vIGltYWdpbmUgYXJyYXkgb2YgZGljdHNcbmNvbnN0IGFsYnVtcyA9IFt7fSwge31dO1xuXG5mdW5jdGlvbiBhcnJheU1lcmdlTWFwKGFyciwgcHJvaikge1xuICBsZXQgcmV0dXJuQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSBvZiBhcnIpIHtcbiAgICBsZXQgcHJvakFycmF5ID0gcHJvaihpdGVtKTtcbiAgICBmb3IgKGxldCBqIG9mIHByb2pBcnJheSkge1xuICAgICAgcmV0dXJuQXJyYXkucHVzaChwcm9qKGl0ZW0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuQXJyYXk7XG59XG5cbmNvbnN0IHRyYWNrcyA9IGFycmF5TWVyZ2VNYXAoYWxidW1zLCAoYWxidW0pID0+IGFsYnVtLnRyYWNrcyk7XG5cblJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMylcbiAgLm1lcmdlTWFwKChpKSA9PlxuICAgIFJ4Lk9ic2VydmFibGUudGltZXIoaSAqIDEwMDApLm1hcCgoKSA9PiBgQWZ0ZXIgJHtpfSBzZWNvbmRzYClcbiAgKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ21lcmdlTWFwJykpO1xuXG5SeC5PYnNlcnZhYmxlLmZyb21Qcm9taXNlKGdldFRyYWNrcygpKVxuICAubWVyZ2VNYXAoKHRyYWNrcykgPT4gUnguT2JzZXJ2YWJsZS5mcm9tKHRyYWNrcykpXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigndHJhY2tzJykpO1xuXG5mdW5jdGlvbiBnZXRUcmFja3MoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKFsndHJhY2sgMScsICd0cmFjayAyJywgJ3RyYWNrIDMnXSk7XG4gICAgfSwgMTAwMCk7XG4gIH0pO1xufVxuXG4vLyBzeW5jaHJvbm91cyBleGFtcGxlXG5SeC5PYnNlcnZhYmxlLm9mKCdteSBxdWVyeScpXG4gIC5kbygoKSA9PiBjb25zb2xlLmxvZygnUXVlcnlpbmcnKSlcbiAgLm1lcmdlTWFwKChhKSA9PiBxdWVyeShhKSlcbiAgLmRvKCgpID0+IGNvbnNvbGUubG9nKCdBZnRlciBxdWVyeWluZycpKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3F1ZXJ5JykpO1xuXG5mdW5jdGlvbiBxdWVyeSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgnVGhpcyBpcyB0aGUgcmVzb2x2ZWQgdmFsdWUnKTtcbiAgICB9LCAxMDAwKTtcbiAgfSk7XG59XG5cbi8vIHN3aXRjaCBtYXBcbiIpKSxtZHgoImgyIix7ImlkIjoiNDQtcmVkdWNlLS1zY2FuIn0sIjQuNDogUmVkdWNlIC8gU2NhbiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCIvLyByZWR1Y2VyIChhY2MsIHZhbHVlKSBhbmQgd29ya3Mgb24gdmFsdWUgLSBkb2Vzbid0IGVtaXQgdW50aWwgdGhlIGNvbXBsZXRpb25cbi8vIHNjYW4gLSBwcm9jZXNzZXMgYW5kIGVtaXRzIGFzIGl0IGNvbWVzIGluXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKVxuICAucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdyZWR1Y2UnKSk7XG5cblJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApXG4gIC5zY2FuKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdzY2FuJykpO1xuIikpLG1keCgiaDIiLHsiaWQiOiI0NS1idWZmZXItLXRvYXJyYXkifSwiNC41OiBCdWZmZXIgLyBUb0FycmF5IiksbWR4KCJwIixudWxsLCJUaGVyZSBoYXZlIGJlZW4gc29tZSBiaWcgY2hhbmdlcyB0byBob3cgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImJ1ZmZlciIpLCIgaGFzIGJlZW4gdXNlZC4iKSxtZHgoInAiLG51bGwsIkJ1ZmZlciB0YWtlcyBpbiBhbiBvYnNlcnZhYmxlLiIpLG1keCgicCIsbnVsbCwidG9BcnJheSB3aWxsIGNvbnZlcnQgcmVzdWx0cyBpbnRvIGFuIGFycmF5LiAtIHN0aWxsIGhhcyBhIGNsZWFuIGV4aXQgaWYgdGhlIG5ldmVyKCkgaXMgaW1wbGVtZW50ZWQhIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIlJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTAwKVxuICAgIC5idWZmZXJDb3VudCgyNSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJpdGVtc1wiKTtcblxuLy8gd2lsbCB0YWtlIDI1IGl0ZW1zIGFuZCBwdXNoaW5nIHRoZW0gaW50byBhbiBhcnJheVxuXG5cblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKVxuICAgIC5idWZmZXJUaW1lKDIwMDApXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiYnVmZmVyVGltZVwiKTtcblxuLy8gc2FtZSBiZWhhdmlvdXIhXG4vLyBlbWl0dGluZyBldmVudCBjYXVzZXMgYnVmZmVyIHRvIGZsdXNoXG5SeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMClcbiAgICAuYnVmZmVyKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiYnVmZmVyXCIpO1xuXG4vL1xuLy8gdG9BcnJheVxuLy9cblxuUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMClcbiAgICAudG9BcnJheSgpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwicmFuZ2VcIikpO1xuIikpLG1keCgiaDIiLHsiaWQiOiI0Ni1maXJzdC0tbGFzdC0tc2luZ2xlLS1za2lwLS10YWtlIn0sIjQuNjogRmlyc3QgLyBMYXN0IC8gU2luZ2xlIC8gU2tpcCAvIFRha2UiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiY29uc3Qgc2ltcGxlID0gbmV3IFJ4Lk9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdHZW5lcmF0aW5nIHNlcXVlbmNlJyk7XG4gIG9ic2VydmVyLm5leHQoMSk7XG4gIG9ic2VydmVyLm5leHQoMik7XG4gIG9ic2VydmVyLm5leHQoMyk7XG4gIG9ic2VydmVyLm5leHQoNCk7XG4gIG9ic2VydmVyLmNvbXBsZXRlKCk7XG59KTtcblxuc2ltcGxlLmZpcnN0KCkuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ2ZpcnN0JykpO1xuXG5zaW1wbGUubGFzdCgpLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdsYXN0JykpO1xuXG4vLyBkaXNwbGF5cyAxICYgNFxuLy8gaWYgbm90aGluZyBpcyBpbiB0aGVyZSwgdGhlcmUgYXJlIEVtcHR5RXJyb3IocykgdGhyb3duXG5cbi8vIHNpbmdsZS5lcnJvciB0aHJvd24gaXMgbW9yZSB0aGFuIG9uZSBlcnJvciB0aHJvd25cbnNpbXBsZS5zaW5nbGUoKS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignc2luZ2xlJykpO1xuXG4vLyB0YWtlIGFuZCBza2lwIHdvbid0IHRocm93IGVycm9yc1xuLy8gdGFrZSBkb2VzIHRoZSBmaXJzdCBob3dldmVyIGVtaXNzaW9uc1xuLy8gc2tpcCB3aWxsIHRha2UgdGhlIGVtaXNzaW9ucyBhZnRlciBhIG51bWJlclxuc2ltcGxlLnRha2UoMikuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3Rha2UnKSk7XG5cbnNpbXBsZS5za2lwKDIpLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdza2lwJykpO1xuXG4vLyAzLCA0XG5zaW1wbGVcbiAgLnNraXAoMilcbiAgLnRha2UoMilcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdza2lwJykpO1xuXG4vLyBza2lwV2hpbGUgLyB0YWtlV2hpbGVcblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKVxuICAuc2tpcFdoaWxlKChpKSA9PiBpIDwgNClcbiAgLnRha2VXaGlsZSgoaSkgPT4gaSA8IDEwKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NraXBXaGlsZS90YWtlV2hpbGUnKSk7XG5cbi8vIHdoYXQncyB1bnRpbCBhbmQgdGFrZSBlbWlzc2lvbnMgdW50aWxcblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKVxuICAuc2tpcFVudGlsKFJ4Lk9ic2VydmFibGUudGltZXIoMTAwMCkpXG4gIC50YWtlVW50aWwoUnguT2JzZXJ2YWJsZS50aW1lcig0MDAwKSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdza2lwVW50aWwnKSk7XG4iKSksbWR4KCJoMiIseyJpZCI6IjQ3LXppcC0td2l0aGxhdGVzdGZyb20tLWNvbWJpbmVsYXRlc3QifSwiNC43OiBaaXAgLyBXaXRoTGF0ZXN0RnJvbSAvIENvbWJpbmVMYXRlc3QiKSxtZHgoInAiLG51bGwsIkhvdyBjYW4gd2UgY29tYmluZSBvYnNlcnZhYmxlcyBpbiBkaWZmZXJlbnQgd2F5cz8iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiZnVuY3Rpb24gYXJyYXlaaXAoYXJyMSwgYXJyMiwgc2VsZWN0b3JGdW5jKSB7XG4gIGNvbnN0IGNvdW50ID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IGNvbWJpbmVkID0gc2VsZWN0b3IoYXJyMVtpXSwgYXJyMltpXSk7XG4gICAgcmVzdWx0cy5wdXNoKGNvbWJpbmVkKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5jb25zdCBhcnIxID0gWzMyLCAyLCA1MiwgNDMsIDU0XTtcbmNvbnN0IGFycjIgPSBbMSwgMCwgMTAsIDQsIDEsIDQsIDYsIDJdO1xuY29uc3QgcmVzdWx0cyA9IGFycmF5WmlwKGFycjEsIGFycjIsIChsZWZ0LCByaWdodCkgPT4gbGVmdCAqIHJpZ2h0KTtcblxuY29uc29sZS5sb2cocmVzdWx0cyk7XG5cbi8vIGluIFJ4SlNcblJ4Lk9ic2VydmFibGUucmFuZ2UoMS4xKVxuICAuemlwKFxuICAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKSxcbiAgICAobGVmdCwgcmlnaHQpID0+IGBpdGVtOiAke2xlZnR9LCBhdCAke3JpZ2h0ICogNTAwfWBcbiAgKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3ppcCcpKTtcblxuLy8gZW1pdHMgdmFsdWUgd2hlbiBzb3VyY2UgZW1pdHNcbi8vIGNhbiBhbHNvIHBhc3MgKGxlZnQsIHJpZ2h0KSBmdW5jdGlvbiBsaWtlIHppcCBhcyBzZWNvbmQgcGFyYW1ldGVyXG5SeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApXG4gIC53aXRoTGF0ZXN0RnJvbShSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkpXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignd2l0aExhdGVzdEZyb20nKSk7XG5cbi8vIGVtaXQgdmFsdWUgaWYgZWl0aGVyIGRvXG5SeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApXG4gIC5jb21iaW5lTGF0ZXN0KFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCd3aXRoTGF0ZXN0RnJvbScpKTtcbiIpKSxtZHgoImgyIix7ImlkIjoiNDgtZXJyb3ItaGFuZGxpbmctY2F0Y2gtYW5kLXJldHJ5In0sIjQuODogRXJyb3IgSGFuZGxpbmcgQ2F0Y2ggYW5kIFJldHJ5IiksbWR4KCJwIixudWxsLCJJZiBhbiBlcnJvciBoYXBwZW5zLCBhbiBvYnNlcnZlciBzdG9wcyBlbWl0dGluZyBhbmQgY2FuIHByZXZlbnQgdmFsdWVzIGZyb20gZW1pdHRpbmcgYXQgYWxsLiBFcnJvciBoYW5kbGluZyBpcyB2ZXJ5IGltcG9ydGFudCEiKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCIuY2F0Y2goZXJyb3IgPT4gUnguT2JzZXJ2YWJsZS5vZihlcnJvcikpIiksIiBjYW4gcGFzcyB0aGlzIGRvd24gYXMgYW4gT2JzZXJ2YWJsZS4iKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCIucmV0cnkoKSIpLCIgd2UgY2FuIHBhc3MgaW4gd2l0aCBhIG51bWVyYWwgdG8gZW5zdXJlIHRoYXQgd2UgZWl0aGVyIGtlZXAgcmV0cnlpbmcgb3IgcmV0cnkgYSBjZXJ0YWluIG51bWJlciBvZiB0aW1lcy4iKSk7fWlmKHR5cGVvZiBNRFhDb250ZW50IT09J3VuZGVmaW5lZCcmJk1EWENvbnRlbnQmJk1EWENvbnRlbnQ9PT1PYmplY3QoTURYQ29udGVudCkmJk9iamVjdC5pc0V4dGVuc2libGUoTURYQ29udGVudCkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShNRFhDb250ZW50LCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJNRFhDb250ZW50IixmaWxlbmFtZToibWFudWFsL0phdmFTY3JpcHQvSlMtUnhKUy5tZCJ9fSk7fU1EWENvbnRlbnQuaXNNRFhDb21wb25lbnQ9dHJ1ZTs="},{"version":3,"sources":["/Users/okeeffe_d/Project-Imposter/developer-notes/manual/JavaScript/JS-RxJS.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"rxjs\"\n    }}>{`RxJS`}</h1>\n    {\n      /* TOC -->autoauto- [RxJS](#rxjs)auto    - [1.0 A Brief Recap of Programming Paradigms](#10-a-brief-recap-of-programming-paradigms)auto        - [Procedural Program](#procedural-program)auto        - [Object Oriented](#object-oriented)auto        - [Declarative](#declarative)auto    - [1.1: Core Reactive Concepts](#11-core-reactive-concepts)auto    - [1.2: Comparing the Autocomplete function using JS vs RxJS](#12-comparing-the-autocomplete-function-using-js-vs-rxjs)auto    - [3: The Core of Reactive Extensions](#3-the-core-of-reactive-extensions)auto    - [3.1: Obervables, Operators and Subscriptions](#31-obervables-operators-and-subscriptions)auto    - [3.2 Creating Observables](#32-creating-observables)auto    - [3.3: Built in Observables](#33-built-in-observables)auto    - [3.4: Using RxJS with Node, jQuery and Promises](#34-using-rxjs-with-node-jquery-and-promises)auto    - [3.5: Subjects](#35-subjects)auto    - [3.6: RxJS Resources and Documentation](#36-rxjs-resources-and-documentation)auto    - [3.7: Sharing Observable Sequences](#37-sharing-observable-sequences)auto    - [4.0: Operators that everyone should know](#40-operators-that-everyone-should-know)auto    - [4.1: Do / Finally / StartWith / Filter](#41-do--finally--startwith--filter)auto    - [4.2: Merge / Concat](#42-merge--concat)auto    - [4.3: Map / MergeMap / SwitchMap](#43-map--mergemap--switchmap)auto    - [4.4: Reduce / Scan](#44-reduce--scan)auto    - [4.5: Buffer / ToArray](#45-buffer--toarray)auto    - [4.6: First / Last / Single / Skip / Take](#46-first--last--single--skip--take)auto    - [4.7: Zip / WithLatestFrom / CombineLatest](#47-zip--withlatestfrom--combinelatest)auto    - [4.8: Error Handling Catch and Retry](#48-error-handling-catch-and-retry)autoauto<!-- /TOC */\n    }\n    <h2 {...{\n      \"id\": \"10-a-brief-recap-of-programming-paradigms\"\n    }}>{`1.0 A Brief Recap of Programming Paradigms`}</h2>\n    <h3 {...{\n      \"id\": \"procedural-program\"\n    }}>{`Procedural Program`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`The ideas that programs are a sense of functions`}</li>\n      <li parentName=\"ul\">{`Goes from top to bottom`}</li>\n      <li parentName=\"ul\">{`Relies heavily on global state, but any line can change the global state`}</li>\n      <li parentName=\"ul\">{`C being a procedural language`}</li>\n      <li parentName=\"ul\">{`\"Imperative\" execution`}</li>\n      <li parentName=\"ul\">{`Easy to write, difficult to maintain`}</li>\n      <li parentName=\"ul\">{`Prone to difficult bugs`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"object-oriented\"\n    }}>{`Object Oriented`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Based around a Primitive: object`}</li>\n      <li parentName=\"ul\">{`Objects have well defined interfaces`}</li>\n      <li parentName=\"ul\">{`Localised behaviour`}</li>\n      <li parentName=\"ul\">{`Objects control state`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Code is still imperative - pro AND con! - Still telling the computer EXACTLY what to do.`}</li>\n      <li parentName=\"ul\">{`Can be more verbose`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"declarative\"\n    }}>{`Declarative`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Describing what you want to happen, but not telling the computer how to do it`}</li>\n      <li parentName=\"ul\">{`Eg. SQL, Regex, HTML`}</li>\n      <li parentName=\"ul\">{`Data is self-describing`}</li>\n      <li parentName=\"ul\">{`As powerful as the interpreter allows`}</li>\n      <li parentName=\"ul\">{`As limiting as the interpreter allows - You want build a game in SQL etc.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"functional\"\n    }}>{`Functional`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`What we want to happen but not how`}</li>\n      <li parentName=\"ul\">{`Little state`}</li>\n      <li parentName=\"ul\">{`Few side effects`}</li>\n      <li parentName=\"ul\">{`Easy to reason about`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Expressive`}</li>\n      <li parentName=\"ul\">{`Works great with OO`}</li>\n      <li parentName=\"ul\">{`Basis in higher math`}</li>\n      <li parentName=\"ul\">{`Cons to think differently`}</li>\n      <li parentName=\"ul\">{`Not always the best choice`}</li>\n      <li parentName=\"ul\">{`No loops, no control logic - Just telling it what we want to happen`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"reactive\"\n    }}>{`Reactive`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Primitive: Observable`}</li>\n      <li parentName=\"ul\">{`Instead of describing data in terms of other data, we describe it in terms of streams of events - From this, we create a pipeline such that we certain data changes, a lot is processed and changed - Example: spreadsheets!`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Expressive`}</li>\n      <li parentName=\"ul\">{`Data flows unidirectionally`}</li>\n      <li parentName=\"ul\">{`Tough to think differently`}</li>\n      <li parentName=\"ul\">{`Subscriptions help change the data`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const cellC2$ = cellA2$\n  .combineLatest(cellB2$)\n  .map((cells) => cells[0] + cells[1]);\n\ncellC2$.subscribe((value) => {\n  console.log(value);\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"11-core-reactive-concepts\"\n    }}>{`1.1: Core Reactive Concepts`}</h2>\n    <p><strong parentName=\"p\">{`Core Concept 1: Pull model vs Push model`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`any data sitting there that you \"ask\" for at some point - example refresh button - manual button trigger - time interval`}</li>\n      <li parentName=\"ul\">{`observable (stream) which is a reactive data source - produces items over a period of time that will either error, complete, or never complete until a page closes - not telling the stream when to get data, it has inbuilt logic on how to get data - we may transform this data - the display of the data is actually part of the description`}</li>\n    </ul>\n    <p>{`An an example for a `}<inlineCode parentName=\"p\">{`pull`}</inlineCode>{` based code, we can think of a window.setInterval() that fires every 5000 seconds.`}</p>\n    <p>{`An example of a push would be to have a function fire and then the return continutes to filter, flatMap, map and subscribe.`}</p>\n    <p><strong parentName=\"p\">{`Core Concept 2: Everything is a database`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`mouse movements`}</li>\n      <li parentName=\"ul\">{`current user`}</li>\n      <li parentName=\"ul\">{`web requests`}</li>\n      <li parentName=\"ul\">{`input boxes`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"12-comparing-the-autocomplete-function-using-js-vs-rxjs\"\n    }}>{`1.2: Comparing the Autocomplete function using JS vs RxJS`}</h2>\n    <p>{`In the comparison where the `}<inlineCode parentName=\"p\">{`$title.on('keyup', () => {})`}</inlineCode>{` runs with a promise returned. The query can run into race conditions.`}</p>\n    <p>{`Also note that every single result also fires.`}</p>\n    <p>{`The issues:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`// Fix up and down arrow\n// Stop always querying\n// Getting race condition\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Bad ways`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`generally `}<inlineCode parentName=\"li\">{`if last query == currentTitle return`}</inlineCode></li>\n      <li parentName=\"ul\">{`using setTimeout to reduce number of queries`}</li>\n      <li parentName=\"ul\">{`Race condition still happening, but bad attempts may be increasing the timeout - Could also use a current id compared to next query id and then returning before the callback occurs`}</li>\n      <li parentName=\"ul\">{`A lot of state across the module being changed`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`The Rx way`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// npm install rxjs-es for es6\nimport $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nconst keyUps$ = Rx.Observable.fromEvent($title, \"keyup\");\nconst queries$ = keyUps$\n    .map(e => e.target.value)\n    .distinctUntilChanged()\n    .debounceTime(250)\n    .switchMap(getItems);   // similar to merge, but if new query comes in, discard the old data\n    //.mergeMap(getItems);  // alias for flatMap\n\nqueries$.subscribe(query => {\n    // get rid of the promise will stop race condition\n    $results.empty();\n    $results.append(items.map( r => $(\\`<li />\\`).text(r)));\n})\n\n<!-- queries$.subscribe(query => {\n    console.log(e); // prints out event\n    getItems(query)\n        .then(items => {\n            $results.empty();\n            $results.append(items.map( r => $(\\`<li />\\`).text(r)));\n        });\n}) -->\n`}</code></pre>\n    <p>{`An even better way.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nRx.Observable.fromEvent($title, 'keyup')\n  .map((e) => e.target.value)\n  .distinctUntilChanged()\n  .debounceTime(500)\n  .switchMap(getItems)\n  .subscribe((items) => {\n    $results.empty();\n    $results.append(items.map((r) => $(\\`<li />\\`).text(r)));\n  });\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`All the Rx has no external state, whereas the other code does.`}</li>\n      <li parentName=\"ul\">{`Rx doesn't have to wait for us to tell it when to do it.`}</li>\n    </ul>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"3-the-core-of-reactive-extensions\"\n    }}>{`3: The Core of Reactive Extensions`}</h2>\n    <h2 {...{\n      \"id\": \"31-obervables-operators-and-subscriptions\"\n    }}>{`3.1: Obervables, Operators and Subscriptions`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Observable: Something that can be observed which produces values`}</li>\n      <li parentName=\"ul\">{`Operator: It's an operation that modifies the data being pushed in from the observable - They don't produce values in and of themselves, but move them through the pipeline.`}</li>\n      <li parentName=\"ul\">{`Subscriptions: Piece of code that will do something with the values returned by the operators`}</li>\n    </ul>\n    <p>{`Note, you can model anything in a reactive context by thinking a little bit differently.`}</p>\n    <p><strong parentName=\"p\">{`Web API Request Example`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`Reactive can still complete, or it can error out and retry.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"32-creating-observables\"\n    }}>{`3.2 Creating Observables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Rx from 'rxjs/Rx';\n\n# promise will always execute - not lazy\nconst promise = new Promise((resolve, reject) => {\n    console.log(\"In promise\");\n    resolve(\"hey\");\n});\n\npromise.then(item => console.log(item));\n\n# this doesn't give any output!\n# observables are lazy!\n# won't run without a subscription\nconst simple$ = new Rx.Observable(observer => {\n    console.log(\"Generating observable\");\n    setTimeout(() => {\n        observer.next(\"An items!\");\n        setTimeout(() => {\n            observer.next(\"Another item!\");\n            observer.complete();\n        }, 1000);\n    }, 1000);\n});\n\n# creating a subscription\n# first arg is the next function\n# second arg is error\n# third arg is complete\nsimple$.subscribe(\n    item => console.log(\\`one.next \\${item}\\`),\n    error => console.log(\\`one.error \\${item}\\`),\n    () => console.log(\"one.complete\")\n);\n\n# Generating observable\n# one.next An item!\n# one.next Another item!\n# one.complete\n\nsetTimeout(() => {\n    simple$.subscribe({\n        next: item => console.log(\\`two.next \\${item}\\`),\n        error: error => console.log(\\`two.error \\${item}\\`),\n        complete: () => console.log(\"two.complete\")\n    });\n}, 3000)\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`Re-subscribing to an observable allows you to run that generator again`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`function createInterval(time) {\n    return new Rx.Observable(observer => {\n        let index = 0;\n        let interval = setInterval(() => {\n            observer.next(index++);\n        }, time);\n\n        return () => {\n            // will run when we unsubscribe\n            clearnInterval(interval);\n        };\n    });\n}\n\nfunction createSubscriber(tag) {\n    return {\n        next(item) { console.log(\\`\\${tag}.next \\${item}\\`); },\n        error(error) { console.log(\\`\\${tag}.error \\${error.stack || error }\\`); },\n        complete() { console.log(\\`\\${tag}.complete\\`); }\n    };\n}\n\nfunction take(observable, amount) {\n    return new Rx.Observable(observer => {\n\n    });\n}\n\n// this is the core of subscriptions\nfunction take(sourceObservable, amount) {\n    return new Rx.Observable(observer => {\n        let count = 0;\n        const subscription = sourceObservable.subscribe({\n            next(item) {\n                observer.next(item);\n                if (++count >= amount) {\n                    observer.complete();\n                }\n            },\n            error(error) { observer.error(error); },\n            complete() { observer.complete(); }\n        });\n\n        return () => subscription.unsubscribe();\n    });\n}\n\nconst everySecond_ = createInterval(1000);\nconst firstFiveSeconds = take(everySecond_, 5);\nconst subscription = everySecond_.subscribe(createSubscriber(\"one\"));\nsetTimeout(() => {\n    subscription.unsubscribe();\n}, 3500);\n`}</code></pre>\n    <p>{`This subscription will console.log out forever and ever and ever... - unless, we dispose of a description`}</p>\n    <p>{`How do operators come into play?`}</p>\n    <p>{`We could run something like `}<inlineCode parentName=\"p\">{`const subscription = everySecond_.take(3)subscribe(createSubscriber(\"one\"));`}</inlineCode></p>\n    <p>{`The steps for it are that it listens for a source and emits a transformation!`}</p>\n    <h2 {...{\n      \"id\": \"33-built-in-observables\"\n    }}>{`3.3: Built in Observables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Rx from 'rxjs/Rx';\n\n\nRx.Observable.interval(500)\n    .take(5)\n    .subscribe(createSubscriber(\"interval\"));\n\nRx.Observable.timer(1000, 500)\n    .take(3)\n    .subscribe(createSubscriber(\"timer\");\n\n// note, array doesn't work - use from\nRx.Observable.of(\"Hello world!\", 42, \"whoa\")\n    .subscribe(createSubscriber(\"of\"));\n\nRx.Observable.from([\"Hello world!\", 42, \"whoa\"])\n    .subscribe(createSubscriber(\"of\"));\n\nRx.Observable.from(generate())\n    .subscribe(createSubscriber(\"of\"));\n\n\nRx.Observable.from(\"hello world!\")\n    .subscribe(createSubscriber(\"of\"));\n\n// it can also take in a generator function!\n\nfunction* generate() {\n    yield 1;\n    yield 5;\n    yield \"HEY\";\n}\n\nRx.Observable.throw(new Error(\"Hey\"))\n    .subscribe(createSubscriber(\"error\"));\n\n// empty\nRx.Observable.empty()\n    .subscribe(createSubscriber(\"empty\"));\n\n// defer\nlet sideEffect = 0;\nconst defer = Rx.Observable.defer(() => {\n    sideEffect++;\n    return Rx.Obserable.of(sideEffect);\n});\n\ndefer.subscribe(createSubscriber(\"defer.one\"));\ndefer.subscribe(createSubscriber(\"defer.two\"));\ndefer.subscribe(createSubscriber(\"defer.three\"));\n\nRx.Observable.never()\n    .subscribe(createSubscriber(\"never\"));\n\nRx.Observable.range(10, 30)\n    .subscribe(createSubscriber(\"range\"));\n`}</code></pre>\n    <p>{`Benefits of the iterable `}<inlineCode parentName=\"p\">{`from`}</inlineCode>{`?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`For every iterable, we could map every element.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"34-using-rxjs-with-node-jquery-and-promises\"\n    }}>{`3.4: Using RxJS with Node, jQuery and Promises`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`Rx.Observable.fromEvent($title, 'keyup')\n  .map((e) => e.target.value)\n  .distinctUntilChanged()\n  .debounceTime(500)\n  .switchMap(getItems)\n  .subscribe((items) => {\n    $results.empty();\n    $results.append(items.map((i) => $('<li />').text(i)));\n  });\n`}</code></pre>\n    <p>{`NOTE: Without the subscribe, it will never be subscribed to the dom!`}</p>\n    <p>{`If we have the `}<inlineCode parentName=\"p\">{`.take(10)`}</inlineCode>{` - it would complete after taking 10 and then furthermore unsubscribe and be great for performance!`}</p>\n    <p><inlineCode parentName=\"p\">{`fromEvent`}</inlineCode>{` calls from `}<inlineCode parentName=\"p\">{`addEventListener`}</inlineCode>{`, so it can do powerful things like `}<inlineCode parentName=\"p\">{`keyup`}</inlineCode>{` for those that don't initially support it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import fs from 'fs';\n\nfs.readdir('./src/server', (err, items) => {\n  if (err) console.log(err);\n  else {\n    console.log(items);\n  }\n});\n\n// alternative\nconst readdir = Rx.Observable.bindNodeCallBack(fs.readdir);\n\nreaddir('./src/server')\n  // mergeMap creates iterable converted from array\n  .mergeMap((files) => Rx.Observable.from(files))\n  .map((file) => \\`MANIPULATED \\${file}\\`)\n  .subscribe(createSubscriber('readdir'));\n\n// promises\n\nfunction getItem() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('Hello');\n    }, 1000);\n  });\n}\n\nRx.Observable.fromPromise(getItem()).subscribe(createSubscriber('promise'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"35-subjects\"\n    }}>{`3.5: Subjects`}</h2>\n    <p>{`Subjects are another Rx primitive. They are both an observable and a observer! Used to bridge non-reactive code with reactive code.`}</p>\n    <p>{`Behaviour, replay subjects etc.`}</p>\n    <p><em parentName=\"p\">{`Warning`}</em>{`: you should only really consider them as a last resort when bridging non-reactive and reactive code.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const simple = new Rx.Subject();\n\nsimple.subscribe(createSubscriber('simple'));\n\nsimple.next('Hello');\nsimple.next('World');\nsimple.complete();\n\nconst interval = Rx.Observable.interval(1000).take(5);\nconst intervalSubject = new Rx.Subject();\nintervalSubject.subscribe(interval);\n\nintervalSubject.subscribe(createSubscriber('sub1'));\nintervalSubject.subscribe(createSubscriber('sub2'));\nintervalSubject.subscribe(createSubscriber('sub3'));\n\n// subscribes after three seconds\nsetTimeout(() => {\n  intervalSubject.subscribe(createSubscriber('LOOK AT ME'));\n}, 3000);\n`}</code></pre>\n    <p>{`Before, we had to invoke a function that call `}<inlineCode parentName=\"p\">{`next`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`complete`}</inlineCode>{`.`}</p>\n    <p>{`In the above example, intervalSubject is acting as a proxy to another observable.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// needs init state parameter\nconst currentUser = new Rx.BehaviorSubject({ isLoggedIn: false });\nconst isLoggedIn = currentUser.map((u) => u.isLoggedIn);\n\ncurrentUser.next({ isLoggedIn: false });\nisLoggedIn.subscribe(createSubscriber('isLoggedIn'));\n\nsetTimeout(() => {\n  currentUser.next({ isLoggedIn: true, name: 'nelson' });\n}, 3000);\n\nsetTimeout(() => {\n  isLogged.subscribe(createSubscription('delayed'));\n}, 1500);\n`}</code></pre>\n    <p>{`How do you remember multiple states?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const replay = new Rx.ReplaySubject(3);\nreplay.next(1);\nreplay.next(2);\n\nreplay.subscribe(createSubscriber(\"one\"));\n\nreplay.next(3);\nreplay.next(4);\nreplay.next(5);\n\n// this subscription only gets the previous three items\nreplay.subscribe(createSubscriber(\"two\"));\n\nreplay.next(6);\n\n// what you see\none.next 1\none.next 2\none.next 3\none.next 4\none.next 5\ntwo.next 3\ntwo.next 4\ntwo.next 5\none.next 6\ntwo.next 6\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Async Subjects`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`const apiCall = new Rx.AsyncSubject();\napiCall.next(1);\n\napiCall.subscribe(createSubscriber(\"one\"));\napiCall.next(2);\n\n// only will emit the final item before it is complete\napiCall.complete();\n\n// if you subscribe to it again, that final value will be emitted\nsetTimeout(() => {\n    apiCall.subscribe(createSubscriber(\"two\"));\n}, 2000);\n\n// output\none.next 2\none.complete\ntwo.next 2\ntwo.complete\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Subject Summary`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`if you can get around it, don't use subjects unless you have to`}</li>\n      <li parentName=\"ul\">{`you should use an observable workflow where possible`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"36-rxjs-resources-and-documentation\"\n    }}>{`3.6: RxJS Resources and Documentation`}</h2>\n    <p>{`Sources:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/ReactiveX/rxjs\"\n        }}>{`RxJS Github`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"http://rxmarbles.com/\"\n        }}>{`RxMarbles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"http://jaredforsyth.com/rxvision/examples/playground/\"\n        }}>{`RxVision Playground`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"37-sharing-observable-sequences\"\n    }}>{`3.7: Sharing Observable Sequences`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Hot Observable: It will produce events regardless of if you're listening - eg.`}<inlineCode parentName=\"li\">{`fromEvent($title, 'keyup')`}</inlineCode></li>\n      <li parentName=\"ul\">{`Cold Obserable: Starts once you subscribe - Interval Observables are actually cold observables`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// this example shows when both start from the beginning eg cold\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000).take(10);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// HOT\n// connectable observable\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000)\n  .take(10)\n  .publish();\n\ninterval.connect();\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// if you connect after a set interval, then it begins executing and sharing the underlying observable\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Why would you want a hot variable?`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// here subscribe console.log runs twice\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n  console.log('subscribed');\n  socket.on('chat:message', (message) => observer.next(message));\n});\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// without it\n\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n  console.log('subscribed');\n  socket.on('chat:message', (message) => observer.next(message));\n}).publish();\n\nchatMessage.connect();\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// using publishLast()\nconst simple = new Rx.Observable((observer) => {\n  observer.next('one');\n  observer.next('two');\n  observer.complete();\n});\n\n// always returns the last value\nconst published = simple.publishLast();\n\n// even if we subscribe before connect, both will get the last value\npublished.subscribe(createSubscriber('one'));\npublished.connect();\npublished.subscribe(creaSubscriber('two'));\n\n// using publishReplay()\nconst simple = new Rx.Observable((observer) => {\n  observer.next('one');\n  observer.next('two');\n  observer.next('three');\n\n  return () => console.log('Disposed');\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2);\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber('one'));\nconst connection = published.connect();\nconst sub2 = published.subscribe(creaSubscriber('two'));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n\nconnection.unsubscribe();\n`}</code></pre>\n    <p>{`Refcount is a way to automatically handle the connection and the unsubscription of a connection observable.`}</p>\n    <p>{`It will connect to the first subscription and then disconnected on the last unsubscribe.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`// using refCount()\nconst simple = new Rx.Observable(observer => {\n    observer.next(\"one\");\n    observer.next(\"two\");\n    observer.next(\"three\");\n\n    return () => console.log(\"Disposed\");\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2).refCount();\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber(\"one\"));\nconst sub2 = published.subscribe(creaSubscriber(\"two\"));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`publish().refCount()`}</inlineCode>{` is done so often, that is has been turned in `}<inlineCode parentName=\"p\">{`share()`}</inlineCode>{`.`}</p>\n    <p>{`Taxing processes that you don't want to repeat but you want multiple things to hook into the result, then turn it into a hot subscription.`}</p>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"40-operators-that-everyone-should-know\"\n    }}>{`4.0: Operators that everyone should know`}</h2>\n    <p>{`Now we will just talk about the different primary operators that you will work with.`}</p>\n    <h2 {...{\n      \"id\": \"41-do--finally--startwith--filter\"\n    }}>{`4.1: Do / Finally / StartWith / Filter`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// do => get the next value and pass it back unchanged\n// finally => only completes after the range has completed, runs right at the end of the final value\n// filter => filters out given statement\n// interval => call timeout\n// startWith => set initial value\n\nRx.Observable.range(1, 10)\n  .do((a) => console.log(\\`From do \\${a}\\`))\n  .map((a) => a * a)\n  .subscribe(createSubscriber('simple'));\n\nRx.Observable.range(1, 10)\n  .finally(() => console.log(\\`From finally\\`))\n  .map((a) => a * 2)\n  .subscribe(createSubscriber('finally'));\n\nRx.Observable.range(1, 10)\n  .filter((a) => a < 5)\n  .map((a) => a * 2)\n  .subscribe(createSubscriber('filter'));\n\nRx.Observable.interval(1000)\n  .startWith(-1)\n  .subscribe(createSubscriber('interval'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"42-merge--concat\"\n    }}>{`4.2: Merge / Concat`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// merge - merge many observables togethers\n// concat - this concatenates observables to the end of another, can also take a list of Observables\n\nRx.Observable.interval(1000)\n    .merge(Rx.Observable.interval(500))\n    .take(5)\n    .subscribe(createSubscriber(\"merge1\"));\n\nRx.Observable.merge(\n    Rx.Observable.interval(1000).map(i => \\`\\${i} seconds),\n    Rx.Observable.interval(500).map(i => \\`\\${i} half seconds))\n    .take(5)\n    .subscribe(createSubscriber('merge2'));\n\n// different events for merged observables\nRx.Observable.merge(\n    socket.on$(\"login\").map(user => processUser(user),\n    socket.on$(\"logout\").map(() => null));\n\nRx.Observable.range(1, 5)\n    .concat(Rx.Observable.range(10,3))\n    .subscribe(createSubscriber(\"concat1\"));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"43-map--mergemap--switchmap\"\n    }}>{`4.3: Map / MergeMap / SwitchMap`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// map - a projection on every item that comes in\n// mergeMap - select many, does projection and then has another thing that we will work on\n// switchMap - similar to mergeMap but replaces with the latest value if another emission comes in\n\nfunction arrayMap(arr, proj) {\n  let returnArray = [];\n  for (let i of arr) {\n    returnArray.push(proj(item));\n  }\n\n  return returnArray;\n}\n\narrayMap([1, 2, 3], (a) => a * a);\n\n// imagine array of dicts\nconst albums = [{}, {}];\n\nfunction arrayMergeMap(arr, proj) {\n  let returnArray = [];\n  for (let i of arr) {\n    let projArray = proj(item);\n    for (let j of projArray) {\n      returnArray.push(proj(item));\n    }\n  }\n\n  return returnArray;\n}\n\nconst tracks = arrayMergeMap(albums, (album) => album.tracks);\n\nRx.Observable.range(1, 3)\n  .mergeMap((i) =>\n    Rx.Observable.timer(i * 1000).map(() => \\`After \\${i} seconds\\`)\n  )\n  .subscribe(createSubscriber('mergeMap'));\n\nRx.Observable.fromPromise(getTracks())\n  .mergeMap((tracks) => Rx.Observable.from(tracks))\n  .subscribe(createSubscriber('tracks'));\n\nfunction getTracks() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(['track 1', 'track 2', 'track 3']);\n    }, 1000);\n  });\n}\n\n// synchronous example\nRx.Observable.of('my query')\n  .do(() => console.log('Querying'))\n  .mergeMap((a) => query(a))\n  .do(() => console.log('After querying'))\n  .subscribe(createSubscriber('query'));\n\nfunction query(value) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('This is the resolved value');\n    }, 1000);\n  });\n}\n\n// switch map\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"44-reduce--scan\"\n    }}>{`4.4: Reduce / Scan`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// reducer (acc, value) and works on value - doesn't emit until the completion\n// scan - processes and emits as it comes in\nRx.Observable.range(1, 10)\n  .reduce((acc, value) => acc + value)\n  .subscribe(createSubscriber('reduce'));\n\nRx.Observable.range(1, 10)\n  .scan((acc, value) => acc + value)\n  .subscribe(createSubscriber('scan'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"45-buffer--toarray\"\n    }}>{`4.5: Buffer / ToArray`}</h2>\n    <p>{`There have been some big changes to how `}<inlineCode parentName=\"p\">{`buffer`}</inlineCode>{` has been used.`}</p>\n    <p>{`Buffer takes in an observable.`}</p>\n    <p>{`toArray will convert results into an array. - still has a clean exit if the never() is implemented!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`Rx.Observable.range(1, 100)\n    .bufferCount(25)\n    .subscribe(createSubscriber(\"items\");\n\n// will take 25 items and pushing them into an array\n\n\nRx.Observable.interval(500)\n    .bufferTime(2000)\n    .subscribe(createSubscriber(\"bufferTime\");\n\n// same behaviour!\n// emitting event causes buffer to flush\nRx.Observable.interval(500)\n    .buffer(Rx.Observable.interval(2000))\n    .subscribe(createSubscriber(\"buffer\");\n\n//\n// toArray\n//\n\nRx.Observable.range(1, 10)\n    .toArray()\n    .subscribe(createSubscriber(\"range\"));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"46-first--last--single--skip--take\"\n    }}>{`4.6: First / Last / Single / Skip / Take`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const simple = new Rx.Observable((observer) => {\n  console.log('Generating sequence');\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.next(4);\n  observer.complete();\n});\n\nsimple.first().subscribe(createSubscriber('first'));\n\nsimple.last().subscribe(createSubscriber('last'));\n\n// displays 1 & 4\n// if nothing is in there, there are EmptyError(s) thrown\n\n// single.error thrown is more than one error thrown\nsimple.single().subscribe(createSubscriber('single'));\n\n// take and skip won't throw errors\n// take does the first however emissions\n// skip will take the emissions after a number\nsimple.take(2).subscribe(createSubscriber('take'));\n\nsimple.skip(2).subscribe(createSubscriber('skip'));\n\n// 3, 4\nsimple\n  .skip(2)\n  .take(2)\n  .subscribe(createSubscriber('skip'));\n\n// skipWhile / takeWhile\nRx.Observable.interval(500)\n  .skipWhile((i) => i < 4)\n  .takeWhile((i) => i < 10)\n  .subscribe(createSubscriber('skipWhile/takeWhile'));\n\n// what's until and take emissions until\nRx.Observable.interval(500)\n  .skipUntil(Rx.Observable.timer(1000))\n  .takeUntil(Rx.Observable.timer(4000))\n  .subscribe(createSubscriber('skipUntil'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"47-zip--withlatestfrom--combinelatest\"\n    }}>{`4.7: Zip / WithLatestFrom / CombineLatest`}</h2>\n    <p>{`How can we combine observables in different ways?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function arrayZip(arr1, arr2, selectorFunc) {\n  const count = Math.min(arr1.length, arr2.length);\n  const results = [];\n\n  for (let i = 0; i < count; i++) {\n    const combined = selector(arr1[i], arr2[i]);\n    results.push(combined);\n  }\n\n  return results;\n}\n\nconst arr1 = [32, 2, 52, 43, 54];\nconst arr2 = [1, 0, 10, 4, 1, 4, 6, 2];\nconst results = arrayZip(arr1, arr2, (left, right) => left * right);\n\nconsole.log(results);\n\n// in RxJS\nRx.Observable.range(1.1)\n  .zip(\n    Rx.Observable.interval(500),\n    (left, right) => \\`item: \\${left}, at \\${right * 500}\\`\n  )\n  .subscribe(createSubscriber('zip'));\n\n// emits value when source emits\n// can also pass (left, right) function like zip as second parameter\nRx.Observable.interval(1000)\n  .withLatestFrom(Rx.Observable.interval(500))\n  .subscribe(createSubscriber('withLatestFrom'));\n\n// emit value if either do\nRx.Observable.interval(1000)\n  .combineLatest(Rx.Observable.interval(500))\n  .subscribe(createSubscriber('withLatestFrom'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"48-error-handling-catch-and-retry\"\n    }}>{`4.8: Error Handling Catch and Retry`}</h2>\n    <p>{`If an error happens, an observer stops emitting and can prevent values from emitting at all. Error handling is very important!`}</p>\n    <p><inlineCode parentName=\"p\">{`.catch(error => Rx.Observable.of(error))`}</inlineCode>{` can pass this down as an Observable.`}</p>\n    <p><inlineCode parentName=\"p\">{`.retry()`}</inlineCode>{` we can pass in with a numeral to ensure that we either keep retrying or retry a certain number of times.`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}