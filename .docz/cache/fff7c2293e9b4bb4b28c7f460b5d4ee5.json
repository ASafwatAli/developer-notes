{"remainingRequest":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/okeeffe_d/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md","dependencies":[{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md","mtime":1548282825023},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1561535530324},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1560300163820},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1561535530532},{"path":"/Users/okeeffe_d/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1548285283521}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9va2VlZmZlX2QvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbm9kZV9tb2R1bGVzL2JhYmVsLXByZXNldC1yZWFjdC1hcHAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIjsvKiBAanN4IG1keCAqL2ltcG9ydCBSZWFjdCBmcm9tJ3JlYWN0JztpbXBvcnR7bWR4fWZyb20nQG1keC1qcy9yZWFjdCc7LyogQGpzeCBtZHggKi92YXIgbWFrZVNob3J0Y29kZT1mdW5jdGlvbiBtYWtlU2hvcnRjb2RlKG5hbWUpe3JldHVybiBmdW5jdGlvbiBNRFhEZWZhdWx0U2hvcnRjb2RlKHByb3BzKXtjb25zb2xlLndhcm4oIkNvbXBvbmVudCAiK25hbWUrIiB3YXMgbm90IGltcG9ydGVkLCBleHBvcnRlZCwgb3IgcHJvdmlkZWQgYnkgTURYUHJvdmlkZXIgYXMgZ2xvYmFsIHNjb3BlIik7cmV0dXJuIG1keCgiZGl2Iixwcm9wcyk7fTt9O3ZhciBsYXlvdXRQcm9wcz17fTt2YXIgTURYTGF5b3V0PSJ3cmFwcGVyIjtleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KF9yZWYpe3ZhciBjb21wb25lbnRzPV9yZWYuY29tcG9uZW50cyxwcm9wcz1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZixbImNvbXBvbmVudHMiXSk7cmV0dXJuIG1keChNRFhMYXlvdXQsT2JqZWN0LmFzc2lnbih7fSxsYXlvdXRQcm9wcyxwcm9wcyx7Y29tcG9uZW50czpjb21wb25lbnRzLG1keFR5cGU6Ik1EWExheW91dCJ9KSxtZHgoImgyIix7ImlkIjoicmVhZGluZy10aGUtZDMtZG9jdW1lbnRhdGlvbiJ9LCJSZWFkaW5nIHRoZSBEMyBEb2N1bWVudGF0aW9uIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIi0gW1JlYWRpbmcgdGhlIEQzIERvY3VtZW50YXRpb25dKCNyZWFkaW5nLXRoZS1kMy1kb2N1bWVudGF0aW9uKVxuLSBbbWFwKCkgYW5kIGZpbHRlcigpIG1ldGhvZHNdKCNtYXAtYW5kLWZpbHRlci1tZXRob2RzKVxuLSBbZDMgbWV0aG9kc10oI2QzLW1ldGhvZHMpXG4tIFtQcm9ncmFtbWF0aWMgU1ZHc10oI3Byb2dyYW1tYXRpYy1zdmdzKVxuLSBbU2NhbGluZyBEYXRhXSgjc2NhbGluZy1kYXRhKVxuLSBbU3R5bGluZyB3aXRoIENTU10oI3N0eWxpbmctd2l0aC1jc3MpXG4tIFtBZGRpbmcgVGV4dCB0byB0aGUgY2hhcnRdKCNhZGRpbmctdGV4dC10by10aGUtY2hhcnQpXG4tIFtVc2luZyBTVkcgZ3JvdXBzXSgjdXNpbmctc3ZnLWdyb3VwcylcbiIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjc2VjdGlvbi00LW1ha2luZy1hLWNvbXBsZXgtY2hhcnQifSksIlNlY3Rpb24gNDogTWFraW5nIGEgQ29tcGxleCBDaGFydCIpLG1keCgidWwiLHtwYXJlbnROYW1lOiJsaSJ9LG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjd29ya2luZy13aXRoLWFycmF5cy1vZi1vYmplY3RzIn0pLCJXb3JraW5nIHdpdGggQXJyYXlzIG9mIE9iamVjdHMiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNjcmVhdGluZy1hbi1vcmRpbmFsLXNjYWxlIn0pLCJDcmVhdGluZyBhbiBPcmRpbmFsIFNjYWxlIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjc2V0dGluZy1jb2xvdXItd2l0aC1jb2xvdXItc2NhbGVzIn0pLCJTZXR0aW5nIGNvbG91ciB3aXRoIGNvbG91ciBzY2FsZXMiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6IiNhZGRpbmcteC1hbmQteS1heGlzIn0pLCJBZGRpbmcgWCBhbmQgWSBheGlzIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjZmxpcHBpbmctdGhlLWF4ZXMifSksIkZsaXBwaW5nIHRoZSBheGVzIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjYWRkaW5nLWdyaWRsaW5lcyJ9KSwiQWRkaW5nIEdyaWRsaW5lcyIpKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoImEiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6ImxpIn0seyJocmVmIjoiI3JvdGF0aW5nLXRoZS14LWF4aXMtdGl0bGVzIn0pLCJSb3RhdGluZyB0aGUgWCBheGlzIHRpdGxlcyIpKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoImEiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6ImxpIn0seyJocmVmIjoiI2FkZGluZy1heGlzLWxhYmVscyJ9KSwiQWRkaW5nIGF4aXMgbGFiZWxzIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjdXBkYXRpbmctdGhlLXBsb3QtZnVuY3Rpb24td2l0aC1iZXN0LXByYWN0aXNlcyJ9KSwiVXBkYXRpbmcgdGhlIHBsb3QgZnVuY3Rpb24gd2l0aCBiZXN0IHByYWN0aXNlcyIpKSkpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LG1keCgiYSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToibGkifSx7ImhyZWYiOiIjc2Vjb250aW9uLTUtbWFraW5nLXRoZS1jaGFydC1pbnRlcmFjdGl2ZSJ9KSwiU2Vjb250aW9uIDU6IE1ha2luZyB0aGUgQ2hhcnQgSW50ZXJhY3RpdmUiKSkpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkFQSSBEb2N1bWVudGF0aW9uIGlzIGEgZ3JlYXQgbGluayB0byBib29rbWFyayIpKSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoibWFwLWFuZC1maWx0ZXItbWV0aG9kcyJ9LCJtYXAoKSBhbmQgZmlsdGVyKCkgbWV0aG9kcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJ2YXIgZGF0YSA9IFsxMjMsIDUyLCA0NiwgMzAsIDRdO1xuXG5jb25zdCByZXN1bHRzID0gZGF0YS5maWx0ZXIoKGVudHJ5KSA9PiB7XG4gICAgcmV0dXJuIGVudHJ5ID4gNTA7XG59KTtcblxuY29uc3QgbWFwcGluZyA9IGRhdGEubWFwKChlbnRyeSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGVudHJ5LmtleSk7XG4gICAgY29uc29sZS5sb2coZW50cnkudmFsdWUpO1xufSk7XG4iKSksbWR4KCJociIsbnVsbCksbWR4KCJoMiIseyJpZCI6ImQzLW1ldGhvZHMifSwiZDMgbWV0aG9kcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJjb25zdCBleGFtcGxlID0gZDMubWluKGRhdGEpO1xuY29uc29sZS5sb2coZXhhbXBsZSk7ICAgICAgIC8vIHZhbHVlcyByZXR1cm5lZFxuXG5jb25zdCBkYXRhTG9IaVZhbHVlID0gZDMuZXh0ZW50KGRhdGEpOyAgLy8gcmV0dXJuIG1pbi9tYXggYXMgYXJyYXlcblxudmFyIGRpY3RNaW5WYWx1ZSA9IGQzLm1pbihkb3VudHMsIChkLCBpKSB7XG4gICAgcmV0dXJuIGQudmFsdWU7XG59KTtcbiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoicHJvZ3JhbW1hdGljLXN2Z3MifSwiUHJvZ3JhbW1hdGljIFNWR3MiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwidmFyIGRhdGEgPSBbMTMyLDcxLDMzNyw5Myw3OCw0MywyMCwxNiwzMCw4LDE3LDIxXTtcbmxldCBzdmcgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2NoYXJ0JylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgNDUwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDgwMCk7XG5cbi8vIGNyZWF0aW5nIHRoZSBiYXJzXG4vLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbnN2Zy5zZWxlY3RBbGwoJy5iYXInKVxuICAgIC5kYXRhKGRhdGEpXG4gICAgLmVudGVyKCkgICAgICAgICAgICAgICAgLy8gZW50ZXIgcGhhc2VcbiAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgICAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAuYXR0cigneCcsIDApXG4gICAgLmF0dHIoJ3knLCAoZCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBpICogMjA7XG4gICAgfSlcbiAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9KVxuICAgIC5hdHRyKCdoZWlnaHQnLCAxOSk7XG4iKSksbWR4KCJoMiIseyJpZCI6InNjYWxpbmctZGF0YSJ9LCJTY2FsaW5nIERhdGEiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDcmVhdGluZyBzY2FsaW5nIGZ1bmN0aW9ucyBmb3IgYm90aCB4IGFuZCB5LiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwidmFyIGRhdGEgPSBbMTMyLCA3MSwgMzM3LCA5MywgNzgsIDQzLCAyMCwgMTYsIDMwLCA4LCAxNywgMjFdO1xubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCB4ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSldKVxuICAgIC5yYW5nZShbMCwgd10pO1xubGV0IHkgPSBkMy5zY2FsZVxuICAgIC5saW5lYXIoKVxuICAgIC5kb21haW4oWzAsIGRhdGEubGVuZ3RoXSlcbiAgICAucmFuZ2UoWzAsIGhdKTtcblxubGV0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdCgnYm9keScpXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuYXR0cignaWQnLCAnY2hhcnQnKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuICAgIC5hdHRyKCd3aWR0aCcsIHcpO1xuXG4vLyBjcmVhdGluZyB0aGUgYmFyc1xuLy8gdmVydGljYWwgYmFyIGdyYXBoXG5zdmdcbiAgICAuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAuZGF0YShkYXRhKVxuICAgIC5lbnRlcigpIC8vIGVudGVyIHBoYXNlXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgIC5hdHRyKCd4JywgMClcbiAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB5KGkpO1xuICAgIH0pXG4gICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHgoZCk7IC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgfSlcbiAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHkoMSkgLSAxO1xuICAgIH0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiJzdHlsaW5nLXdpdGgtY3NzIn0sIlN0eWxpbmcgd2l0aCBDU1MiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJHZXR0aW5nIHJpZCBvZiB0aGUgYWxpYXNpbmciKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWNzcyJ9KSwiLmJhciB7XG4gICAgZmlsbDogcHVycGxlO1xufVxuIikpLG1keCgicCIsbnVsbCwiTm90IHRoYXQgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImF0dHIoJ2NsYXNzJywgJ2JhcicpIiksIiB3aWxsIG1hbnVhbGx5IHJlc2V0IHRoZSBjbGFzcyB2YWx1ZSwgc28geW91IGNhbiBhbHNvIHVzZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiLmNsYXNzZWQoJ2JhcicsIHRydWUpIiksIiAtIHRydWUgdG8gYWRkIHRoZSBjbGFzcywgZmFsc2UgdG8gcmVtb3ZlLiIpLG1keCgiaDIiLHsiaWQiOiJhZGRpbmctdGV4dC10by10aGUtY2hhcnQifSwiQWRkaW5nIFRleHQgdG8gdGhlIGNoYXJ0IiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ3JlYXRpbmcgc2NhbGluZyBmdW5jdGlvbnMgZm9yIGJvdGggeCBhbmQgeS4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksInZhciBkYXRhID0gWzEzMiwgNzEsIDMzNywgOTMsIDc4LCA0MywgMjAsIDE2LCAzMCwgOCwgMTcsIDIxXTtcbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgeCA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEpXSlcbiAgICAucmFuZ2UoWzAsIHddKTtcbmxldCB5ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgLnJhbmdlKFswLCBoXSk7XG5cbmxldCBzdmcgPSBkM1xuICAgIC5zZWxlY3QoJ2JvZHknKVxuICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgLmF0dHIoJ2lkJywgJ2NoYXJ0JylcbiAgICAuYXR0cignaGVpZ2h0JywgaClcbiAgICAuYXR0cignd2lkdGgnLCB3KTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkKTsgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAtIDE7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkKTsgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAvIDEuNSArIDI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG59XG5cbi8vIGZpcnN0IGFyZyB3aWxsIGJlIHdoYXQgaXMgcmVmZXJlbmNlZCBieSBcInRoaXNcIlxucGxvdC5jYWxsKHN2Zywge1xuICAgIGRhdGE6IGRhdGFcbn0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiJ1c2luZy1zdmctZ3JvdXBzIn0sIlVzaW5nIFNWRyBncm91cHMiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJTVkcgZ3JvdXBzIGFyZSBsaWtlIGEgZGl2IHRoYXQgYXJlIGEgY29udmVuaWVuY2UgZWxlbWVudCB0byBhbGxvdyBjaGlsZHJlbiB0byBiZSBtb3ZlZCBhbmQgYWZmZWN0ZWQgdG9nZXRoZXIuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJ2YXIgZGF0YSA9IFsxMzIsIDcxLCAzMzcsIDkzLCA3OCwgNDMsIDIwLCAxNiwgMzAsIDgsIDE3LCAyMV07XG5sZXQgdyA9IDgwMDtcbmxldCBoID0gNDUwO1xubGV0IG1hcmdpbiA9IHtcbiAgICB0b3A6IDIwLFxuICAgIGJvdHRvbTogMjAsXG4gICAgbGVmdDogMjAsXG4gICAgcmlnaHQ6IDIwXG59O1xuXG52YXIgd2lkdGggPSB3IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG52YXIgaGVpZ2h0ID0gaCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5sZXQgeCA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEpXSlcbiAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5sZXQgeSA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbMCwgZGF0YS5sZW5ndGhdKVxuICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbmxldCBzdmcgPSBkM1xuICAgIC5zZWxlY3QoJ2JvZHknKVxuICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgLmF0dHIoJ2lkJywgJ2NoYXJ0JylcbiAgICAuYXR0cignaGVpZ2h0JywgaClcbiAgICAuYXR0cignd2lkdGgnLCB3KTtcblxubGV0IGNoYXJ0ID0gc3ZnXG4gICAgLmFwcGVuZCgnZycpXG4gICAgLmNsYXNzZWQoJ2Rpc3BsYXknLCB0cnVlKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDIwLCAyMCknKTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkKTsgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAtIDE7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkKTsgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAvIDEuNSArIDI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG59XG5cbi8vIGZpcnN0IGFyZyB3aWxsIGJlIHdoYXQgaXMgcmVmZXJlbmNlZCBieSBcInRoaXNcIlxucGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgZGF0YTogZGF0YVxufSk7XG4iKSksbWR4KCJociIsbnVsbCksbWR4KCJoMSIseyJpZCI6InNlY3Rpb24tNC1tYWtpbmctYS1jb21wbGV4LWNoYXJ0In0sIlNlY3Rpb24gNDogTWFraW5nIGEgQ29tcGxleCBDaGFydCIpLG1keCgiaDIiLHsiaWQiOiJ3b3JraW5nLXdpdGgtYXJyYXlzLW9mLW9iamVjdHMifSwiV29ya2luZyB3aXRoIEFycmF5cyBvZiBPYmplY3RzIiksbWR4KCJwIixudWxsLCJJZiB3b3JraW5nIHdpdGggYSBkaWN0LCB3ZSBuZWVkIGFuIGFjY2Vzc29yIGZ1bmN0aW9uISIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJ2YXIgZGF0YSA9IFtcbiAgICB7IGtleTogJ0dsYXplZCcsIHZhbHVlOiAxMzIgfSxcbiAgICB7IGtleTogJ0plbGx5JywgdmFsdWU6IDcxIH0sXG4gICAgeyBrZXk6ICdIb2xlcycsIHZhbHVlOiAzMzcgfSxcbiAgICB7IGtleTogJ1Nwcmlua2xlcycsIHZhbHVlOiA5MyB9LFxuICAgIHsga2V5OiAnQ3J1bWInLCB2YWx1ZTogNzggfSxcbiAgICB7IGtleTogJ0Nob2NvbGF0ZScsIHZhbHVlOiA0MyB9LFxuICAgIHsga2V5OiAnQ29jb251dCcsIHZhbHVlOiAyMCB9LFxuICAgIHsga2V5OiAnQ3JlYW0nLCB2YWx1ZTogMTYgfSxcbiAgICB7IGtleTogJ0NydWxsZXInLCB2YWx1ZTogMzAgfSxcbiAgICB7IGtleTogJ1x4QzljbGFpcicsIHZhbHVlOiA4IH0sXG4gICAgeyBrZXk6ICdGcml0dGVyJywgdmFsdWU6IDE3IH0sXG4gICAgeyBrZXk6ICdCZWFyY2xhdycsIHZhbHVlOiAyMSB9XG5dO1xuXG5sZXQgdyA9IDgwMDtcbmxldCBoID0gNDUwO1xubGV0IG1hcmdpbiA9IHtcbiAgICB0b3A6IDIwLFxuICAgIGJvdHRvbTogMjAsXG4gICAgbGVmdDogMjAsXG4gICAgcmlnaHQ6IDIwXG59O1xuXG52YXIgd2lkdGggPSB3IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG52YXIgaGVpZ2h0ID0gaCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5sZXQgeCA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbXG4gICAgICAgIDAsXG4gICAgICAgIGQzLm1heChkYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pXG4gICAgXSlcbiAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbmxldCB5ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxubGV0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdCgnYm9keScpXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuYXR0cignd2lkdGgnLCA4MDApXG4gICAgLmF0dHIoJ2hlaWdodCcsIDQyMClcbiAgICAuYXR0cignaWQnLCAnY2hhcnQnKTtcbmxldCBjaGFydCA9IHN2Z1xuICAgIC5hcHBlbmQoJ2cnKVxuICAgIC5jbGFzc2VkKCdkaXNwbGF5JywgdHJ1ZSlcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgyMCwgMjApJyk7XG5cbmZ1bmN0aW9uIHBsb3QocGFyYW1zKSB7XG4gICAgLy8gY3JlYXRpbmcgdGhlIGJhcnNcbiAgICAvLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhcicpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKSAvLyBlbnRlciBwaGFzZVxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7IC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoMSkgLSAxO1xuICAgICAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyLWxhYmVsJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuY2xhc3NlZCgnYmFyLWxhYmVsJywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7IC8vIHVzZSBjc3MgdG8gY2hhbmdlIHRoZSBhbmNob3JcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R4JywgLTQpXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoMSkgLyAxLjUgKyAyO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pO1xufVxuXG5wbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhXG59KTtcbiIpKSxtZHgoImgyIix7ImlkIjoiY3JlYXRpbmctYW4tb3JkaW5hbC1zY2FsZSJ9LCJDcmVhdGluZyBhbiBPcmRpbmFsIFNjYWxlIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksInZhciBkYXRhID0gW1xuICAgIHtrZXk6IFwiR2xhemVkXCIsICAgICB2YWx1ZTogMTMyfSxcbiAgICB7a2V5OiBcIkplbGx5XCIsICAgICAgdmFsdWU6IDcxfSxcbiAgICB7a2V5OiBcIkhvbGVzXCIsICAgICAgdmFsdWU6IDMzN30sXG4gICAge2tleTogXCJTcHJpbmtsZXNcIiwgIHZhbHVlOiA5M30sXG4gICAge2tleTogXCJDcnVtYlwiLCAgICAgIHZhbHVlOiA3OH0sXG4gICAge2tleTogXCJDaG9jb2xhdGVcIiwgIHZhbHVlOiA0M30sXG4gICAge2tleTogXCJDb2NvbnV0XCIsICAgIHZhbHVlOiAyMH0sXG4gICAge2tleTogXCJDcmVhbVwiLCAgICAgIHZhbHVlOiAxNn0sXG4gICAge2tleTogXCJDcnVsbGVyXCIsICAgIHZhbHVlOiAzMH0sXG4gICAge2tleTogXCJceEM5Y2xhaXJcIiwgICAgIHZhbHVlOiA4fSxcbiAgICB7a2V5OiBcIkZyaXR0ZXJcIiwgICAgdmFsdWU6IDE3fSxcbiAgICB7a2V5OiBcIkJlYXJjbGF3XCIsICAgdmFsdWU6IDIxfVxuXTtcblxubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCBtYXJnaW4gPSB7XG4gICAgdG9wOiAyMCxcbiAgICBib3R0b206IDIwLFxuICAgIGxlZnQ6IDIwLFxuICAgIHJpZ2h0OiAyMFxufTtcblxudmFyIHdpZHRoID0gdyAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xudmFyIGhlaWdodCA9IGggLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxubGV0IHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgIH0pXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xudmFyIHkgPSBkMy5zY2FsZS5vcmRpbmFsKCkgICAgICAgICAgLy8gbmVlZCBkaXN0aW5jdCB2YWx1ZXMgZWcga2V5c1xuICAgICAgICAuZG9tYWluKGRhdGEubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmtleTtcbiAgICAgICAgfSkpXG4gICAgICAgIC5yYW5nZUJhbmRzKFswLCBoZWlnaHRdKTsgICAvLyB1c2VkIGZvciBkaXN0aW5jdCB2YWx1ZXNcblxubGV0IHN2ZyA9IGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDgwMClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCA0MjApXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnY2hhcnQnKTtcbmxldCBjaGFydCA9IHN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdkaXNwbGF5JywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMjAsIDIwKScpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgICAgICAgICAgICAgICAgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAgIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgIC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkgLSAxO1xuICAgICAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyLWxhYmVsJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuY2xhc3NlZCgnYmFyLWxhYmVsJywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgICAgIC8vIHVzZSBjc3MgdG8gY2hhbmdlIHRoZSBhbmNob3JcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R4JywgLTQpXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpLzEuNSsyO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pO1xufVxuXG5wbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhXG59KTtcbiIpKSxtZHgoImgyIix7ImlkIjoic2V0dGluZy1jb2xvdXItd2l0aC1jb2xvdXItc2NhbGVzIn0sIlNldHRpbmcgY29sb3VyIHdpdGggY29sb3VyIHNjYWxlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJ2YXIgZGF0YSA9IFtcbiAgICB7a2V5OiBcIkdsYXplZFwiLCAgICAgdmFsdWU6IDEzMn0sXG4gICAge2tleTogXCJKZWxseVwiLCAgICAgIHZhbHVlOiA3MX0sXG4gICAge2tleTogXCJIb2xlc1wiLCAgICAgIHZhbHVlOiAzMzd9LFxuICAgIHtrZXk6IFwiU3ByaW5rbGVzXCIsICB2YWx1ZTogOTN9LFxuICAgIHtrZXk6IFwiQ3J1bWJcIiwgICAgICB2YWx1ZTogNzh9LFxuICAgIHtrZXk6IFwiQ2hvY29sYXRlXCIsICB2YWx1ZTogNDN9LFxuICAgIHtrZXk6IFwiQ29jb251dFwiLCAgICB2YWx1ZTogMjB9LFxuICAgIHtrZXk6IFwiQ3JlYW1cIiwgICAgICB2YWx1ZTogMTZ9LFxuICAgIHtrZXk6IFwiQ3J1bGxlclwiLCAgICB2YWx1ZTogMzB9LFxuICAgIHtrZXk6IFwiXHhDOWNsYWlyXCIsICAgICB2YWx1ZTogOH0sXG4gICAge2tleTogXCJGcml0dGVyXCIsICAgIHZhbHVlOiAxN30sXG4gICAge2tleTogXCJCZWFyY2xhd1wiLCAgIHZhbHVlOiAyMX1cbl07XG5cbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgbWFyZ2luID0ge1xuICAgIHRvcDogMjAsXG4gICAgYm90dG9tOiAyMCxcbiAgICBsZWZ0OiAyMCxcbiAgICByaWdodDogMjBcbn07XG5cbnZhciB3aWR0aCA9IHcgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbnZhciBoZWlnaHQgPSBoIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbmxldCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEsIChkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICB9KV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbnZhciB5ID0gZDMuc2NhbGUub3JkaW5hbCgpICAgICAgICAgIC8vIG5lZWQgZGlzdGluY3QgdmFsdWVzIGVnIGtleXNcbiAgICAgICAgLmRvbWFpbihkYXRhLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5rZXk7XG4gICAgICAgIH0pKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgaGVpZ2h0XSk7ICAgLy8gdXNlZCBmb3IgZGlzdGluY3QgdmFsdWVzXG5cbi8vIGFsdGVyIGNvbG91cnMgdXNpbmcgbGluZWFyIHNjYWxlXG5sZXQgbGluZWFyQ29sb3JTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWycjNTcyNTAwJywgJyNGNjgwMjYnXSk7XG5cbi8vIG9yZGluYWwgZm9yIGRpc3RpbmN0IGNvbG91cnNcbmxldCBvcmRpbmFsQ29sb3JTY2FsZSA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcblxubGV0IHN2ZyA9IGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDgwMClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCA0MjApXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnY2hhcnQnKTtcbmxldCBjaGFydCA9IHN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdkaXNwbGF5JywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMjAsIDIwKScpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgICAgICAgICAgICAgICAgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAgIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgIC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkgLSAxO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckNvbG9yU2NhbGUoaSk7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAgICAgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkvMS41KzI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSk7XG59XG5cbnBsb3QuY2FsbChjaGFydCwge1xuICAgIGRhdGE6IGRhdGFcbn0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiJhZGRpbmcteC1hbmQteS1heGlzIn0sIkFkZGluZyBYIGFuZCBZIGF4aXMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLy8gYWZ0ZXIgdGhlIGNvbG91ciBzY2FsZXNcblxubGV0IHhBeGlzID0gZDMuc3ZnLmF4aXMoKSAgICAgICAgICAgLy8gc3ZnIHBvcnRpb24gb2YgdGhlIGQzIGxpYnJhcnlcbiAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAub3JpZW50KCdib3R0b20nKTtcblxubGV0IHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgIC5vcmllbnQoJ2xlZnQnKTtcblxuLi4uXG5cbmZ1bmN0aW9uIHBsb3QocGFyYW1zKSB7XG4gICAgLy8gY3JlYXRpbmcgdGhlIGJhcnNcbiAgICAvLyB2ZXJ0aWNhbCBiYXIgZ3JhcGhcbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhcicpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKSAgICAgICAgICAgICAgICAvLyBlbnRlciBwaGFzZVxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpICAgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKSAtIDE7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGluZWFyQ29sb3JTY2FsZShpKTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgICAgICAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKS8xLjUrMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB0aGlzLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgneCBheGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAwICArICcsICcgKyBoZWlnaHQgICsgJyknKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgIHRoaXMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd5IGF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMCknKVxuICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xufVxuIikpLG1keCgiaDIiLHsiaWQiOiJmbGlwcGluZy10aGUtYXhlcyJ9LCJGbGlwcGluZyB0aGUgYXhlcyIpLG1keCgicCIsbnVsbCwiSG93IHRvIGNyZWF0ZSBhIGNvbHVtbiBjaGFydD8iKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJoZWlnaHQgbmVlZHMgdG8gdGFrZSBhbiBvZmZzZXQiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwib3RoZXIgdmFsdWVzIGVzc2VudGlhbGx5IGludmVydCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJ0ZXh0IGFuY2hvciB3aWxsIGJlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToibGkifSwibWlkZGxlIiksIiBpbiBjc3MiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksInZhciBkYXRhID0gW1xuICAgIHtrZXk6IFwiR2xhemVkXCIsICAgICB2YWx1ZTogMTMyfSxcbiAgICB7a2V5OiBcIkplbGx5XCIsICAgICAgdmFsdWU6IDcxfSxcbiAgICB7a2V5OiBcIkhvbGVzXCIsICAgICAgdmFsdWU6IDMzN30sXG4gICAge2tleTogXCJTcHJpbmtsZXNcIiwgIHZhbHVlOiA5M30sXG4gICAge2tleTogXCJDcnVtYlwiLCAgICAgIHZhbHVlOiA3OH0sXG4gICAge2tleTogXCJDaG9jb2xhdGVcIiwgIHZhbHVlOiA0M30sXG4gICAge2tleTogXCJDb2NvbnV0XCIsICAgIHZhbHVlOiAyMH0sXG4gICAge2tleTogXCJDcmVhbVwiLCAgICAgIHZhbHVlOiAxNn0sXG4gICAge2tleTogXCJDcnVsbGVyXCIsICAgIHZhbHVlOiAzMH0sXG4gICAge2tleTogXCJceEM5Y2xhaXJcIiwgICAgIHZhbHVlOiA4fSxcbiAgICB7a2V5OiBcIkZyaXR0ZXJcIiwgICAgdmFsdWU6IDE3fSxcbiAgICB7a2V5OiBcIkJlYXJjbGF3XCIsICAgdmFsdWU6IDIxfVxuXTtcblxubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCBtYXJnaW4gPSB7XG4gICAgdG9wOiAyMCxcbiAgICBib3R0b206IDIwLFxuICAgIGxlZnQ6IDIwLFxuICAgIHJpZ2h0OiAyMFxufTtcblxudmFyIHdpZHRoID0gdyAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xudmFyIGhlaWdodCA9IGggLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxubGV0IHggPSBkMy5zY2FsZS5vcmRpbmFsKCkgICAgICAgICAgLy8gbmVlZCBkaXN0aW5jdCB2YWx1ZXMgZWcga2V5c1xuICAgICAgICAuZG9tYWluKGRhdGEubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmtleTtcbiAgICAgICAgfSkpXG4gICAgICAgIC5yYW5nZUJhbmRzKFswLCBoZWlnaHRdKTsgICAvLyB1c2VkIGZvciBkaXN0aW5jdCB2YWx1ZXNcblxubGV0IHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7ICAgIC8vIElNUE9SVEFOVCBDSEFOR0UgRlJPTSBbMCwgd2lkdGhdXG5cbi8vIGFsdGVyIGNvbG91cnMgdXNpbmcgbGluZWFyIHNjYWxlXG5sZXQgbGluZWFyQ29sb3JTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWycjNTcyNTAwJywgJyNGNjgwMjYnXSk7XG5cbi8vIG9yZGluYWwgZm9yIGRpc3RpbmN0IGNvbG91cnNcbmxldCBvcmRpbmFsQ29sb3JTY2FsZSA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcblxubGV0IHN2ZyA9IGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDgwMClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCA0MjApXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnY2hhcnQnKTtcbmxldCBjaGFydCA9IHN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdkaXNwbGF5JywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMjAsIDIwKScpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgICAgICAgICAgICAgICAgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAgIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQudmFsdWUpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geC5yYW5nZUJhbmQoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJDb2xvclNjYWxlKGkpO1xuICAgICAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyLWxhYmVsJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuY2xhc3NlZCgnYmFyLWxhYmVsJywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgICAgIC8vIHVzZSBjc3MgdG8gY2hhbmdlIHRoZSBhbmNob3JcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R4JywgLTQpXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpLzEuNSsyO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd4IGF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIDAgICsgJywgJyArIGhlaWdodCAgKyAnKScpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgIHRoaXMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd5IGF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMCknKVxuICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xufVxuXG5wbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhXG59KTtcbiIpKSxtZHgoImgyIix7ImlkIjoiYWRkaW5nLWdyaWRsaW5lcyJ9LCJBZGRpbmcgR3JpZGxpbmVzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksInZhciB5R3JpZGxpbmVzID0gZDMuc3ZnLmF4aXMoKSAgICAgICAgICAgICAgLy8gY3JlYXRlIGFub3RoZXIgXCJheGlzXCJcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtd2lkdGgsIDAsIDApICAgICAgICAgICAgIC8vIHVzZWQgdG8gYWRqdXN0IHRoZSBheGlzXG4gICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KCcnKVxuICAgICAgICAgICAgICAgICAgICAub3JpZW50KCdsZWZ0Jyk7XG5cbi8vIGFkZCB0aGVzZSBncmlkIGxpbmVzIHdpdGggdGhlIGNhbGwgZnVuY3Rpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBwbG90IGZ1bmN0aW9uXG4iKSksbWR4KCJwIixudWxsLCJUaGUgZ3JpZCBsaW5lcyBhbHNvIG5lZWQgdG8gYmUgc3R5bGVkISBIaXQgdXAgdGhlIENTUyBmaWxlIHRvIGRvIHRoaXMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIi5ncmlkbGluZSBwYXRoLFxuLmdyaWRsaW5lIGxpbmUge1xuICAgIGZpbGw6IG5vbmU7XG4gICAgY29sb3I6IGJsdWU7XG4gICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xufVxuIikpLG1keCgiaDIiLHsiaWQiOiJyb3RhdGluZy10aGUteC1heGlzLXRpdGxlcyJ9LCJSb3RhdGluZyB0aGUgWCBheGlzIHRpdGxlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIuLi5cbnRoaXMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd4IGF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIDAgICsgJywgJyArIGhlaWdodCAgKyAnKScpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcylcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAtOClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgOClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKSwgcm90YXRlKC00NSknKTtcbnRoaXMuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd5IGF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMCknKVxuICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuLi4uXG4iKSksbWR4KCJoMiIseyJpZCI6ImFkZGluZy1heGlzLWxhYmVscyJ9LCJBZGRpbmcgYXhpcyBsYWJlbHMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiLy8gd2l0aGluIHRoZSBwbG90IGZ1bmN0aW9uIGF0IHRoZSBib3R0b21cblxudGhpcy5zZWxlY3QoJy55LmF4aXMnKVxuICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgIC5hdHRyKCd4JywgMClcbiAgICAuYXR0cigneScsIDApXG4gICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC01MCwgJyArIGhlaWdodCAvIDIgKyAnKSByb3RhdGUoLTkwKScpXG4gICAgLnRleHQoJ1VuaXRzIHNvbGQnKTtcblxudGhpcy5zZWxlY3QoJy54LmF4aXMnKVxuICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgIC5hdHRyKCd4JywgMClcbiAgICAuYXR0cigneScsIDApXG4gICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB3aWR0aCAvIDIgKyAnLCA4MCkgcm90YXRlKC05MCknKVxuICAgIC50ZXh0KCdEb251dCBUeXBlJyk7XG4iKSksbWR4KCJoMiIseyJpZCI6InVwZGF0aW5nLXRoZS1wbG90LWZ1bmN0aW9uLXdpdGgtYmVzdC1wcmFjdGlzZXMifSwiVXBkYXRpbmcgdGhlIHBsb3QgZnVuY3Rpb24gd2l0aCBiZXN0IHByYWN0aXNlcyIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkFkZCBuZXcgcGFyYW1ldGVyIGVudHJpZXMuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJwbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIGF4aXM6IHtcbiAgICAgICAgeDogeEF4aXMsXG4gICAgICAgIHk6IHlBeGlzXG4gICAgfSxcbiAgICBncmlkbGluZXM6IHlHcmlkbGluZXNcbn1cbn0pXG4iKSksbWR4KCJociIsbnVsbCksbWR4KCJoMSIseyJpZCI6InNlY29udGlvbi01LW1ha2luZy10aGUtY2hhcnQtaW50ZXJhY3RpdmUifSwiU2Vjb250aW9uIDU6IE1ha2luZyB0aGUgQ2hhcnQgSW50ZXJhY3RpdmUiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJTb3J0aW5nIGRhdGEgdXNpbmcgdGhpbmdzIGxpa2UgYnV0dG9ucy4iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiU2ltaWxhcnkgdG8ganF1ZXJ5LCB3aXRoIGhhdmUgZDMgbWV0aG9kcyBsaWtlIFwib25cIiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJVc2luZyB0aGUgJysnIHByZWZpeCB3aWxsIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlciIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJUbyBzaG93IHVwZGF0ZWQgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJsaSJ9LCJkYXRhIiksIiBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGtub3cgYWJvdXQgdGhlIHBoYXNlcyAvLyBlbnRlcigpLCB1cGRhdGUoKSwgZXhpdCgpIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIndlIGVuc3VyZSB0aGlzIGNhbiBoYXBwZW4gYnkgc3BsaXR0aW5nIHRoZSBzZWxlY3RBbGwgZnVuY3Rpb24gd2hlcmUgdGhlIHVwZGF0ZWQgcGhhc2UgaXMgaW4gdGhlIGxhdHRlciBwYXJ0IC0gdGhlbiBpbiB0aGUgZXhpdCBwaGFzZSB3ZSBnZXQgcmlkIG9mIGFueSBlbGVtZW50cyB0aGF0IGFyZSBubyBsb25nZXIgYm91bmQhIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sInlvdSBtdXN0IHVwZGF0ZSB0aGUgZG9tYWlucyB3aGVuIHlvdSB1cGRhdGUgZGF0YSEiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIi8vIGRvIGZvciBhbGwgZWxlbWVudHMgd2Ugd2lzaCB0byByZW1vdmVcbnRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAuZXhpdCgpXG4gICAgLnJlbW92ZSgpO1xuIikpKTt9aWYodHlwZW9mIE1EWENvbnRlbnQhPT0ndW5kZWZpbmVkJyYmTURYQ29udGVudCYmTURYQ29udGVudD09PU9iamVjdChNRFhDb250ZW50KSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShNRFhDb250ZW50KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KE1EWENvbnRlbnQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6Ik1EWENvbnRlbnQiLGZpbGVuYW1lOiJtYW51YWwvSmF2YVNjcmlwdC9KUy1EMy1VZGVteS5tZCJ9fSk7fU1EWENvbnRlbnQuaXNNRFhDb21wb25lbnQ9dHJ1ZTs="},{"version":3,"sources":["/Users/okeeffe_d/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"4LAAA,cACE,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,GAAT,KAAoB,eAApB,CACA,cAGF,GAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAAAC,IAAI,QAAI,SAASC,CAAAA,mBAAT,CAA6BC,KAA7B,CAAoC,CAChEC,OAAO,CAACC,IAAR,CAAa,aAAeJ,IAAf,CAAsB,yEAAnC,EACA,MAAO,WAASE,KAAT,CAAP,CACD,CAHyB,EAA1B,CAKA,GAAMG,CAAAA,WAAW,CAAG,EAApB,CAGA,GAAMC,CAAAA,SAAS,CAAG,SAAlB,CACA,cAAe,SAASC,CAAAA,UAAT,MAGZ,IAFDC,CAAAA,UAEC,MAFDA,UAEC,CADEN,KACF,+CACD,MAAO,KAAC,SAAD,kBAAeG,WAAf,CAAgCH,KAAhC,EAAuC,UAAU,CAAEM,UAAnD,CAA+D,OAAO,CAAC,WAAvE,GACL,SAAQ,CACN,KAAM,8BADA,CAAR,gCADK,CAOL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,mXAAL,CAPK,CAgBL,cACE,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,mCAD+B,CAAvB,sCAApB,CAE8C,UAAI,UAAU,CAAC,IAAf,EAC1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,iCAD+B,CAAvB,mCAApB,CAD0C,CAI1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,4BAD+B,CAAvB,8BAApB,CAJ0C,CAO1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,oCAD+B,CAAvB,sCAApB,CAP0C,CAU1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,sBAD+B,CAAvB,wBAApB,CAV0C,CAa1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,oBAD+B,CAAvB,sBAApB,CAb0C,CAgB1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,mBAD+B,CAAvB,qBAApB,CAhB0C,CAmB1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,6BAD+B,CAAvB,+BAApB,CAnB0C,CAsB1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,qBAD+B,CAAvB,uBAApB,CAtB0C,CAyB1C,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,iDAD+B,CAAvB,mDAApB,CAzB0C,CAF9C,CADF,CAgCE,UAAI,UAAU,CAAC,IAAf,EAAoB,uBAAG,UAAU,CAAC,IAAd,EAAuB,CACvC,OAAQ,2CAD+B,CAAvB,8CAApB,CAhCF,CAhBK,CAuDL,cACE,UAAI,UAAU,CAAC,IAAf,kDADF,CAvDK,CA0DL,cA1DK,CA2DL,SAAQ,CACN,KAAM,wBADA,CAAR,8BA3DK,CA8DL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,qBADe,CAA3B,0NAAL,CA9DK,CA2EL,cA3EK,CA4EL,SAAQ,CACN,KAAM,YADA,CAAR,cA5EK,CA+EL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,kOAAL,CA/EK,CAwFL,cAxFK,CAyFL,SAAQ,CACN,KAAM,mBADA,CAAR,qBAzFK,CA4FL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,qBADe,CAA3B,ukBAAL,CA5FK,CAoHL,SAAQ,CACN,KAAM,cADA,CAAR,gBApHK,CAuHL,cACE,UAAI,UAAU,CAAC,IAAf,iDADF,CAvHK,CA0HL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,qBADe,CAA3B,wzBAAL,CA1HK,CAkKL,SAAQ,CACN,KAAM,kBADA,CAAR,oBAlKK,CAqKL,cACE,UAAI,UAAU,CAAC,IAAf,gCADF,CArKK,CAwKL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,cADe,CAA3B,mCAAL,CAxKK,CA8KL,yBAAgB,kBAAY,UAAU,CAAC,GAAvB,yBAAhB,8DAA8I,kBAAY,UAAU,CAAC,GAAvB,0BAA9I,8CA9KK,CA+KL,SAAQ,CACN,KAAM,0BADA,CAAR,4BA/KK,CAkLL,cACE,UAAI,UAAU,CAAC,IAAf,iDADF,CAlLK,CAqLL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,qBADe,CAA3B,69CAAL,CArLK,CAsPL,SAAQ,CACN,KAAM,kBADA,CAAR,oBAtPK,CAyPL,cACE,UAAI,UAAU,CAAC,IAAf,kHADF,CAzPK,CA4PL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,qBADe,CAA3B,0wDAAL,CA5PK,CA4UL,cA5UK,CA6UL,SAAQ,CACN,KAAM,kCADA,CAAR,qCA7UK,CAgVL,SAAQ,CACN,KAAM,gCADA,CAAR,kCAhVK,CAmVL,qEAnVK,CAoVL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,qBADe,CAA3B,yrEAAL,CApVK,CAsbL,SAAQ,CACN,KAAM,2BADA,CAAR,6BAtbK,CAybL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,25EAAL,CAzbK,CAkhBL,SAAQ,CACN,KAAM,mCADA,CAAR,qCAlhBK,CAqhBL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,owFAAL,CArhBK,CAynBL,SAAQ,CACN,KAAM,qBADA,CAAR,uBAznBK,CA4nBL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,qsDAAL,CA5nBK,CA0rBL,SAAQ,CACN,KAAM,mBADA,CAAR,qBA1rBK,CA6rBL,6CA7rBK,CA8rBL,cACE,UAAI,UAAU,CAAC,IAAf,mCADF,CAEE,UAAI,UAAU,CAAC,IAAf,oCAFF,CAGE,UAAI,UAAU,CAAC,IAAf,yBAA4C,kBAAY,UAAU,CAAC,IAAvB,WAA5C,WAHF,CA9rBK,CAmsBL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,wpGAAL,CAnsBK,CAmzBL,SAAQ,CACN,KAAM,kBADA,CAAR,oBAnzBK,CAszBL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,+VAAL,CAtzBK,CA8zBL,sFA9zBK,CA+zBL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,gHAAL,CA/zBK,CAs0BL,SAAQ,CACN,KAAM,4BADA,CAAR,8BAt0BK,CAy0BL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,whBAAL,CAz0BK,CAy1BL,SAAQ,CACN,KAAM,oBADA,CAAR,sBAz1BK,CA41BL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,0eAAL,CA51BK,CA82BL,SAAQ,CACN,KAAM,gDADA,CAAR,kDA92BK,CAi3BL,cACE,UAAI,UAAU,CAAC,IAAf,+BADF,CAj3BK,CAo3BL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,sIAAL,CAp3BK,CA83BL,cA93BK,CA+3BL,SAAQ,CACN,KAAM,0CADA,CAAR,6CA/3BK,CAk4BL,cACE,UAAI,UAAU,CAAC,IAAf,4CADF,CAEE,UAAI,UAAU,CAAC,IAAf,yDAFF,CAGE,UAAI,UAAU,CAAC,IAAf,6DAHF,CAIE,UAAI,UAAU,CAAC,IAAf,qBAAwC,kBAAY,UAAU,CAAC,IAAvB,SAAxC,2EAJF,CAKE,UAAI,UAAU,CAAC,IAAf,8LALF,CAME,UAAI,UAAU,CAAC,IAAf,sDANF,CAl4BK,CA04BL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,EAA3B,4HAAL,CA14BK,CAAP,CAi5BD,C,4QAEDD,UAAU,CAACE,cAAX,CAA4B,IAA5B","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h2 {...{\n      \"id\": \"reading-the-d3-documentation\"\n    }}>{`Reading the D3 Documentation`}</h2>\n    {\n      /* TOC */\n    }\n    <pre><code parentName=\"pre\" {...{}}>{`- [Reading the D3 Documentation](#reading-the-d3-documentation)\n- [map() and filter() methods](#map-and-filter-methods)\n- [d3 methods](#d3-methods)\n- [Programmatic SVGs](#programmatic-svgs)\n- [Scaling Data](#scaling-data)\n- [Styling with CSS](#styling-with-css)\n- [Adding Text to the chart](#adding-text-to-the-chart)\n- [Using SVG groups](#using-svg-groups)\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#section-4-making-a-complex-chart\"\n        }}>{`Section 4: Making a Complex Chart`}</a><ul parentName=\"li\">\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#working-with-arrays-of-objects\"\n            }}>{`Working with Arrays of Objects`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#creating-an-ordinal-scale\"\n            }}>{`Creating an Ordinal Scale`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#setting-colour-with-colour-scales\"\n            }}>{`Setting colour with colour scales`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-x-and-y-axis\"\n            }}>{`Adding X and Y axis`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#flipping-the-axes\"\n            }}>{`Flipping the axes`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-gridlines\"\n            }}>{`Adding Gridlines`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#rotating-the-x-axis-titles\"\n            }}>{`Rotating the X axis titles`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-axis-labels\"\n            }}>{`Adding axis labels`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#updating-the-plot-function-with-best-practises\"\n            }}>{`Updating the plot function with best practises`}</a></li>\n        </ul></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#secontion-5-making-the-chart-interactive\"\n        }}>{`Secontion 5: Making the Chart Interactive`}</a></li>\n    </ul>\n    {\n      /* /TOC */\n    }\n    <ul>\n      <li parentName=\"ul\">{`API Documentation is a great link to bookmark`}</li>\n    </ul>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"map-and-filter-methods\"\n    }}>{`map() and filter() methods`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [123, 52, 46, 30, 4];\n\nconst results = data.filter((entry) => {\n    return entry > 50;\n});\n\nconst mapping = data.map((entry) => {\n    console.log(entry.key);\n    console.log(entry.value);\n});\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"d3-methods\"\n    }}>{`d3 methods`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`const example = d3.min(data);\nconsole.log(example);       // values returned\n\nconst dataLoHiValue = d3.extent(data);  // return min/max as array\n\nvar dictMinValue = d3.min(dounts, (d, i) {\n    return d.value;\n});\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"programmatic-svgs\"\n    }}>{`Programmatic SVGs`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132,71,337,93,78,43,20,16,30,8,17,21];\nlet svg = d3.select('body').append('svg')\n                .attr('id', 'chart')\n                .attr('height', 450)\n                .attr('width', 800);\n\n// creating the bars\n// vertical bar graph\nsvg.selectAll('.bar')\n    .data(data)\n    .enter()                // enter phase\n    .append('rect')\n    .attr('class', 'bar')   // for future selections\n    .attr('x', 0)\n    .attr('y', (d i) => {\n        return i * 20;\n    })\n    .attr('width', (d, i) => {\n        return d;\n    })\n    .attr('height', 19);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"scaling-data\"\n    }}>{`Scaling Data`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Creating scaling functions for both x and y.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, w]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, h]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\n// creating the bars\n// vertical bar graph\nsvg\n    .selectAll('.bar')\n    .data(data)\n    .enter() // enter phase\n    .append('rect')\n    .attr('class', 'bar') // for future selections\n    .attr('x', 0)\n    .attr('y', (d, i) => {\n        return y(i);\n    })\n    .attr('width', (d, i) => {\n        return x(d); // x() does the scaling\n    })\n    .attr('height', (d, i) => {\n        return y(1) - 1;\n    });\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"styling-with-css\"\n    }}>{`Styling with CSS`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Getting rid of the aliasing`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-css\"\n      }}>{`.bar {\n    fill: purple;\n}\n`}</code></pre>\n    <p>{`Not that `}<inlineCode parentName=\"p\">{`attr('class', 'bar')`}</inlineCode>{` will manually reset the class value, so you can also use `}<inlineCode parentName=\"p\">{`.classed('bar', true)`}</inlineCode>{` - true to add the class, false to remove.`}</p>\n    <h2 {...{\n      \"id\": \"adding-text-to-the-chart\"\n    }}>{`Adding Text to the chart`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Creating scaling functions for both x and y.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, w]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, h]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d;\n        });\n}\n\n// first arg will be what is referenced by \"this\"\nplot.call(svg, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"using-svg-groups\"\n    }}>{`Using SVG groups`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`SVG groups are like a div that are a convenience element to allow children to be moved and affected together.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, width]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, height]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\nlet chart = svg\n    .append('g')\n    .classed('display', true)\n    .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d;\n        });\n}\n\n// first arg will be what is referenced by \"this\"\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <hr></hr>\n    <h1 {...{\n      \"id\": \"section-4-making-a-complex-chart\"\n    }}>{`Section 4: Making a Complex Chart`}</h1>\n    <h2 {...{\n      \"id\": \"working-with-arrays-of-objects\"\n    }}>{`Working with Arrays of Objects`}</h2>\n    <p>{`If working with a dict, we need an accessor function!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [\n    { key: 'Glazed', value: 132 },\n    { key: 'Jelly', value: 71 },\n    { key: 'Holes', value: 337 },\n    { key: 'Sprinkles', value: 93 },\n    { key: 'Crumb', value: 78 },\n    { key: 'Chocolate', value: 43 },\n    { key: 'Coconut', value: 20 },\n    { key: 'Cream', value: 16 },\n    { key: 'Cruller', value: 30 },\n    { key: 'Éclair', value: 8 },\n    { key: 'Fritter', value: 17 },\n    { key: 'Bearclaw', value: 21 }\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale\n    .linear()\n    .domain([\n        0,\n        d3.max(data, (d) => {\n            return d.value;\n        })\n    ])\n    .range([0, width]);\n\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, height]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('width', 800)\n    .attr('height', 420)\n    .attr('id', 'chart');\nlet chart = svg\n    .append('g')\n    .classed('display', true)\n    .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"creating-an-ordinal-scale\"\n    }}>{`Creating an Ordinal Scale`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"Éclair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n    })])\n        .range([0, width]);\nvar y = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"setting-colour-with-colour-scales\"\n    }}>{`Setting colour with colour scales`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"Éclair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n    })])\n        .range([0, width]);\nvar y = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\n// alter colours using linear scale\nlet linearColorScale = d3.scale.linear()\n                        .domain([0, data.length])\n                        .range(['#572500', '#F68026']);\n\n// ordinal for distinct colours\nlet ordinalColorScale = d3.scale.category20();\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-x-and-y-axis\"\n    }}>{`Adding X and Y axis`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`// after the colour scales\n\nlet xAxis = d3.svg.axis()           // svg portion of the d3 library\n                .scale(x)\n                .orient('bottom');\n\nlet yAxis = d3.svg.axis()\n                .scale(y)\n                .orient('left');\n\n...\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n    this.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis);\n    this.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"flipping-the-axes\"\n    }}>{`Flipping the axes`}</h2>\n    <p>{`How to create a column chart?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`height needs to take an offset`}</li>\n      <li parentName=\"ul\">{`other values essentially invert`}</li>\n      <li parentName=\"ul\">{`text anchor will be `}<inlineCode parentName=\"li\">{`middle`}</inlineCode>{` in css`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"Éclair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\nlet y = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n        })])\n        .range([height, 0]);    // IMPORTANT CHANGE FROM [0, width]\n\n// alter colours using linear scale\nlet linearColorScale = d3.scale.linear()\n                        .domain([0, data.length])\n                        .range(['#572500', '#F68026']);\n\n// ordinal for distinct colours\nlet ordinalColorScale = d3.scale.category20();\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', (d, i) => {\n            return x(d.key);\n        })\n        .attr('y', (d, i) => {\n            return y(d.value);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return x.rangeBand();\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n\n        this.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis);\n        this.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-gridlines\"\n    }}>{`Adding Gridlines`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var yGridlines = d3.svg.axis()              // create another \"axis\"\n                    .scale(y)\n                    .tickSize(-width, 0, 0)             // used to adjust the axis\n                    .tickFormat('')\n                    .orient('left');\n\n// add these grid lines with the call function at the start of the plot function\n`}</code></pre>\n    <p>{`The grid lines also need to be styled! Hit up the CSS file to do this.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`.gridline path,\n.gridline line {\n    fill: none;\n    color: blue;\n    shape-rendering: crispEdges;\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"rotating-the-x-axis-titles\"\n    }}>{`Rotating the X axis titles`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`...\nthis.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis)\n                .selectAll('text')\n                    .style('text-anchor', 'end')\n                    .attr('dx', -8)\n                    .attr('dy', 8)\n                    .attr('transform', 'translate(0,0), rotate(-45)');\nthis.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n...\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-axis-labels\"\n    }}>{`Adding axis labels`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`// within the plot function at the bottom\n\nthis.select('.y.axis')\n    .append('text')\n    .attr('x', 0)\n    .attr('y', 0)\n    .style('text-anchor', 'middle')\n    .attr('transform', 'translate(-50, ' + height / 2 + ') rotate(-90)')\n    .text('Units sold');\n\nthis.select('.x.axis')\n    .append('text')\n    .attr('x', 0)\n    .attr('y', 0)\n    .style('text-anchor', 'middle')\n    .attr('transform', 'translate(' + width / 2 + ', 80) rotate(-90)')\n    .text('Donut Type');\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"updating-the-plot-function-with-best-practises\"\n    }}>{`Updating the plot function with best practises`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Add new parameter entries.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`plot.call(chart, {\n    data: data,\n    axis: {\n        x: xAxis,\n        y: yAxis\n    },\n    gridlines: yGridlines\n}\n})\n`}</code></pre>\n    <hr></hr>\n    <h1 {...{\n      \"id\": \"secontion-5-making-the-chart-interactive\"\n    }}>{`Secontion 5: Making the Chart Interactive`}</h1>\n    <ul>\n      <li parentName=\"ul\">{`Sorting data using things like buttons.`}</li>\n      <li parentName=\"ul\">{`Similary to jquery, with have d3 methods like \"on\"`}</li>\n      <li parentName=\"ul\">{`Using the '+' prefix will convert the string to a number`}</li>\n      <li parentName=\"ul\">{`To show updated `}<inlineCode parentName=\"li\">{`data`}</inlineCode>{` changes, we need to know about the phases // enter(), update(), exit()`}</li>\n      <li parentName=\"ul\">{`we ensure this can happen by splitting the selectAll function where the updated phase is in the latter part - then in the exit phase we get rid of any elements that are no longer bound!`}</li>\n      <li parentName=\"ul\">{`you must update the domains when you update data!`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`// do for all elements we wish to remove\nthis.selectAll('.bar')\n    .data(params.data)\n    .exit()\n    .remove();\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}