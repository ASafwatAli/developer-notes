{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/R/R-Intermediate.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/R/R-Intermediate.md","mtime":1579078174019},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJyZWxhdGlvbmFsLW9wZXJhdG9ycyJ9LCJSZWxhdGlvbmFsIE9wZXJhdG9ycyIpLG1keCgicCIsbnVsbCwiUi5PLidzIGFyZSBvcGVyYXRvcnMgdGhhdCBsZXQgdXMgc2VlIGhvdyBvbmUgUiBvYmplY3QgcmVsYXRlcyB0byBhbm90aGVyIGVnLiBlcXVhbGl0eSBldGMiKSxtZHgoInAiLG51bGwsIllvdSBjYW4gY29tcGFyZSBhcnJheXMsIG1hdHJpY2VzLCBsaXN0cyBhbmQgb3RoZXIgdHlwZXMgb2YgZGF0YSBzdHJ1Y3R1cmVzLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIEVxdWFsaXR5ID09XG4+IFRSVUUgPT0gVFJVRVxuWzFdIFRSVUVcblxuIyBJbmVxdWFsaXR5ICE9XG4jIExULCBHVCA+IGFuZCA8XG5cbkFscGhhYmV0aWNhbCBvcmRlciB3aXRoIHJlbGF0ZSB0byBhbHBoYWJldCBhbmQgVC9GIHdpbGwgZ28gMS8wXG5cbiMgUmVsYXRpb25hbCBPcGVyYXRvcnMgYW5kIFZlY3RvcnNcbj4gZXhhbXBsZSA8LSBjKDEyLDQsNSwzLDUpXG4+IGV4YW1wbGVcblsxXSAxMiA0IDUgMyA1XG4+IGV4YW1wbGUgPiAxMFxuWzFdIFRSVUUgRkFMU0UgRkFMU0UgRkFMU0UgRkFMU0VcblxuIyBDb21wYXJpc29uIG9mIGxvZ2ljYWxzXG4+IFRSVUUgPT0gRkFMU0VcblsxXSBGQUxTRVxuPlxuIyBDb21wYXJpc29uIG9mIG51bWVyaWNzXG4+IC02ICogMTQgIT0gMTcgLSAxMDFcblsxXSBGQUxTRVxuPlxuIyBDb21wYXJpc29uIG9mIGNoYXJhY3RlciBzdHJpbmdzXG4+IFwidXNlUlwiID09IFwidXNlclwiXG5bMV0gRkFMU0Vcbj5cbiMgQ29tcGFyZSBhIGxvZ2ljYWwgd2l0aCBhIG51bWVyaWNcbj4gVFJVRSA9PSAxXG5bMV0gVFJVRVxuIikpLG1keCgiaDMiLHsiaWQiOiJncmVhdGVyLXRoYW4tb3ItbGVzcy10aGFuIn0sIkdyZWF0ZXIgdGhhbiBvciBsZXNzIHRoYW4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBDb21wYXJpc29uIG9mIG51bWVyaWNzXG4+IC02ICogNSArIDIgPj0gLTEwICsgMVxuWzFdIEZBTFNFXG4+XG4jIENvbXBhcmlzb24gb2YgY2hhcmFjdGVyIHN0cmluZ3Ncbj4gXCJyYWluaW5nXCIgPD0gXCJyYWluaW5nIGRvZ3NcIlxuWzFdIFRSVUVcbj5cbiMgQ29tcGFyaXNvbiBvZiBsb2dpY2Fsc1xuPiBUUlVFID4gRkFMU0VcblsxXSBUUlVFXG4iKSksbWR4KCJoMyIseyJpZCI6ImNvbXBhcmUtdmVjdG9ycyJ9LCJDb21wYXJlIFZlY3RvcnMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBsaW5rZWRpbiA8LSBjKDE2LCA5LCAxMywgNSwgMiwgMTcsIDE0KVxuPiBmYWNlYm9vayA8LSBjKDE3LCA3LCA1LCAxNiwgOCwgMTMsIDE0KVxuPlxuIyBQb3B1bGFyIGRheXNcbj4gbGlua2VkaW4gPiAxNVxuWzFdICBUUlVFIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFICBUUlVFIEZBTFNFXG4+XG4jIFF1aWV0IGRheXNcbj4gbGlua2VkaW4gPD0gNVxuWzFdIEZBTFNFIEZBTFNFIEZBTFNFICBUUlVFICBUUlVFIEZBTFNFIEZBTFNFXG4+XG4jIExpbmtlZEluIG1vcmUgcG9wdWxhciB0aGFuIEZhY2Vib29rXG4+IGxpbmtlZGluID4gZmFjZWJvb2tcblsxXSBGQUxTRSAgVFJVRSAgVFJVRSBGQUxTRSBGQUxTRSAgVFJVRSBGQUxTRVxuIikpLG1keCgiaDMiLHsiaWQiOiJjb21wYXJlLW1hdHJpY2VzIn0sIkNvbXBhcmUgTWF0cmljZXMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBsaW5rZWRpbiA8LSBjKDE2LCA5LCAxMywgNSwgMiwgMTcsIDE0KVxuPiBmYWNlYm9vayA8LSBjKDE3LCA3LCA1LCAxNiwgOCwgMTMsIDE0KVxuPiB2aWV3cyA8LSBtYXRyaXgoYyhsaW5rZWRpbiwgZmFjZWJvb2spLCBucm93ID0gMiwgYnlyb3cgPSBUUlVFKVxuPlxuIyBXaGVuIGRvZXMgdmlld3MgZXF1YWwgMTM/XG4+IHZpZXdzID09IDEzXG4gICAgICBbLDFdICBbLDJdICBbLDNdICBbLDRdICBbLDVdICBbLDZdICBbLDddXG5bMSxdIEZBTFNFIEZBTFNFICBUUlVFIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFXG5bMixdIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFICBUUlVFIEZBTFNFXG4+XG4jIFdoZW4gaXMgdmlld3MgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDE0P1xuPiB2aWV3cyA8PSAxNFxuICAgICAgWywxXSBbLDJdIFssM10gIFssNF0gWyw1XSAgWyw2XSBbLDddXG5bMSxdIEZBTFNFIFRSVUUgVFJVRSAgVFJVRSBUUlVFIEZBTFNFIFRSVUVcblsyLF0gRkFMU0UgVFJVRSBUUlVFIEZBTFNFIFRSVUUgIFRSVUUgVFJVRVxuIikpLG1keCgiaDMiLHsiaWQiOiJsb2dpY2FsLW9wZXJhdG9ycyJ9LCJMb2dpY2FsIE9wZXJhdG9ycyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJ4IDwtIDEyXG54ID4gNSAmIHggPCAxNSAgIyBldmFsdWF0ZXMgdG8gVFJVRVxuXG4mICAgLy8gYW5kXG58ICAgLy8gb3JcbiEgICAvLyBub3RcblxuIyBmb3IgdmVjdG9yc1xuXG4mJiAgICAgIC8vIG9ubHkgZXZhbHVhdGVzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSB2ZWN0b3Jcbnx8ICAgICAgLy8gb25seSBldmFsdWF0ZXMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHZlY3RvclxuXG4vLyBleGFtcGxlc1xuXG4+IGxpbmtlZGluIDwtIGMoMTYsIDksIDEzLCA1LCAyLCAxNywgMTQpXG4+IGxhc3QgPC0gdGFpbChsaW5rZWRpbiwgMSlcbj5cbiMgSXMgbGFzdCB1bmRlciA1IG9yIGFib3ZlIDEwP1xuPiBsYXN0IDwgNSB8IGxhc3QgPiAxMFxuWzFdIFRSVUVcbj5cbiMgSXMgbGFzdCBiZXR3ZWVuIDE1IChleGNsdXNpdmUpIGFuZCAyMCAoaW5jbHVzaXZlKT9cbj4gbGFzdCA+IDE1ICYgbGFzdCA8PSAyMFxuWzFdIEZBTFNFXG5cbi8vIHZlY3RvciBleGFtcGxlc1xuXG4jIGxpbmtlZGluIGV4Y2VlZHMgMTAgYnV0IGZhY2Vib29rIGJlbG93IDEwXG4+IGxpbmtlZGluID4gMTAgJiBmYWNlYm9vayA8IDEwXG5bMV0gRkFMU0UgRkFMU0UgIFRSVUUgRkFMU0UgRkFMU0UgRkFMU0UgRkFMU0Vcbj5cbiMgV2hlbiB3ZXJlIG9uZSBvciBib3RoIHZpc2l0ZWQgYXQgbGVhc3QgMTIgdGltZXM/XG4+IGxpbmtlZGluID49IDEyIHwgZmFjZWJvb2sgPj0gMTJcblsxXSAgVFJVRSBGQUxTRSAgVFJVRSAgVFJVRSBGQUxTRSAgVFJVRSAgVFJVRVxuPlxuIyBXaGVuIGlzIHZpZXdzIGJldHdlZW4gMTEgKGV4Y2x1c2l2ZSkgYW5kIDE0IChpbmNsdXNpdmUpP1xuPiB2aWV3cyA+IDExICYgdmlld3MgPD0gMTRcbiAgICAgIFssMV0gIFssMl0gIFssM10gIFssNF0gIFssNV0gIFssNl0gWyw3XVxuWzEsXSBGQUxTRSBGQUxTRSAgVFJVRSBGQUxTRSBGQUxTRSBGQUxTRSBUUlVFXG5bMixdIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFIEZBTFNFICBUUlVFIFRSVUVcblxuLy8gdG91Z2hlciBleGVyY2lzZXNcblxuIyBTZWxlY3QgdGhlIHNlY29uZCBjb2x1bW4sIG5hbWVkIGRheTIsIGZyb20gbGlfZGY6IHNlY29uZFxuPiBzZWNvbmQgPC0gbGlfZGZbXCJkYXkyXCJdXG4+XG4jIEJ1aWxkIGEgbG9naWNhbCB2ZWN0b3IsIFRSVUUgaWYgdmFsdWUgaW4gc2Vjb25kIGlzIGV4dHJlbWU6IGV4dHJlbWVzXG4+IGV4dHJlbWVzIDwtIGMoc2Vjb25kID4gMjUgfCBzZWNvbmQgPCA1KVxuPlxuIyBDb3VudCB0aGUgbnVtYmVyIG9mIFRSVUVzIGluIGV4dHJlbWVzXG4+IHN1bShleHRyZW1lcyA9PSBUUlVFKVxuWzFdIDE2XG4+XG4jIFNvbHZlIGl0IHdpdGggYSBvbmUtbGluZXJcbj4gc3VtKGxpX2RmW1wiZGF5MlwiXSA+IDI1IHwgbGlfZGZbXCJkYXkyXCJdIDwgNSlcblsxXSAxNlxuIikpLG1keCgiaDMiLHsiaWQiOiJjb25kaXRpb25hbC1zdGF0ZW1lbnRzIn0sIkNvbmRpdGlvbmFsIFN0YXRlbWVudHMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiaWYgKGNvbmRpdGlvbikge1xuICAgIC8vIGV4cHJcbn1cblxueCA8LSAzXG5cbmlmICh4IDwgMCkge1xuICAgIHByaW50KFwieCBpcyBuZWdhdGl2ZVwiKVxufSBlbHNlIGlmICh4IDwgMykge1xuICAgIHByaW50KFwiZWxzZSBpZiBleGVjXCIpXG59IGVsc2Uge1xuICAgIHByaW50KFwieCBpcyBwb3NpdGl2ZVwiKVxufVxuXG4jIFZhcmlhYmxlcyByZWxhdGVkIHRvIHlvdXIgbGFzdCBkYXkgb2YgcmVjb3JkaW5nc1xuPiBtZWRpdW0gPC0gXCJMaW5rZWRJblwiXG4+IG51bV92aWV3cyA8LSAxNFxuPlxuIyBFeGFtaW5lIHRoZSBpZiBzdGF0ZW1lbnQgZm9yIG1lZGl1bVxuPiBpZiAobWVkaXVtID09IFwiTGlua2VkSW5cIikge1xuICAgIHByaW50KFwiU2hvd2luZyBMaW5rZWRJbiBpbmZvcm1hdGlvblwiKVxuICB9XG5bMV0gXCJTaG93aW5nIExpbmtlZEluIGluZm9ybWF0aW9uXCJcbj5cbiMgV3JpdGUgdGhlIGlmIHN0YXRlbWVudCBmb3IgbnVtX3ZpZXdzXG4+IGlmIChudW1fdmlld3MgPiAxNSkge1xuICAgIHByaW50KFwiWW91J3JlIHBvcHVsYXIhXCIpXG4gIH1cbj5cblxuIyBWYXJpYWJsZXMgcmVsYXRlZCB0byB5b3VyIGxhc3QgZGF5IG9mIHJlY29yZGluZ3Ncbj4gbGkgPC0gMTVcbj4gZmIgPC0gOVxuPlxuIyBDb2RlIHRoZSBjb250cm9sLWZsb3cgY29uc3RydWN0XG4+IGlmIChsaSA+PSAxNSAmIGZiID49IDE1KSB7XG4gICAgc21zIDwtIDIgKiAobGkgKyBmYilcbiAgfSBlbHNlIGlmIChsaSA8IDEwICYgZmIgPCAxMCkge1xuICAgIHNtcyA8LSAwLjUgKiAobGkgKyBmYilcbiAgfSBlbHNlIHtcbiAgICBzbXMgPC0gbGkgKyBmYlxuICB9XG4+XG4jIFByaW50IHRoZSByZXN1bHRpbmcgc21zIHRvIHRoZSBjb25zb2xlXG4+IHNtc1xuWzFdIDI0XG4iKSksbWR4KCJociIsbnVsbCksbWR4KCJoMiIseyJpZCI6Imxvb3BzIn0sIkxvb3BzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIndoaWxlIChjb25kaXRpb24pIHtcbiAgLy8gcnVuIHRoZSBleHBcbn1cblxuY3RyIDwtIDFcblxud2hpbGUgKGN0ciA8PSA3KSB7XG4gIC8vIHJ1biB0aGUgZXhwcmVzc2lvblxuICBjdHIgPC0gY3RyICsgMVxufVxuIikpLG1keCgicCIsbnVsbCwiTWFrZSBzdXJlIHRoYXQgdGhlIGNvbmRpdGlvbiBmb3IgYSB3aGlsZSBsb29wIGJlY2F1c2UgZmFsc2UgYXQgc29tZSBzdGFnZS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBQcmludCBvdXQgdGhlIHNwZWVkIHZhcmlhYmxlXG4+IHNwZWVkXG5bMV0gNjRcbiMgSW5pdGlhbGl6ZSB0aGUgc3BlZWQgdmFyaWFibGVcbj4gc3BlZWQgPC0gNjRcbj5cbiMgQ29kZSB0aGUgd2hpbGUgbG9vcFxuPiB3aGlsZSAoc3BlZWQgPiAzMCkge1xuICAgIHByaW50KFwiU2xvdyBkb3duIVwiKVxuICAgIHNwZWVkIDwtIHNwZWVkIC03XG4gIH1cblsxXSBcIlNsb3cgZG93biFcIlxuWzFdIFwiU2xvdyBkb3duIVwiXG5bMV0gXCJTbG93IGRvd24hXCJcblsxXSBcIlNsb3cgZG93biFcIlxuWzFdIFwiU2xvdyBkb3duIVwiXG4+XG4jIFByaW50IG91dCB0aGUgc3BlZWQgdmFyaWFibGVcbj4gc3BlZWRcblsxXSAyOVxuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIEluaXRpYWxpemUgdGhlIHNwZWVkIHZhcmlhYmxlXG4+IHNwZWVkIDwtIDY0XG4+XG4jIEV4dGVuZC9hZGFwdCB0aGUgd2hpbGUgbG9vcFxuPiB3aGlsZSAoc3BlZWQgPiAzMCkge1xuICAgIHByaW50KHBhc3RlKFwiWW91ciBzcGVlZCBpc1wiLHNwZWVkKSlcbiAgICBpZiAoc3BlZWQgPiA0OCkge1xuICAgICAgcHJpbnQoXCJTbG93IGRvd24gYmlnIHRpbWUhXCIpXG4gICAgICBzcGVlZCA8LSBzcGVlZCAtIDExXG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KFwiU2xvdyBkb3duIVwiKVxuICAgICAgc3BlZWQgPC0gc3BlZWQgLSA2XG4gICAgfVxuICB9XG5bMV0gXCJZb3VyIHNwZWVkIGlzIDY0XCJcblsxXSBcIlNsb3cgZG93biBiaWcgdGltZSFcIlxuWzFdIFwiWW91ciBzcGVlZCBpcyA1M1wiXG5bMV0gXCJTbG93IGRvd24gYmlnIHRpbWUhXCJcblsxXSBcIllvdXIgc3BlZWQgaXMgNDJcIlxuWzFdIFwiU2xvdyBkb3duIVwiXG5bMV0gXCJZb3VyIHNwZWVkIGlzIDM2XCJcblsxXSBcIlNsb3cgZG93biFcIlxuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIEluaXRpYWxpemUgdGhlIHNwZWVkIHZhcmlhYmxlXG4+IHNwZWVkIDwtIDg4XG4+XG4+IHdoaWxlIChzcGVlZCA+IDMwKSB7XG4gICAgcHJpbnQocGFzdGUoXCJZb3VyIHNwZWVkIGlzXCIsIHNwZWVkKSlcblxuICAgICMgQnJlYWsgdGhlIHdoaWxlIGxvb3Agd2hlbiBzcGVlZCBleGNlZWRzIDgwXG4gICAgaWYgKHNwZWVkID4gODApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKHNwZWVkID4gNDgpIHtcbiAgICAgIHByaW50KFwiU2xvdyBkb3duIGJpZyB0aW1lIVwiKVxuICAgICAgc3BlZWQgPC0gc3BlZWQgLSAxMVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmludChcIlNsb3cgZG93biFcIilcbiAgICAgIHNwZWVkIDwtIHNwZWVkIC0gNlxuICAgIH1cbiAgfVxuWzFdIFwiWW91ciBzcGVlZCBpcyA4OFwiXG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgSW5pdGlhbGl6ZSBpIGFzIDFcbj4gaSA8LSAxXG4+XG4jIENvZGUgdGhlIHdoaWxlIGxvb3Bcbj4gd2hpbGUgKGkgPD0gMTApIHtcbiAgICBwcmludCgzICogaSlcbiAgICBpZiAoMyppICUlIDggPT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaSA8LSBpICsgMVxuICB9XG5bMV0gM1xuWzFdIDZcblsxXSA5XG5bMV0gMTJcblsxXSAxNVxuWzFdIDE4XG5bMV0gMjFcblsxXSAyNFxuIikpLG1keCgiaDMiLHsiaWQiOiJmb3ItbG9vcCJ9LCJGb3IgTG9vcCIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFRoZSBsaW5rZWRpbiB2ZWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGZvciB5b3Vcbj4gbGlua2VkaW4gPC0gYygxNiwgOSwgMTMsIDUsIDIsIDE3LCAxNClcbj5cbiMgTG9vcCB2ZXJzaW9uIDFcbj4gZm9yIChsIGluIGxpbmtlZGluKSB7XG4gICAgcHJpbnQobClcbiAgfVxuWzFdIDE2XG5bMV0gOVxuWzFdIDEzXG5bMV0gNVxuWzFdIDJcblsxXSAxN1xuWzFdIDE0XG4+XG4+XG4jIExvb3AgdmVyc2lvbiAyXG4+IGZvciAoaSBpbiAxOmxlbmd0aChsaW5rZWRpbikpIHtcbiAgICBwcmludChsaW5rZWRpbltpXSlcbiAgfVxuWzFdIDE2XG5bMV0gOVxuWzFdIDEzXG5bMV0gNVxuWzFdIDJcblsxXSAxN1xuWzFdIDE0XG4iKSksbWR4KCJoMyIseyJpZCI6Imxvb3Bpbmctb3Zlci1hLWxpc3QifSwiTG9vcGluZyBPdmVyIGEgTGlzdCIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJwcmltZXNfbGlzdCA8LSBsaXN0KDIsIDMsIDUsIDcsIDExLCAxMylcblxuIyBsb29wIHZlcnNpb24gMVxuZm9yIChwIGluIHByaW1lc19saXN0KSB7XG4gIHByaW50KHApXG59XG5cbiMgbG9vcCB2ZXJzaW9uIDJcbmZvciAoaSBpbiAxOmxlbmd0aChwcmltZXNfbGlzdCkpIHtcbiAgcHJpbnQocHJpbWVzX2xpc3RbW2ldXSlcbn1cbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBUaGUgbnljIGxpc3QgaXMgYWxyZWFkeSBzcGVjaWZpZWRcbj4gbnljIDwtIGxpc3QocG9wID0gODQwNTgzNyxcbiAgICAgICAgICAgICAgYm9yb3VnaHMgPSBjKFwiTWFuaGF0dGFuXCIsIFwiQnJvbnhcIiwgXCJCcm9va2x5blwiLCBcIlF1ZWVuc1wiLCBcIlN0YXRlbiBJc2xhbmRcIiksXG4gICAgICAgICAgICAgIGNhcGl0YWwgPSBGQUxTRSlcbj5cbiMgTG9vcCB2ZXJzaW9uIDFcbj4gZm9yIChuIGluIG55Yykge1xuICAgIHByaW50KG4pXG4gIH1cblsxXSA4NDA1ODM3XG5bMV0gXCJNYW5oYXR0YW5cIiAgICAgXCJCcm9ueFwiICAgICAgICAgXCJCcm9va2x5blwiICAgICAgXCJRdWVlbnNcIlxuWzVdIFwiU3RhdGVuIElzbGFuZFwiXG5bMV0gRkFMU0Vcbj5cbiMgTG9vcCB2ZXJzaW9uIDJcbj4gZm9yIChpIGluIDE6bGVuZ3RoKG55YykpIHtcbiAgICBwcmludChueWNbW2ldXSlcbiAgfVxuWzFdIDg0MDU4MzdcblsxXSBcIk1hbmhhdHRhblwiICAgICBcIkJyb254XCIgICAgICAgICBcIkJyb29rbHluXCIgICAgICBcIlF1ZWVuc1wiXG5bNV0gXCJTdGF0ZW4gSXNsYW5kXCJcblsxXSBGQUxTRVxuIikpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiSG93IGFib3V0IHByaW50aW5nIG92ZXIgYSBtYXRyaXg/IikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFRoZSB0aWMtdGFjLXRvZSBtYXRyaXggdHR0IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBmb3IgeW91XG4+XG4jIGRlZmluZSB0aGUgZG91YmxlIGZvciBsb29wXG4+IGZvciAoaSBpbiAxOm5yb3codHR0KSkge1xuICAgIGZvciAoaiBpbiAxOm5jb2wodHR0KSkge1xuICAgICAgcHJpbnQocGFzdGUoXCJPbiByb3dcIiwgaSwgXCJhbmQgY29sdW1uXCIsIGosIFwidGhlIGJvYXJkIGNvbnRhaW5zXCIsIHR0dFtpLGpdKSlcbiAgICB9XG4gIH1cblsxXSBcIk9uIHJvdyAxIGFuZCBjb2x1bW4gMSB0aGUgYm9hcmQgY29udGFpbnMgT1wiXG5bMV0gXCJPbiByb3cgMSBhbmQgY29sdW1uIDIgdGhlIGJvYXJkIGNvbnRhaW5zIE5BXCJcblsxXSBcIk9uIHJvdyAxIGFuZCBjb2x1bW4gMyB0aGUgYm9hcmQgY29udGFpbnMgWFwiXG5bMV0gXCJPbiByb3cgMiBhbmQgY29sdW1uIDEgdGhlIGJvYXJkIGNvbnRhaW5zIE5BXCJcblsxXSBcIk9uIHJvdyAyIGFuZCBjb2x1bW4gMiB0aGUgYm9hcmQgY29udGFpbnMgT1wiXG5bMV0gXCJPbiByb3cgMiBhbmQgY29sdW1uIDMgdGhlIGJvYXJkIGNvbnRhaW5zIE9cIlxuWzFdIFwiT24gcm93IDMgYW5kIGNvbHVtbiAxIHRoZSBib2FyZCBjb250YWlucyBYXCJcblsxXSBcIk9uIHJvdyAzIGFuZCBjb2x1bW4gMiB0aGUgYm9hcmQgY29udGFpbnMgTkFcIlxuWzFdIFwiT24gcm93IDMgYW5kIGNvbHVtbiAzIHRoZSBib2FyZCBjb250YWlucyBYXCJcbiIpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIk1peGluZyB0b2dldGhlciBDb250cm9sIEZsb3cgYW5kIExvb3BzIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFRoZSBsaW5rZWRpbiB2ZWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGZvciB5b3Vcbj4gbGlua2VkaW4gPC0gYygxNiwgOSwgMTMsIDUsIDIsIDE3LCAxNClcbj5cbiMgQ29kZSB0aGUgZm9yIGxvb3Agd2l0aCBjb25kaXRpb25hbHNcbj4gZm9yIChsaSBpbiBsaW5rZWRpbikge1xuICAgIGlmIChsaSA+IDEwKSB7XG4gICAgICBwcmludChcIllvdSdyZSBwb3B1bGFyIVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmludChcIkJlIG1vcmUgdmlzaWJsZSFcIilcbiAgICB9XG4gICAgcHJpbnQobGkpXG4gIH1cblsxXSBcIllvdSdyZSBwb3B1bGFyIVwiXG5bMV0gMTZcblsxXSBcIkJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIDlcblsxXSBcIllvdSdyZSBwb3B1bGFyIVwiXG5bMV0gMTNcblsxXSBcIkJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIDVcblsxXSBcIkJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIDJcblsxXSBcIllvdSdyZSBwb3B1bGFyIVwiXG5bMV0gMTdcblsxXSBcIllvdSdyZSBwb3B1bGFyIVwiXG5bMV0gMTRcbiIpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIk5leHQgaW4gTG9vcHMiKSksbWR4KCJwIixudWxsLCJOZXh0IGRvZXMgd2hhdCBjb250aW51ZSBkb2VzIGluIGEgbnVtYmVyIG9mIG90aGVyIGxhbmd1YWdlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFRoZSBsaW5rZWRpbiB2ZWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGZvciB5b3Vcbj4gbGlua2VkaW4gPC0gYygxNiwgOSwgMTMsIDUsIDIsIDE3LCAxNClcbj5cbiMgRXh0ZW5kIHRoZSBmb3IgbG9vcFxuPiBmb3IgKGxpIGluIGxpbmtlZGluKSB7XG4gICAgaWYgKGxpID4gMTApIHtcbiAgICAgIHByaW50KFwiWW91J3JlIHBvcHVsYXIhXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KFwiQmUgbW9yZSB2aXNpYmxlIVwiKVxuICAgIH1cblxuICAgICMgQWRkIGlmIHN0YXRlbWVudCB3aXRoIGJyZWFrXG4gICAgaWYgKGxpID4gMTYpIHtcbiAgICAgIHByaW50KFwiVGhpcyBpcyByaWRpY3Vsb3VzLCBJJ20gb3V0dGEgaGVyZSFcIilcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgIyBBZGQgaWYgc3RhdGVtZW50IHdpdGggbmV4dFxuICAgIGlmIChsaSA8IDUpIHtcbiAgICAgIHByaW50KFwiVGhpcyBpcyB0b28gZW1iYXJyYXNzaW5nIVwiKVxuICAgICAgbmV4dFxuICAgIH1cblxuICAgIHByaW50KGxpKVxuICB9XG5bMV0gXCJZb3UncmUgcG9wdWxhciFcIlxuWzFdIDE2XG5bMV0gXCJCZSBtb3JlIHZpc2libGUhXCJcblsxXSA5XG5bMV0gXCJZb3UncmUgcG9wdWxhciFcIlxuWzFdIDEzXG5bMV0gXCJCZSBtb3JlIHZpc2libGUhXCJcblsxXSA1XG5bMV0gXCJCZSBtb3JlIHZpc2libGUhXCJcblsxXSBcIlRoaXMgaXMgdG9vIGVtYmFycmFzc2luZyFcIlxuWzFdIFwiWW91J3JlIHBvcHVsYXIhXCJcblsxXSBcIlRoaXMgaXMgcmlkaWN1bG91cywgSSdtIG91dHRhIGhlcmUhXCJcbiIpKSxtZHgoInAiLG51bGwsIlRoZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwic3Ryc3BsaXQoKSIpLCIgZnVuY3Rpb24gc3BsaXRzIHRoZSBjaGFycyBpbnRvIGEgdmVjdG9yIHdpdGggaW5kaXZpZHVhbCBsZXR0ZXJzLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFByZS1kZWZpbmVkIHZhcmlhYmxlc1xuPiBycXVvdGUgPC0gXCJyJ3MgaW50ZXJuYWxzIGFyZSBpcnJlZnV0YWJseSBpbnRyaWd1aW5nXCJcbj4gY2hhcnMgPC0gc3Ryc3BsaXQocnF1b3RlLCBzcGxpdCA9IFwiXCIpW1sxXV1cbj5cbiMgSW5pdGlhbGl6ZSByY291bnRcbj4gcmNvdW50IDwtIDBcbj5cbiMgRmluaXNoIHRoZSBmb3IgbG9vcFxuPiBmb3IgKGNoYXIgaW4gY2hhcnMpIHtcbiAgICBpZiAoY2hhciA9PSAncicpIHtcbiAgICAgIHJjb3VudCA9IHJjb3VudCArIDFcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PSAndScpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4+XG4jIFByaW50IG91dCByY291bnRcbj4gcmNvdW50XG5bMV0gNVxuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJmdW5jdGlvbnMifSwiRnVuY3Rpb25zIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImhlbHAoKVxuYXJncygpXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJVc2luZyBmdW5jdGlvbnMiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVGhlIGxpbmtlZGluIGFuZCBmYWNlYm9vayB2ZWN0b3JzIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHlvdVxuPiBsaW5rZWRpbiA8LSBjKDE2LCA5LCAxMywgNSwgMiwgMTcsIDE0KVxuPiBmYWNlYm9vayA8LSBjKDE3LCA3LCA1LCAxNiwgOCwgMTMsIDE0KVxuPlxuIyBDYWxjdWxhdGUgYXZlcmFnZSBudW1iZXIgb2Ygdmlld3Ncbj4gYXZnX2xpIDwtIG1lYW4obGlua2VkaW4pXG4+IGF2Z19mYiA8LSBtZWFuKGZhY2Vib29rKVxuPlxuIyBJbnNwZWN0IGF2Z19saSBhbmQgYXZnX2ZiXG4+IGF2Z19saVxuWzFdIDEwLjg1NzE0XG4+IGF2Z19mYlxuWzFdIDExLjQyODU3XG4iKSksbWR4KCJoMyIseyJpZCI6Im1lYW4ifSwibWVhbigpIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVGhlIGxpbmtlZGluIGFuZCBmYWNlYm9vayB2ZWN0b3JzIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHlvdVxuPiBsaW5rZWRpbiA8LSBjKDE2LCA5LCAxMywgNSwgMiwgMTcsIDE0KVxuPiBmYWNlYm9vayA8LSBjKDE3LCA3LCA1LCAxNiwgOCwgMTMsIDE0KVxuPlxuIyBDYWxjdWxhdGUgdGhlIG1lYW4gb2YgdGhlIHN1bVxuPiBhdmdfc3VtIDwtIG1lYW4obGlua2VkaW4gKyBmYWNlYm9vaylcbj5cbiMgQ2FsY3VsYXRlIHRoZSB0cmltbWVkIG1lYW4gb2YgdGhlIHN1bVxuPiBhdmdfc3VtX3RyaW1tZWQgPC0gbWVhbihsaW5rZWRpbiArIGZhY2Vib29rLCAwLjIpXG4+XG4jIEluc3BlY3QgYm90aCBuZXcgdmFyaWFibGVzXG4+IGF2Z19zdW1cblsxXSAyMi4yODU3MVxuPiBhdmdfc3VtX3RyaW1tZWRcblsxXSAyMi42XG4iKSksbWR4KCJoMyIseyJpZCI6Im1lYW4tY29udGludWVkLXNkLWFuZC1ybW5hIn0sIm1lYW4oKSBjb250aW51ZWQsIHNkKCkgYW5kIHJtLm5hIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVGhlIGxpbmtlZGluIGFuZCBmYWNlYm9vayB2ZWN0b3JzIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHlvdVxuPiBsaW5rZWRpbiA8LSBjKDE2LCA5LCAxMywgNSwgTkEsIDE3LCAxNClcbj4gZmFjZWJvb2sgPC0gYygxNywgTkEsIDUsIDE2LCA4LCAxMywgMTQpXG4+XG4jIEJhc2ljIGF2ZXJhZ2Ugb2YgbGlua2VkaW5cbj4gbWVhbihsaW5rZWRpbilcblsxXSBOQVxuPlxuIyBBZHZhbmNlZCBhdmVyYWdlIG9mIGxpbmtlZGluXG4+IG1lYW4obGlua2VkaW4sIG5hLnJtID0gVFJVRSlcblsxXSAxMi4zMzMzM1xuIikpLG1keCgicCIsbnVsbCwiTm90ZSB0aGF0IHlvdSBjYW4gdXNlIGZ1bmN0aW9uIGNhbGxzIHdpdGhpbiBmdW5jdGlvbnMgY2FsbHMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVGhlIGxpbmtlZGluIGFuZCBmYWNlYm9vayB2ZWN0b3JzIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHlvdVxuPiBsaW5rZWRpbiA8LSBjKDE2LCA5LCAxMywgNSwgTkEsIDE3LCAxNClcbj4gZmFjZWJvb2sgPC0gYygxNywgTkEsIDUsIDE2LCA4LCAxMywgMTQpXG4+XG4jIENhbGN1bGF0ZSB0aGUgbWVhbiBhYnNvbHV0ZSBkZXZpYXRpb25cbj4gbWVhbihhYnMobGlua2VkaW4gLSBmYWNlYm9vayksIG5hLnJtID0gVFJVRSlcblsxXSA0LjhcbiIpKSxtZHgoImgzIix7ImlkIjoid3JpdGluZy1mdW5jdGlvbnMifSwiV3JpdGluZyBGdW5jdGlvbnMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBDcmVhdGUgYSBmdW5jdGlvbiBwb3dfdHdvKClcbj4gcG93X3R3byA8LSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4XjIpXG4gIH1cbj5cbj5cbiMgVXNlIHRoZSBmdW5jdGlvblxuPiBwb3dfdHdvKDEyKVxuWzFdIDE0NFxuPlxuIyBDcmVhdGUgYSBmdW5jdGlvbiBzdW1fYWJzKClcbj4gc3VtX2FicyA8LSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIChhYnMoeCkgKyBhYnMoeSkpXG4gIH1cbj5cbiMgVXNlIHRoZSBmdW5jdGlvblxuPiBzdW1fYWJzKC0yLCAzKVxuWzFdIDVcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBEZWZpbmUgdGhlIGZ1bmN0aW9uIGhlbGxvKClcbj4gaGVsbG8gPC0gZnVuY3Rpb24oKSB7XG4gICAgcHJpbnQoXCJIaSB0aGVyZSFcIilcbiAgICByZXR1cm4gKFRSVUUpXG4gIH1cbj5cbiMgQ2FsbCB0aGUgZnVuY3Rpb24gaGVsbG8oKVxuPiBoZWxsbygpXG5bMV0gXCJIaSB0aGVyZSFcIlxuWzFdIFRSVUVcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBGaW5pc2ggdGhlIHBvd190d28oKSBmdW5jdGlvblxuPiBwb3dfdHdvIDwtIGZ1bmN0aW9uKHgsIHByaW50X2luZm8gPSBUUlVFKSB7XG4gICAgeSA8LSB4IF4gMlxuICAgIGlmIChwcmludF9pbmZvKSB7XG4gICAgICBwcmludChwYXN0ZSh4LCBcInRvIHRoZSBwb3dlciB0d28gZXF1YWxzXCIsIHkpKVxuICAgIH1cbiAgICByZXR1cm4oeSlcbiAgfVxuPlxuPiBwb3dfdHdvKDIpXG5bMV0gXCIyIHRvIHRoZSBwb3dlciB0d28gZXF1YWxzIDRcIlxuWzFdIDRcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBEZWZpbmUgdGhlIGludGVycHJldCBmdW5jdGlvblxuPiBpbnRlcnByZXQgPC0gZnVuY3Rpb24obnVtX3ZpZXdzKSB7XG4gICAgaWYgKG51bV92aWV3cyA+IDE1KSB7XG4gICAgICBwcmludChcIllvdSdyZSBwb3B1bGFyIVwiKVxuICAgICAgcmV0dXJuIChudW1fdmlld3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KFwiVHJ5IHRvIGJlIG1vcmUgdmlzaWJsZSFcIilcbiAgICAgIHJldHVybiAoMClcbiAgICB9XG4gIH1cbj5cbiMgQ2FsbCB0aGUgaW50ZXJwcmV0IGZ1bmN0aW9uIHR3aWNlXG4+IGludGVycHJldChsaW5rZWRpblsxXSlcblsxXSBcIllvdSdyZSBwb3B1bGFyIVwiXG5bMV0gMTZcbj4gaW50ZXJwcmV0KGZhY2Vib29rWzJdKVxuWzFdIFwiVHJ5IHRvIGJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIDBcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBUaGUgbGlua2VkaW4gYW5kIGZhY2Vib29rIHZlY3RvcnMgaGF2ZSBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgeW91XG4+IGxpbmtlZGluIDwtIGMoMTYsIDksIDEzLCA1LCAyLCAxNywgMTQpXG4+IGZhY2Vib29rIDwtIGMoMTcsIDcsIDUsIDE2LCA4LCAxMywgMTQpXG4+XG4jIFRoZSBpbnRlcnByZXQoKSBjYW4gYmUgdXNlZCBpbnNpZGUgaW50ZXJwcmV0X2FsbCgpXG4+IGludGVycHJldCA8LSBmdW5jdGlvbihudW1fdmlld3MpIHtcbiAgICBpZiAobnVtX3ZpZXdzID4gMTUpIHtcbiAgICAgIHByaW50KFwiWW91J3JlIHBvcHVsYXIhXCIpXG4gICAgICByZXR1cm4obnVtX3ZpZXdzKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmludChcIlRyeSB0byBiZSBtb3JlIHZpc2libGUhXCIpXG4gICAgICByZXR1cm4oMClcbiAgICB9XG4gIH1cbj5cbiMgRGVmaW5lIHRoZSBpbnRlcnByZXRfYWxsKCkgZnVuY3Rpb25cbiMgdmlld3M6IHZlY3RvciB3aXRoIGRhdGEgdG8gaW50ZXJwcmV0XG4jIHJldHVybl9zdW06IHJldHVybiB0b3RhbCBudW1iZXIgb2Ygdmlld3Mgb24gcG9wdWxhciBkYXlzP1xuPiBpbnRlcnByZXRfYWxsIDwtIGZ1bmN0aW9uKHZpZXdzLCByZXR1cm5fc3VtID0gVFJVRSkge1xuICAgIGNvdW50IDwtIDBcblxuICAgIGZvciAodiBpbiB2aWV3cykge1xuICAgICAgY291bnQgPC0gY291bnQgKyBpbnRlcnByZXQodilcbiAgICB9XG5cbiAgICBpZiAocmV0dXJuX3N1bSkge1xuICAgICAgcmV0dXJuIChjb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChOVUxMKVxuICAgIH1cbiAgfVxuPlxuIyBDYWxsIHRoZSBpbnRlcnByZXRfYWxsKCkgZnVuY3Rpb24gb24gYm90aCBsaW5rZWRpbiBhbmQgZmFjZWJvb2tcbj4gaW50ZXJwcmV0X2FsbChsaW5rZWRpbilcblsxXSBcIllvdSdyZSBwb3B1bGFyIVwiXG5bMV0gXCJUcnkgdG8gYmUgbW9yZSB2aXNpYmxlIVwiXG5bMV0gXCJUcnkgdG8gYmUgbW9yZSB2aXNpYmxlIVwiXG5bMV0gXCJUcnkgdG8gYmUgbW9yZSB2aXNpYmxlIVwiXG5bMV0gXCJUcnkgdG8gYmUgbW9yZSB2aXNpYmxlIVwiXG5bMV0gXCJZb3UncmUgcG9wdWxhciFcIlxuWzFdIFwiVHJ5IHRvIGJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIDMzXG4+IGludGVycHJldF9hbGwoZmFjZWJvb2spXG5bMV0gXCJZb3UncmUgcG9wdWxhciFcIlxuWzFdIFwiVHJ5IHRvIGJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIFwiVHJ5IHRvIGJlIG1vcmUgdmlzaWJsZSFcIlxuWzFdIFwiWW91J3JlIHBvcHVsYXIhXCJcblsxXSBcIlRyeSB0byBiZSBtb3JlIHZpc2libGUhXCJcblsxXSBcIlRyeSB0byBiZSBtb3JlIHZpc2libGUhXCJcblsxXSBcIlRyeSB0byBiZSBtb3JlIHZpc2libGUhXCJcblsxXSAzM1xuIikpLG1keCgiaDMiLHsiaWQiOiJwYWNrYWdlcyJ9LCJQYWNrYWdlcyIpLG1keCgicCIsbnVsbCwiVG8gaW5zdGFsbC4uLiAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiaW5zdGFsbC5wYWNrYWdlcyg8aW5zdGFsbCBwYWNrYWdlPikiKSksbWR4KCJwIixudWxsLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwibGlicmFyeSgpIiksIiBsb2FkcyBwYWNrYWdlcywgYXR0YWNoZXMgdGhlbSB0byB0aGUgc2VhcmNoIGxpc3Qgb24geW91ciBSIHdvcmtzcGFjZS4iKSxtZHgoInAiLG51bGwsIkV4YW1wbGUgLSBsb2FkaW5nIHRoZSBnZ3Bsb3QyIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gc2VhcmNoKClcbiBbMV0gXCIuR2xvYmFsRW52XCIgICAgICAgICAgXCJwYWNrYWdlOlJCYWNrZW5kXCIgICAgXCJwYWNrYWdlOmRhdGFjYW1wU0NUXCJcbiBbNF0gXCJwYWNrYWdlOnN0YXRzXCIgICAgICAgXCJwYWNrYWdlOmdyYXBoaWNzXCIgICAgXCJwYWNrYWdlOmdyRGV2aWNlc1wiXG4gWzddIFwicGFja2FnZTp1dGlsc1wiICAgICAgIFwicGFja2FnZTpkYXRhc2V0c1wiICAgIFwicGFja2FnZTptZXRob2RzXCJcblsxMF0gXCJBdXRvbG9hZHNcIiAgICAgICAgICAgXCJwYWNrYWdlOmJhc2VcIlxuPiBxcGxvdChtdGNhcnMkd3QsIG10Y2FycyRocClcbkVycm9yOiBjb3VsZCBub3QgZmluZCBmdW5jdGlvbiBcInFwbG90XCJcblxuIyBMb2FkIHRoZSBnZ3Bsb3QyIHBhY2thZ2Vcbj4gbGlicmFyeShnZ3Bsb3QyKVxuPlxuIyBSZXRyeSB0aGUgcXBsb3QoKSBmdW5jdGlvblxuPiBxcGxvdChtdGNhcnMkd3QsIG10Y2FycyRocClcbj5cbiMgQ2hlY2sgb3V0IHRoZSBjdXJyZW50bHkgYXR0YWNoZWQgcGFja2FnZXMgYWdhaW5cbj4gc2VhcmNoKClcbiBbMV0gXCIuR2xvYmFsRW52XCIgICAgICAgICAgXCJwYWNrYWdlOmdncGxvdDJcIiAgICAgXCJwYWNrYWdlOlJCYWNrZW5kXCJcbiBbNF0gXCJwYWNrYWdlOmRhdGFjYW1wU0NUXCIgXCJwYWNrYWdlOnN0YXRzXCIgICAgICAgXCJwYWNrYWdlOmdyYXBoaWNzXCJcbiBbN10gXCJwYWNrYWdlOmdyRGV2aWNlc1wiICAgXCJwYWNrYWdlOnV0aWxzXCIgICAgICAgXCJwYWNrYWdlOmRhdGFzZXRzXCJcblsxMF0gXCJwYWNrYWdlOm1ldGhvZHNcIiAgICAgXCJBdXRvbG9hZHNcIiAgICAgICAgICAgXCJwYWNrYWdlOmJhc2VcIlxuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJ0aGUtYXBwbHktZmFtaWx5In0sIlRoZSBBcHBseSBGYW1pbHkiKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJsYXBwbHkiKSwiIGNhbiBhcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggaXRlbSBpbiBhIGxpc3QsIHZlY3RvciBldGMuIiksbWR4KCJwIixudWxsLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwibGFwcGx5IiksIiBpdHNlbGYgIixtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiQUxXQVlTIiksIiByZXR1cm5zIGEgbGlzdC4iKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJ1bmxpc3QobGFwcGx5KGV4YW1wbGVfbGlzdCwgbmNoYXIpKSIpLCIgY291bGQgZG8gdGhpbmdzIGxpa2UgdHVybiBhIGxpc3QgaW50byBhIHZlY3RvciBvZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gZWFjaCBlbGVtZW50IG9mIGV4YW1wbGVfbGlzdC4iKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJsYXBwbHkoWCwgRlVOLCAuLi4pIikpLG1keCgicCIsbnVsbCwiVG8gcHV0IGl0IGdlbmVyYWxseSwgbGFwcGx5IHRha2VzIGEgdmVjdG9yIG9yIGxpc3QgWCwgYW5kIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIEZVTiB0byBlYWNoIG9mIGl0cyBtZW1iZXJzLiBJZiBGVU4gcmVxdWlyZXMgYWRkaXRpb25hbCBhcmd1bWVudHMsIHlvdSBwYXNzIHRoZW0gYWZ0ZXIgeW91J3ZlIHNwZWNpZmllZCBYIGFuZCBGVU4gKC4uLikuIFRoZSBvdXRwdXQgb2YgbGFwcGx5KCkgaXMgYSBsaXN0LCB0aGUgc2FtZSBsZW5ndGggYXMgWCwgd2hlcmUgZWFjaCBlbGVtZW50IGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgRlVOIG9uIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgWC4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBUaGUgdmVjdG9yIHBpb25lZXJzIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgeW91XG4+IHBpb25lZXJzIDwtIGMoXCJHQVVTUzoxNzc3XCIsIFwiQkFZRVM6MTcwMlwiLCBcIlBBU0NBTDoxNjIzXCIsIFwiUEVBUlNPTjoxODU3XCIpXG4+XG4jIFNwbGl0IG5hbWVzIGZyb20gYmlydGggeWVhclxuPiBzcGxpdF9tYXRoIDwtIHN0cnNwbGl0KHBpb25lZXJzLCBzcGxpdCA9IFwiOlwiKVxuPlxuIyBDb252ZXJ0IHRvIGxvd2VyY2FzZSBzdHJpbmdzOiBzcGxpdF9sb3dcbj4gc3BsaXRfbG93IDwtIGxhcHBseShzcGxpdF9tYXRoLCB0b2xvd2VyKVxuPlxuIyBUYWtlIGEgbG9vayBhdCB0aGUgc3RydWN0dXJlIG9mIHNwbGl0X2xvd1xuPiBzdHIoc3BsaXRfbG93KVxuTGlzdCBvZiA0XG4gJCA6IGNociBbMToyXSBcImdhdXNzXCIgXCIxNzc3XCJcbiAkIDogY2hyIFsxOjJdIFwiYmF5ZXNcIiBcIjE3MDJcIlxuICQgOiBjaHIgWzE6Ml0gXCJwYXNjYWxcIiBcIjE2MjNcIlxuICQgOiBjaHIgWzE6Ml0gXCJwZWFyc29uXCIgXCIxODU3XCJcbiIpKSxtZHgoInAiLG51bGwsIkhvdyBhYm91dCB1c2luZyAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwibGFwcGx5IiksIiB3aXRoIHlvdXIgb3duIGZ1bmN0aW9ucz8iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiBwaW9uZWVycyA8LSBjKFwiR0FVU1M6MTc3N1wiLCBcIkJBWUVTOjE3MDJcIiwgXCJQQVNDQUw6MTYyM1wiLCBcIlBFQVJTT046MTg1N1wiKVxuPiBzcGxpdCA8LSBzdHJzcGxpdChwaW9uZWVycywgc3BsaXQgPSBcIjpcIilcbj4gc3BsaXRfbG93IDwtIGxhcHBseShzcGxpdCwgdG9sb3dlcilcbj5cbiMgV3JpdGUgZnVuY3Rpb24gc2VsZWN0X2ZpcnN0KClcbj4gc2VsZWN0X2ZpcnN0IDwtIGZ1bmN0aW9uKHgpIHtcbiAgIHhbMV1cbiB9XG4+XG4jIEFwcGx5IHNlbGVjdF9maXJzdCgpIG92ZXIgc3BsaXRfbG93OiBuYW1lc1xuPiBuYW1lcyA8LSBsYXBwbHkoc3BsaXRfbG93LCBzZWxlY3RfZmlyc3QpXG4+XG4jIFdyaXRlIGZ1bmN0aW9uIHNlbGVjdF9zZWNvbmQoKVxuPiBzZWxlY3Rfc2Vjb25kIDwtIGZ1bmN0aW9uKHgpIHtcbiAgIHhbMl1cbiB9XG4+XG4jIEFwcGx5IHNlbGVjdF9zZWNvbmQoKSBvdmVyIHNwbGl0X2xvdzogeWVhcnNcbj4geWVhcnMgPC0gbGFwcGx5KHNwbGl0X2xvdywgc2VsZWN0X3NlY29uZClcbiIpKSxtZHgoImgzIix7ImlkIjoiYW5vbnltb3VzLWZ1bmN0aW9ucyJ9LCJBbm9ueW1vdXMgRnVuY3Rpb25zIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gcGlvbmVlcnMgPC0gYyhcIkdBVVNTOjE3NzdcIiwgXCJCQVlFUzoxNzAyXCIsIFwiUEFTQ0FMOjE2MjNcIiwgXCJQRUFSU09OOjE4NTdcIilcbj4gc3BsaXQgPC0gc3Ryc3BsaXQocGlvbmVlcnMsIHNwbGl0ID0gXCI6XCIpXG4+IHNwbGl0X2xvdyA8LSBsYXBwbHkoc3BsaXQsIHRvbG93ZXIpXG4+XG4jIFRyYW5zZm9ybTogdXNlIGFub255bW91cyBmdW5jdGlvbiBpbnNpZGUgbGFwcGx5XG4+IG5hbWVzIDwtIGxhcHBseShzcGxpdF9sb3csIGZ1bmN0aW9uKHgpIHtcbiAgICB4WzFdXG4gIH0pXG4+XG4jIFRyYW5zZm9ybTogdXNlIGFub255bW91cyBmdW5jdGlvbiBpbnNpZGUgbGFwcGx5XG4+IHllYXJzIDwtIGxhcHBseShzcGxpdF9sb3csIGZ1bmN0aW9uKHgpIHtcbiAgICB4WzJdXG4gIH0pXG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgRGVmaW5pdGlvbiBvZiBzcGxpdF9sb3dcbj4gcGlvbmVlcnMgPC0gYyhcIkdBVVNTOjE3NzdcIiwgXCJCQVlFUzoxNzAyXCIsIFwiUEFTQ0FMOjE2MjNcIiwgXCJQRUFSU09OOjE4NTdcIilcbj4gc3BsaXQgPC0gc3Ryc3BsaXQocGlvbmVlcnMsIHNwbGl0ID0gXCI6XCIpXG4+IHNwbGl0X2xvdyA8LSBsYXBwbHkoc3BsaXQsIHRvbG93ZXIpXG4+XG4jIEdlbmVyaWMgc2VsZWN0IGZ1bmN0aW9uXG4+IHNlbGVjdF9lbCA8LSBmdW5jdGlvbih4LCBpbmRleCkge1xuICAgIHhbaW5kZXhdXG4gIH1cbj5cbiMgVXNlIGxhcHBseSgpIHR3aWNlIG9uIHNwbGl0X2xvdzogbmFtZXMgYW5kIHllYXJzXG4+IG5hbWVzIDwtIGxhcHBseShzcGxpdF9sb3csIHNlbGVjdF9lbCwgaW5kZXg9MSlcbj4geWVhcnMgPC0gbGFwcGx5KHNwbGl0X2xvdywgc2VsZWN0X2VsLCBpbmRleD0yKVxuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDMiLHsiaWQiOiJzYXBwbHkifSwic2FwcGx5IiksbWR4KCJwIixudWxsLCJXaGVyZWFzIGxhcHBseSgpIHJldHVybnMgYSBsaXN0LCBzYXBwbHkoKSAtIGluc3RlYWQgb2YgdW5saXN0KCkgZnVuY3Rpb24gb24gdGhhdCByZXR1cm5lZCBsaXN0LCB3ZSBjYW4gdXNlZCBzYXBwbHkoKSBmb3IgXCJzaW1wbGlmaWVkIGFwcGx5XCIgYW5kIGl0IHdpbGwgcmVzdWx0IGluIGEgbmFtZWQgdmVjdG9yLiBXZSBjYW4gYWxzbyBoYXZlIG1hdHJpY2VzIHJldHVyZWQgdG9vISIpLG1keCgicCIsbnVsbCxtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInNhcHBseShYLCBGVU5DLCBVU0UuTkFNRVMgPSBUUlVFKSIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiB0ZW1wXG5bWzFdXVxuWzFdICAzICA3ICA5ICA2IC0xXG5cbltbMl1dXG5bMV0gIDYgIDkgMTIgMTMgIDVcblxuW1szXV1cblsxXSAgNCAgOCAgMyAtMSAtM1xuXG5bWzRdXVxuWzFdICAxICA0ICA3ICAyIC0yXG5cbltbNV1dXG5bMV0gNSA3IDkgNCAyXG5cbltbNl1dXG5bMV0gLTMgIDUgIDggIDkgIDRcblxuW1s3XV1cblsxXSAzIDYgOSA0IDFcblxuIyB0ZW1wIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBpbiB0aGUgd29ya3NwYWNlXG4+XG4jIFVzZSBsYXBwbHkoKSB0byBmaW5kIGVhY2ggZGF5J3MgbWluaW11bSB0ZW1wZXJhdHVyZVxuPiBsYXBwbHkodGVtcCwgbWluKVxuW1sxXV1cblsxXSAtMVxuXG5bWzJdXVxuWzFdIDVcblxuW1szXV1cblsxXSAtM1xuXG5bWzRdXVxuWzFdIC0yXG5cbltbNV1dXG5bMV0gMlxuXG5bWzZdXVxuWzFdIC0zXG5cbltbN11dXG5bMV0gMVxuPlxuIyBVc2Ugc2FwcGx5KCkgdG8gZmluZCBlYWNoIGRheSdzIG1pbmltdW0gdGVtcGVyYXR1cmVcbj4gc2FwcGx5KHRlbXAsIG1pbilcblsxXSAtMSAgNSAtMyAtMiAgMiAtMyAgMVxuPlxuIyBVc2UgbGFwcGx5KCkgdG8gZmluZCBlYWNoIGRheSdzIG1heGltdW0gdGVtcGVyYXR1cmVcbj4gbGFwcGx5KHRlbXAsIG1heClcbltbMV1dXG5bMV0gOVxuXG5bWzJdXVxuWzFdIDEzXG5cbltbM11dXG5bMV0gOFxuXG5bWzRdXVxuWzFdIDdcblxuW1s1XV1cblsxXSA5XG5cbltbNl1dXG5bMV0gOVxuXG5bWzddXVxuWzFdIDlcbj5cbiMgVXNlIHNhcHBseSgpIHRvIGZpbmQgZWFjaCBkYXkncyBtYXhpbXVtIHRlbXBlcmF0dXJlXG4+IHNhcHBseSh0ZW1wLCBtYXgpXG5bMV0gIDkgMTMgIDggIDcgIDkgIDkgIDlcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBGaW5pc2ggZnVuY3Rpb24gZGVmaW5pdGlvbiBvZiBleHRyZW1lc19hdmdcbj4gZXh0cmVtZXNfYXZnIDwtIGZ1bmN0aW9uKHgpIHtcbiAgICAoIG1pbih4KSArIG1heCh4KSApIC8gMlxuICB9XG4+XG4jIEFwcGx5IGV4dHJlbWVzX2F2ZygpIG92ZXIgdGVtcCB1c2luZyBzYXBwbHkoKVxuPiBzYXBwbHkodGVtcCwgZXh0cmVtZXNfYXZnKVxuWzFdIDQuMCA5LjAgMi41IDIuNSA1LjUgMy4wIDUuMFxuPlxuIyBBcHBseSBleHRyZW1lc19hdmcoKSBvdmVyIHRlbXAgdXNpbmcgbGFwcGx5KClcbj4gbGFwcGx5KHRlbXAsIGV4dHJlbWVzX2F2ZylcbltbMV1dXG5bMV0gNFxuXG5bWzJdXVxuWzFdIDlcblxuW1szXV1cblsxXSAyLjVcblxuW1s0XV1cblsxXSAyLjVcblxuW1s1XV1cblsxXSA1LjVcblxuW1s2XV1cblsxXSAzXG5cbltbN11dXG5bMV0gNVxuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIHRlbXAgaXMgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIHdvcmtzcGFjZVxuPlxuIyBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbWluIGFuZCBtYXggb2YgYSB2ZWN0b3I6IGV4dHJlbWVzXG4+IGV4dHJlbWVzIDwtIGZ1bmN0aW9uKHgpIHtcbiAgICBjKG1pbiA9IG1pbih4KSwgbWF4ID0gbWF4KHgpKVxuICB9XG4+XG4jIEFwcGx5IGV4dHJlbWVzKCkgb3ZlciB0ZW1wIHdpdGggc2FwcGx5KClcbj4gc2FwcGx5KHRlbXAsIGV4dHJlbWVzKVxuICAgIFssMV0gWywyXSBbLDNdIFssNF0gWyw1XSBbLDZdIFssN11cbm1pbiAgIC0xICAgIDUgICAtMyAgIC0yICAgIDIgICAtMyAgICAxXG5tYXggICAgOSAgIDEzICAgIDggICAgNyAgICA5ICAgIDkgICAgOVxuPlxuIyBBcHBseSBleHRyZW1lcygpIG92ZXIgdGVtcCB3aXRoIGxhcHBseSgpXG4+IGxhcHBseSh0ZW1wLCBleHRyZW1lcylcbltbMV1dXG5taW4gbWF4XG4gLTEgICA5XG5cbltbMl1dXG5taW4gbWF4XG4gIDUgIDEzXG5cbltbM11dXG5taW4gbWF4XG4gLTMgICA4XG5cbltbNF1dXG5taW4gbWF4XG4gLTIgICA3XG5cbltbNV1dXG5taW4gbWF4XG4gIDIgICA5XG5cbltbNl1dXG5taW4gbWF4XG4gLTMgICA5XG5cbltbN11dXG5taW4gbWF4XG4gIDEgICA5XG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgdGVtcCBpcyBhbHJlYWR5IHByZXBhcmVkIGZvciB5b3UgaW4gdGhlIHdvcmtzcGFjZVxuPlxuIyBEZWZpbml0aW9uIG9mIGJlbG93X3plcm8oKVxuPiBiZWxvd196ZXJvIDwtIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4oeFt4IDwgMF0pXG4gIH1cbj5cbiMgQXBwbHkgYmVsb3dfemVybyBvdmVyIHRlbXAgdXNpbmcgc2FwcGx5KCk6IGZyZWV6aW5nX3Ncbj4gZnJlZXppbmdfcyA8LSBzYXBwbHkodGVtcCwgYmVsb3dfemVybylcbj5cbiMgQXBwbHkgYmVsb3dfemVybyBvdmVyIHRlbXAgdXNpbmcgbGFwcGx5KCk6IGZyZWV6aW5nX2xcbj4gZnJlZXppbmdfbCA8LSBsYXBwbHkodGVtcCwgYmVsb3dfemVybylcbj5cbiMgQXJlIGZyZWV6aW5nX3MgYW5kIGZyZWV6aW5nX2wgaWRlbnRpY2FsP1xuPiBpZGVudGljYWwoZnJlZXppbmdfbCwgZnJlZXppbmdfcylcblsxXSBUUlVFXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJzYXBwbHkgd2l0aCBOdWxsIHZhbHVlcyIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBEZWZpbml0aW9uIG9mIHByaW50X2luZm8oKVxuPiBwcmludF9pbmZvIDwtIGZ1bmN0aW9uKHgpIHtcbiAgICBjYXQoXCJUaGUgYXZlcmFnZSB0ZW1wZXJhdHVyZSBpc1wiLCBtZWFuKHgpLCBcIlxcblwiKVxuICB9XG4+XG4jIEFwcGx5IHByaW50X2luZm8oKSBvdmVyIHRlbXAgdXNpbmcgc2FwcGx5KClcbj4gbnVsbF9zIDwtIHNhcHBseSh0ZW1wLCBwcmludF9pbmZvKVxuVGhlIGF2ZXJhZ2UgdGVtcGVyYXR1cmUgaXMgNC44XG5UaGUgYXZlcmFnZSB0ZW1wZXJhdHVyZSBpcyA5XG5UaGUgYXZlcmFnZSB0ZW1wZXJhdHVyZSBpcyAyLjJcblRoZSBhdmVyYWdlIHRlbXBlcmF0dXJlIGlzIDIuNFxuVGhlIGF2ZXJhZ2UgdGVtcGVyYXR1cmUgaXMgNS40XG5UaGUgYXZlcmFnZSB0ZW1wZXJhdHVyZSBpcyA0LjZcblRoZSBhdmVyYWdlIHRlbXBlcmF0dXJlIGlzIDQuNlxuPlxuIyBBcHBseSBwcmludF9pbmZvKCkgb3ZlciB0ZW1wIHVzaW5nIGxhcHBseSgpXG4+IG51bGxfbCA8LSBsYXBwbHkodGVtcCwgcHJpbnRfaW5mbylcblRoZSBhdmVyYWdlIHRlbXBlcmF0dXJlIGlzIDQuOFxuVGhlIGF2ZXJhZ2UgdGVtcGVyYXR1cmUgaXMgOVxuVGhlIGF2ZXJhZ2UgdGVtcGVyYXR1cmUgaXMgMi4yXG5UaGUgYXZlcmFnZSB0ZW1wZXJhdHVyZSBpcyAyLjRcblRoZSBhdmVyYWdlIHRlbXBlcmF0dXJlIGlzIDUuNFxuVGhlIGF2ZXJhZ2UgdGVtcGVyYXR1cmUgaXMgNC42XG5UaGUgYXZlcmFnZSB0ZW1wZXJhdHVyZSBpcyA0LjZcbj5cbj4gaWRlbnRpY2FsKG51bGxfbCwgbnVsbF9zKVxuWzFdIFRSVUVcbiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgzIix7ImlkIjoidmFwcGx5In0sInZhcHBseSgpIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImxhcHBseSgpIDogYXBwbHkgZnVuY3Rpb24gb3ZlciBsaXN0IG9yIHZlY3Rvclxub3V0cHV0ID0gbGlzdFxuXG5zYXBwbHkoKSA6IGFwcGx5IGZ1bmN0aW9uIG92ZXIgbGlzdCBvciB2ZWN0b3JcbnRyeSB0byBzaW1wbGlmeSBsaXN0IHRvIGFycmF5XG5cbnZhcHBseSgpIDogYXBwbHkgZnVuY3Rpb24gb3ZlciBsaXN0IG9yIHZlY3RvclxuZXhwbGljaXRseSBzcGVjaWZ5IG91dHB1dCBmb3JtYXRcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBEZWZpbml0aW9uIG9mIGJhc2ljcygpXG4+IGJhc2ljcyA8LSBmdW5jdGlvbih4KSB7XG4gICAgYyhtaW4gPSBtaW4oeCksIG1lYW4gPSBtZWFuKHgpLCBtYXggPSBtYXgoeCkpXG4gIH1cbj5cbiMgQXBwbHkgYmFzaWNzKCkgb3ZlciB0ZW1wIHVzaW5nIHZhcHBseSgpXG4+IHZhcHBseSh0ZW1wLCBiYXNpY3MsIG51bWVyaWMoMykpXG4gICAgIFssMV0gWywyXSBbLDNdIFssNF0gWyw1XSBbLDZdIFssN11cbm1pbiAgLTEuMCAgICA1IC0zLjAgLTIuMCAgMi4wIC0zLjAgIDEuMFxubWVhbiAgNC44ICAgIDkgIDIuMiAgMi40ICA1LjQgIDQuNiAgNC42XG5tYXggICA5LjAgICAxMyAgOC4wICA3LjAgIDkuMCAgOS4wICA5LjBcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBDb252ZXJ0IHRvIHZhcHBseSgpIGV4cHJlc3Npb25cbj4gdmFwcGx5KHRlbXAsIG1heCwgbnVtZXJpYygxKSlcblsxXSAgOSAxMyAgOCAgNyAgOSAgOSAgOVxuPlxuIyBDb252ZXJ0IHRvIHZhcHBseSgpIGV4cHJlc3Npb25cbj4gdmFwcGx5KHRlbXAsIGZ1bmN0aW9uKHgsIHkpIHsgbWVhbih4KSA+IHkgfSwgeSA9IDUsIGxvZ2ljYWwoMSkpXG5bMV0gRkFMU0UgIFRSVUUgRkFMU0UgRkFMU0UgIFRSVUUgRkFMU0UgRkFMU0VcbiIpKSxtZHgoImhyIixudWxsKSxtZHgoImgyIix7ImlkIjoidXNlZnVsLWZ1bmN0aW9ucyJ9LCJVc2VmdWwgRnVuY3Rpb25zIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksInNhcHBseSgpLCBsYXBwbHkoKSwgdmFwcGx5KClcbnNvcnQoKVxucHJpbnQoKVxuaWRlbnRpY2FsKClcbm1lYW4oKVxucm91bmQoKVxuYWJzKClcblxuLy8gZnVuY3MgZm9yIGRhdGEgc3RydWN0dXJlc1xuc2VxKClcbnJlcCgpIC8vIHJlcGxpY2F0ZVxuaXMuKigpXG5hcy4qKClcbnVubGlzdCgpXG5hcHBlbmQoKVxucmV2KClcbiIpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIk1hdGggVXRpbHMiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gZXJyb3JzIDwtIGMoMS45LCAtMi42LCA0LjAsIC05LjUsIC0zLjQsIDcuMylcbj5cbiMgU3VtIG9mIGFic29sdXRlIHJvdW5kZWQgdmFsdWVzIG9mIGVycm9yc1xuPiBzdW0ocm91bmQoYWJzKGVycm9ycykpKVxuWzFdIDI5XG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgRG9uJ3QgZWRpdCB0aGVzZSB0d28gbGluZXNcbj4gdmVjMSA8LSBjKDEuNSwgMi41LCA4LjQsIDMuNywgNi4zKVxuPiB2ZWMyIDwtIHJldih2ZWMxKVxuPlxuIyBGaXggdGhlIGVycm9yXG4+IG1lYW4oYyhhYnModmVjMSksIGFicyh2ZWMyKSkpXG5bMV0gNC40OFxuIikpLG1keCgiaDMiLHsiaWQiOiJkYXRhLXV0aWxpdGllcyJ9LCJEYXRhIFV0aWxpdGllcyIpLG1keCgicCIsbnVsbCwiUiBmZWF0dXJlcyBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyB0byBqdWdnbGUgYXJvdW5kIHdpdGggZGF0YSBzdHJ1Y3R1cmVzOjoiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwic2VxKCk6IEdlbmVyYXRlIHNlcXVlbmNlcywgYnkgc3BlY2lmeWluZyB0aGUgZnJvbSwgdG8gYW5kIGJ5IGFyZ3VtZW50cy5cbnJlcCgpOiBSZXBsaWNhdGUgZWxlbWVudHMgb2YgdmVjdG9ycyBhbmQgbGlzdHMuXG5zb3J0KCk6IFNvcnQgYSB2ZWN0b3IgaW4gYXNjZW5kaW5nIG9yZGVyLiBXb3JrcyBvbiBudW1lcmljcywgYnV0IGFsc28gb24gY2hhcmFjdGVyIHN0cmluZ3MgYW5kIGxvZ2ljYWxzLlxucmV2KCk6IFJldmVyc2UgdGhlIGVsZW1lbnRzIGluIGEgZGF0YSBzdHJ1Y3R1cmVzIGZvciB3aGljaCByZXZlcnNhbCBpcyBkZWZpbmVkLlxuc3RyKCk6IERpc3BsYXkgdGhlIHN0cnVjdHVyZSBvZiBhbnkgUiBvYmplY3QuXG5hcHBlbmQoKTogTWVyZ2UgdmVjdG9ycyBvciBsaXN0cy5cbmlzLiooKTogQ2hlY2sgZm9yIHRoZSBjbGFzcyBvZiBhbiBSIG9iamVjdC5cbmFzLiooKTogQ29udmVydCBhbiBSIG9iamVjdCBmcm9tIG9uZSBjbGFzcyB0byBhbm90aGVyLlxudW5saXN0KCk6IEZsYXR0ZW4gKHBvc3NpYmx5IGVtYmVkZGVkKSBsaXN0cyB0byBwcm9kdWNlIGEgdmVjdG9yLlxuIikpLG1keCgicCIsbnVsbCwiUmVtZW1iZXIgdGhlIHNvY2lhbCBtZWRpYSBwcm9maWxlIHZpZXcgZGF0YT8gWW91ciBMaW5rZWRJbiBhbmQgRmFjZWJvb2sgdmlldyBjb3VudHMgZm9yIHRoZSBsYXN0IHNldmVuIGRheXMgYXJlIGFscmVhZHkgZGVmaW5lZCBhcyBsaXN0cyBvbiB0aGUgcmlnaHQuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVGhlIGxpbmtlZGluIGFuZCBmYWNlYm9vayBsaXN0cyBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkIGZvciB5b3Vcbj4gbGlua2VkaW4gPC0gbGlzdCgxNiwgOSwgMTMsIDUsIDIsIDE3LCAxNClcbj4gZmFjZWJvb2sgPC0gbGlzdCgxNywgNywgNSwgMTYsIDgsIDEzLCAxNClcbj5cbiMgQ29udmVydCBsaW5rZWRpbiBhbmQgZmFjZWJvb2sgdG8gYSB2ZWN0b3I6IGxpX3ZlYyBhbmQgZmJfdmVjXG4+IGxpX3ZlYyA8LSB1bmxpc3QobGlua2VkaW4pXG4+IGZiX3ZlYyA8LSB1bmxpc3QoZmFjZWJvb2spXG4+XG4jIEFwcGVuZCBmYl92ZWMgdG8gbGlfdmVjOiBzb2NpYWxfdmVjXG4+IHNvY2lhbF92ZWMgPC0gYXBwZW5kKGxpX3ZlYywgZmJfdmVjKVxuPlxuIyBTb3J0IHNvY2lhbF92ZWNcbj4gc29ydChzb2NpYWxfdmVjLCBkZWNyZWFzaW5nID0gVFJVRSlcbiBbMV0gMTcgMTcgMTYgMTYgMTQgMTQgMTMgMTMgIDkgIDggIDcgIDUgIDUgIDJcbiIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiPiByZXAoc2VxKDEsIDcsIGJ5ID0gMiksIHRpbWVzID0gNylcbiBbMV0gMSAzIDUgNyAxIDMgNSA3IDEgMyA1IDcgMSAzIDUgNyAxIDMgNSA3IDEgMyA1IDcgMSAzIDUgN1xuIikpLG1keCgiaDMiLHsiaWQiOiJiZWF0LWdhdXNzLXVzaW5nLXIifSwiQmVhdCBHYXVzcyB1c2luZyBSIiksbWR4KCJwIixudWxsLCJUaGVyZSBpcyBhIHBvcHVsYXIgc3RvcnkgYWJvdXQgeW91bmcgR2F1c3MuIEFzIGEgcHVwaWwsIGhlIGhhZCBhIGxhenkgdGVhY2hlciB3aG8gd2FudGVkIHRvIGtlZXAgdGhlIGNsYXNzcm9vbSBidXN5IGJ5IGhhdmluZyB0aGVtIGFkZCB1cCB0aGUgbnVtYmVycyAxIHRvIDEwMC4gR2F1c3MgY2FtZSB1cCB3aXRoIGFuIGFuc3dlciBhbG1vc3QgaW5zdGFudGFuZW91c2x5LCA1MDUwLiBPbiB0aGUgc3BvdCwgaGUgaGFkIGRldmVsb3BlZCBhIGZvcm11bGEgZm9yIGNhbGN1bGF0aW5nIHRoZSBzdW0gb2YgYW4gYXJpdGhtZXRpYyBzZXJpZXMuIFRoZXJlIGFyZSBtb3JlIGdlbmVyYWwgZm9ybXVsYXMgZm9yIGNhbGN1bGF0aW5nIHRoZSBzdW0gb2YgYW4gYXJpdGhtZXRpYyBzZXJpZXMgd2l0aCBkaWZmZXJlbnQgc3RhcnRpbmcgdmFsdWVzIGFuZCBpbmNyZW1lbnRzLiBJbnN0ZWFkIG9mIGRlcml2aW5nIHN1Y2ggYSBmb3JtdWxhLCB3aHkgbm90IHVzZSBSIHRvIGNhbGN1bGF0ZSB0aGUgc3VtIG9mIGEgc2VxdWVuY2U/IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgQ3JlYXRlIGZpcnN0IHNlcXVlbmNlOiBzZXExXG4+IHNlcTEgPC0gc2VxKDEsIDUwMCwgMylcbj5cbiMgQ3JlYXRlIHNlY29uZCBzZXF1ZW5jZTogc2VxMlxuPiBzZXEyIDwtIHNlcSgxMjAwLCA5MDAsIC03KVxuPlxuIyBDYWxjdWxhdGUgdG90YWwgc3VtIG9mIHRoZSBzZXF1ZW5jZXNcbj4gc3VtKHNlcTEsIHNlcTIpXG5bMV0gODcwMjlcbiIpKSxtZHgoImgzIix7ImlkIjoicmVnZXgifSwiUmVnZXgiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiZ3JlcGwocGF0dGVyID0gPHJlZ2V4PiwgeCA9IDxzdHJpbmc+KVxuXG5hbmltYWxzIDwtIGMoXCJjYXRcIiwgXCJtb29zZVwiKVxuZ3JlcGwoXCJhXCIsIGFuaW1hbHMpXG5UUlVFIEZBTFNFXG5cbnN1YihwYXR0ZXJuID0gPHJlZ2V4PiwgcmVwbGFjZW1lbnQgPSA8c3RyPiwgeCA9IDxzdHI+KVxuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFRoZSBlbWFpbHMgdmVjdG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBmb3IgeW91XG4+IGVtYWlscyA8LSBjKFwiam9obi5kb2VAaXZ5bGVhZ3VlLmVkdVwiLCBcImVkdWNhdGlvbkB3b3JsZC5nb3ZcIiwgXCJkYWxhaS5sYW1hQHBlYWNlLm9yZ1wiLFxuICAgICAgICAgICAgICBcImludmFsaWQuZWR1XCIsIFwicXVhbnRAYmlnZGF0YWNvbGxlZ2UuZWR1XCIsIFwiY29va2llLm1vbnN0ZXJAc2VzYW1lLnR2XCIpXG4+XG4jIFVzZSBncmVwbCgpIHRvIG1hdGNoIGZvciBcImVkdVwiXG4+IGdyZXBsKFwiZWR1XCIsIGVtYWlscylcblsxXSAgVFJVRSAgVFJVRSBGQUxTRSAgVFJVRSAgVFJVRSBGQUxTRVxuPlxuIyBVc2UgZ3JlcCgpIHRvIG1hdGNoIGZvciBcImVkdVwiLCBzYXZlIHJlc3VsdCB0byBoaXRzXG4+IGhpdHMgPC0gZ3JlcChcImVkdVwiLCBlbWFpbHMpXG4+XG4jIFN1YnNldCBlbWFpbHMgdXNpbmcgaGl0c1xuPiBlbWFpbHNbaGl0c11cblsxXSBcImpvaG4uZG9lQGl2eWxlYWd1ZS5lZHVcIiAgIFwiZWR1Y2F0aW9uQHdvcmxkLmdvdlwiXG5bM10gXCJpbnZhbGlkLmVkdVwiICAgICAgICAgICAgICBcInF1YW50QGJpZ2RhdGFjb2xsZWdlLmVkdVwiXG4iKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQCwgYmVjYXVzZSBhIHZhbGlkIGVtYWlsIG11c3QgY29udGFpbiBhbiBhdC1zaWduLiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCIuIixtZHgoImVtIix7cGFyZW50TmFtZToibGkifSwiLCB3aGljaCBtYXRjaGVzIGFueSBjaGFyYWN0ZXIgKC4pIHplcm8gb3IgbW9yZSB0aW1lcyAoIiksIikuIEJvdGggdGhlIGRvdCBhbmQgdGhlIGFzdGVyaXNrIGFyZSBtZXRhY2hhcmFjdGVycy4gWW91IGNhbiB1c2UgdGhlbSB0byBtYXRjaCBhbnkgY2hhcmFjdGVyIGJldHdlZW4gdGhlIGF0LXNpZ24gYW5kIHRoZSBcIi5lZHVcIiBwb3J0aW9uIG9mIGFuIGVtYWlsIGFkZHJlc3MuIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIFRoZSBlbWFpbHMgdmVjdG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBmb3IgeW91XG4+IGVtYWlscyA8LSBjKFwiam9obi5kb2VAaXZ5bGVhZ3VlLmVkdVwiLCBcImVkdWNhdGlvbkB3b3JsZC5nb3ZcIiwgXCJkYWxhaS5sYW1hQHBlYWNlLm9yZ1wiLFxuICAgICAgICAgICAgICBcImludmFsaWQuZWR1XCIsIFwicXVhbnRAYmlnZGF0YWNvbGxlZ2UuZWR1XCIsIFwiY29va2llLm1vbnN0ZXJAc2VzYW1lLnR2XCIpXG4+XG4jIFVzZSBncmVwbCgpIHRvIG1hdGNoIGZvciAuZWR1IGFkZHJlc3NlcyBtb3JlIHJvYnVzdGx5XG4+IGdyZXBsKFwiQC4qXFxcXC5lZHUkXCIsIGVtYWlscylcblsxXSAgVFJVRSBGQUxTRSBGQUxTRSBGQUxTRSAgVFJVRSBGQUxTRVxuPlxuIikpLG1keCgiaDMiLHsiaWQiOiJzdWItLWdzdWIifSwic3ViICYgZ3N1YiIpLG1keCgicCIsbnVsbCwiV2hpbGUgZ3JlcCgpIGFuZCBncmVwbCgpIHdlcmUgdXNlZCB0byBzaW1wbHkgY2hlY2sgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBjb3VsZCBiZSBtYXRjaGVkIHdpdGggYSBjaGFyYWN0ZXIgdmVjdG9yLCBzdWIoKSBhbmQgZ3N1YigpIHRha2UgaXQgb25lIHN0ZXAgZnVydGhlcjogeW91IGNhbiBzcGVjaWZ5IGEgcmVwbGFjZW1lbnQgYXJndW1lbnQuIElmIGluc2lkZSB0aGUgY2hhcmFjdGVyIHZlY3RvciB4LCB0aGUgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaXMgZm91bmQsIHRoZSBtYXRjaGluZyBlbGVtZW50KHMpIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCByZXBsYWNlbWVudC5zdWIoKSBvbmx5IHJlcGxhY2VzIHRoZSBmaXJzdCBtYXRjaCwgd2hlcmVhcyBnc3ViKCkgcmVwbGFjZXMgYWxsIG1hdGNoZXMuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgVGhlIGVtYWlscyB2ZWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGZvciB5b3Vcbj4gZW1haWxzIDwtIGMoXCJqb2huLmRvZUBpdnlsZWFndWUuZWR1XCIsIFwiZWR1Y2F0aW9uQHdvcmxkLmdvdlwiLCBcImRhbGFpLmxhbWFAcGVhY2Uub3JnXCIsXG4gICAgICAgICAgICAgIFwiaW52YWxpZC5lZHVcIiwgXCJxdWFudEBiaWdkYXRhY29sbGVnZS5lZHVcIiwgXCJjb29raWUubW9uc3RlckBzZXNhbWUudHZcIilcbj5cbiMgVXNlIHN1YigpIHRvIGNvbnZlcnQgdGhlIGVtYWlsIGRvbWFpbnMgdG8gZGF0YWNhbXAuZWR1XG4+IHN1YihcIkAuKlxcXFwuZWR1JFwiLCBcIkBkYXRhY2FtcC5lZHVcIiwgZW1haWxzKVxuWzFdIFwiam9obi5kb2VAZGF0YWNhbXAuZWR1XCIgICAgXCJlZHVjYXRpb25Ad29ybGQuZ292XCJcblszXSBcImRhbGFpLmxhbWFAcGVhY2Uub3JnXCIgICAgIFwiaW52YWxpZC5lZHVcIlxuWzVdIFwicXVhbnRAZGF0YWNhbXAuZWR1XCIgICAgICAgXCJjb29raWUubW9uc3RlckBzZXNhbWUudHZcIlxuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiJ0aW1lcy0tZGF0ZXMifSwiVGltZXMgJiBEYXRlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJ0b2RheSA8LSBTeXMuRGF0ZSgpXG50b2RheVxuIyBwcmludHMgZGF0ZVxuXG4jIGZvciBhIHRpbWVzdGFtcFxubm93IDwtIFN5cy50aW1lKClcblxubXlfZGF0ZSA8LSBhcy5EYXRlKFwiMTk3NS0xNC0wNVwiLCBmb3JtYXQgPSBcIiVZLSVkLSVtXCIpXG5cbiMgZm9ybWF0IG11c3QgYmUgc3BlY2lmaWVkIGlmIHlvdSBjaGFuZ2UgZnJvbSBZLW0tZFxuXG4+IG5vdyA8LSBTeXMudGltZSgpXG4+IG5vd1xuWzFdIFwiMjAxNi0xMS0yMCAwOTozNjo0MyBBRURUXCJcblxuIyBhZGRpbmcgZGF5c1xuXG4+IG15ZGF0ZVxuWzFdIFwiMjAxNi0xMS0yMFwiXG4+IG15ZGF0ZSArIDFcblsxXSBcIjIwMTYtMTEtMjFcIlxuXG4jIGRpZmZlcmVuY2UgaW4gZGF0ZXNcblxuPiBteWRhdGUyIDwtIG15ZGF0ZSArIDQwXG4+IG15ZGF0ZTIgLSBteWRhdGVcblRpbWUgZGlmZmVyZW5jZSBvZiA0MCBkYXlzXG5cbiMgcG9zaXggLSBkYXlzIHNpbmNlIEphbiAxLCAxOTcwXG4jIHVuY2xhc3MgdGltZSB3aWxsIGRvIHRoaXMgY2FsY3VsYXRpb24gaW4gc2Vjb25kc1xuXG4+IHVuY2xhc3MobXlkYXRlKVxuWzFdIDE3MTI1XG4iKSksbWR4KCJwIixudWxsLCJJbiB0ZXJtcyBvZiBwYWNrYWdlcyB0aGF0IGFyZSBnb29kIGZvciBkZWFsaW5nIHdpdGggZGF0ZXMgYW5kIHRpbWVzOiIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sImx1YnJpZGF0ZSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJ6b28iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwieHRzIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIjIEdldCB0aGUgY3VycmVudCBkYXRlOiB0b2RheVxuPiB0b2RheSA8LSBTeXMuRGF0ZSgpXG4+XG4jIFNlZSB3aGF0IHRvZGF5IGxvb2tzIGxpa2UgdW5kZXIgdGhlIGhvb2Rcbj4gdW5jbGFzcyh0b2RheSlcblsxXSAxNzEyNFxuPlxuIyBHZXQgdGhlIGN1cnJlbnQgdGltZTogbm93XG4+IG5vdyA8LSBTeXMudGltZSgpXG4+XG4jIFNlZSB3aGF0IG5vdyBsb29rcyBsaWtlIHVuZGVyIHRoZSBob29kXG4+IHVuY2xhc3Mobm93KVxuWzFdIDE0Nzk1OTU1MDhcbiIpKSxtZHgoInAiLG51bGwsIlRvIGNyZWF0ZSBhIERhdGUgb2JqZWN0IGZyb20gYSBzaW1wbGUgY2hhcmFjdGVyIHN0cmluZyBpbiBSLCB5b3UgY2FuIHVzZSB0aGUgYXMuRGF0ZSgpIGZ1bmN0aW9uLiBUaGUgY2hhcmFjdGVyIHN0cmluZyBoYXMgdG8gb2JleSBhIGZvcm1hdCB0aGF0IGNhbiBiZSBkZWZpbmVkIHVzaW5nIGEgc2V0IG9mIHN5bWJvbHMgKHRoZSBleGFtcGxlcyBjb3JyZXNwb25kIHRvIDEzIEphbnVhcnksIDE5ODIpOiIpLG1keCgicCIsbnVsbCwiJVk6IDQtZGlnaXQgeWVhciAoMTk4MilcbiV5OiAyLWRpZ2l0IHllYXIgKDgyKVxuJW06IDItZGlnaXQgbW9udGggKDAxKVxuJWQ6IDItZGlnaXQgZGF5IG9mIHRoZSBtb250aCAoMTMpXG4lQTogd2Vla2RheSAoV2VkbmVzZGF5KVxuJWE6IGFiYnJldmlhdGVkIHdlZWtkYXkgKFdlZClcbiVCOiBtb250aCAoSmFudWFyeSlcbiViOiBhYmJyZXZpYXRlZCBtb250aCAoSmFuKSIpLG1keCgicCIsbnVsbCwiVGhlIGZvbGxvd2luZyBSIGNvbW1hbmRzIHdpbGwgYWxsIGNyZWF0ZSB0aGUgc2FtZSBEYXRlIG9iamVjdCBmb3IgMTMgSmFudWFyeSwgMTk4MjoiKSxtZHgoInAiLG51bGwsImFzLkRhdGUoXCIxOTgyLTAxLTEzXCIpXG5hcy5EYXRlKFwiSmFuLTEzLTgyXCIsIGZvcm1hdCA9IFwiJWItJWQtJXlcIilcbmFzLkRhdGUoXCIxMyBKYW51YXJ5LCAxOTgyXCIsIGZvcm1hdCA9IFwiJWQgJUIsICVZXCIpIiksbWR4KCJwIixudWxsLCJOb3RpY2UgdGhhdCB0aGUgZmlyc3QgbGluZSBoZXJlIGRpZCBub3QgbmVlZCBhIGZvcm1hdCBhcmd1bWVudCwgYmVjYXVzZSBieSBkZWZhdWx0IFIgbWF0Y2hlcyB5b3VyIGNoYXJhY3RlciBzdHJpbmcgdG8gdGhlIGZvcm1hdHMgXCIlWS0lbS0lZFwiIG9yIFwiJVkvJW0vJWRcIi4iKSxtZHgoInAiLG51bGwsIkluIGFkZGl0aW9uIHRvIGNyZWF0aW5nIGRhdGVzLCB5b3UgY2FuIGFsc28gY29udmVydCBkYXRlcyB0byBjaGFyYWN0ZXIgc3RyaW5ncyB0aGF0IHVzZSBhIGRpZmZlcmVudCBkYXRlIG5vdGF0aW9uLiBGb3IgdGhpcywgeW91IHVzZSB0aGUgZm9ybWF0KCkgZnVuY3Rpb24uIFRyeSB0aGUgZm9sbG93aW5nIGxpbmVzIG9mIGNvZGU6IiksbWR4KCJwIixudWxsLCJ0b2RheSA8LSBTeXMuRGF0ZSgpXG5mb3JtYXQoU3lzLkRhdGUoKSwgZm9ybWF0ID0gXCIlZCAlQiwgJVlcIilcbmZvcm1hdChTeXMuRGF0ZSgpLCBmb3JtYXQgPSBcIlRvZGF5IGlzIGEgJUEhXCIpIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgRGVmaW5pdGlvbiBvZiBjaGFyYWN0ZXIgc3RyaW5ncyByZXByZXNlbnRpbmcgZGF0ZXNcbj4gc3RyMSA8LSBcIk1heSAyMywgJzk2XCJcbj4gc3RyMiA8LSBcIjIwMTItMDMtMTVcIlxuPiBzdHIzIDwtIFwiMzAvSmFudWFyeS8yMDA2XCJcbj5cbiMgQ29udmVydCB0aGUgc3RyaW5ncyB0byBkYXRlczogZGF0ZTEsIGRhdGUyLCBkYXRlM1xuPiBkYXRlMSA8LSBhcy5EYXRlKHN0cjEsIGZvcm1hdCA9IFwiJWIgJWQsICcleVwiKVxuPiBkYXRlMiA8LSBhcy5EYXRlKHN0cjIsIGZvcm1hdCA9IFwiJVktJW0tJWRcIilcbj4gZGF0ZTMgPC0gYXMuRGF0ZShzdHIzLCBmb3JtYXQgPSBcIiVkLyVCLyVZXCIpXG4+XG4+XG4jIENvbnZlcnQgZGF0ZXMgdG8gZm9ybWF0dGVkIHN0cmluZ3Ncbj4gZm9ybWF0KGRhdGUxLCBcIiVBXCIpXG5bMV0gXCJUaHVyc2RheVwiXG4+IGZvcm1hdChkYXRlMiwgXCIlZFwiKVxuWzFdIFwiMTVcIlxuPiBmb3JtYXQoZGF0ZTMsIFwiJWIgJVlcIilcblsxXSBcIkphbiAyMDA2XCJcbiIpKSxtZHgoInAiLG51bGwsIlNpbWlsYXIgdG8gd29ya2luZyB3aXRoIGRhdGVzLCB5b3UgY2FuIHVzZSBhcy5QT1NJWGN0KCkgdG8gY29udmVydCBmcm9tIGEgY2hhcmFjdGVyIHN0cmluZyB0byBhIFBPU0lYY3Qgb2JqZWN0LCBhbmQgZm9ybWF0KCkgdG8gY29udmVydCBmcm9tIGEgUE9TSVhjdCBvYmplY3QgdG8gYSBjaGFyYWN0ZXIgc3RyaW5nLiBBZ2FpbiwgeW91IGhhdmUgYSB3aWRlIHZhcmlldHkgb2Ygc3ltYm9sczoiKSxtZHgoInAiLG51bGwsIiVIOiBob3VycyBhcyBhIGRlY2ltYWwgbnVtYmVyICgwMC0yMylcbiVNOiBtaW51dGVzIGFzIGEgZGVjaW1hbCBudW1iZXJcbiVTOiBzZWNvbmRzIGFzIGEgZGVjaW1hbCBudW1iZXJcbiVUOiBzaG9ydGhhbmQgbm90YXRpb24gZm9yIHRoZSB0eXBpY2FsIGZvcm1hdCAlSDolTTolUyIpLG1keCgicCIsbnVsbCwiRm9yIGEgZnVsbCBsaXN0IG9mIGNvbnZlcnNpb24gc3ltYm9scywgY29uc3VsdCB0aGUgc3RycHRpbWUgZG9jdW1lbnRhdGlvbiBpbiB0aGUgY29uc29sZToiKSxtZHgoInAiLG51bGwsIj9zdHJwdGltZSIpLG1keCgicCIsbnVsbCwiQWdhaW4sIGFzLlBPU0lYY3QoKSB1c2VzIGEgZGVmYXVsdCBmb3JtYXQgdG8gbWF0Y2ggY2hhcmFjdGVyIHN0cmluZ3MuIEluIHRoaXMgY2FzZSwgaXQncyAlWS0lbS0lZCAlSDolTTolUy4gSW4gdGhpcyBleGVyY2lzZSwgYWJzdHJhY3Rpb24gaXMgbWFkZSBvZiBkaWZmZXJlbnQgdGltZSB6b25lcy4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBEZWZpbml0aW9uIG9mIGNoYXJhY3RlciBzdHJpbmdzIHJlcHJlc2VudGluZyB0aW1lc1xuPiBzdHIxIDwtIFwiTWF5IDIzLCAnOTYgaG91cnM6MjMgbWludXRlczowMSBzZWNvbmRzOjQ1XCJcbj4gc3RyMiA8LSBcIjIwMTItMy0xMiAxNDoyMzowOFwiXG4+XG4jIENvbnZlcnQgdGhlIHN0cmluZ3MgdG8gUE9TSVhjdCBvYmplY3RzOiB0aW1lMSwgdGltZTJcbj4gdGltZTEgPC0gYXMuUE9TSVhjdChzdHIxLCBmb3JtYXQgPSBcIiVCICVkLCAnJXkgaG91cnM6JUggbWludXRlczolTSBzZWNvbmRzOiVTXCIpXG4+IHRpbWUyIDwtIGFzLlBPU0lYY3Qoc3RyMiwgZm9ybWF0ID0gXCIlWS0lbS0lZCAlSDolTTolU1wiKVxuPlxuIyBDb252ZXJ0IHRpbWVzIHRvIGZvcm1hdHRlZCBzdHJpbmdzXG4+IGZvcm1hdCh0aW1lMSwgXCIlTVwiKVxuWzFdIFwiMDFcIlxuPiBmb3JtYXQodGltZTIsIFwiJUk6JU0gJXBcIilcblsxXSBcIjAyOjIzIFBNXCJcbiIpKSxtZHgoInAiLG51bGwsIkJvdGggRGF0ZSBhbmQgUE9TSVhjdCBSIG9iamVjdHMgYXJlIHJlcHJlc2VudGVkIGJ5IHNpbXBsZSBudW1lcmljYWwgdmFsdWVzIHVuZGVyIHRoZSBob29kLiBUaGlzIG1ha2VzIGNhbGN1bGF0aW9uIHdpdGggdGltZSBhbmQgZGF0ZSBvYmplY3RzIHZlcnkgc3RyYWlnaHRmb3J3YXJkOiBSIHBlcmZvcm1zIHRoZSBjYWxjdWxhdGlvbnMgdXNpbmcgdGhlIHVuZGVybHlpbmcgbnVtZXJpY2FsIHZhbHVlcywgYW5kIHRoZW4gY29udmVydHMgdGhlIHJlc3VsdCBiYWNrIHRvIGh1bWFuLXJlYWRhYmxlIHRpbWUgaW5mb3JtYXRpb24gYWdhaW4uIiksbWR4KCJwIixudWxsLCJZb3UgY2FuIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IERhdGUgb2JqZWN0cywgb3IgZG8gYWN0dWFsIGNhbGN1bGF0aW9ucyB3aXRoIHRoZW0gKHRyeSBpdCBvdXQgaW4gdGhlIGNvbnNvbGUhKToiKSxtZHgoInAiLG51bGwsInRvZGF5IDwtIFN5cy5EYXRlKClcbnRvZGF5ICsgMVxudG9kYXkgLSAxIiksbWR4KCJwIixudWxsLCJhcy5EYXRlKFwiMjAxNS0wMy0xMlwiKSAtIGFzLkRhdGUoXCIyMDE1LTAyLTI3XCIpIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIiMgRGlmZmVyZW5jZSBiZXR3ZWVuIGxhc3QgYW5kIGZpcnN0IHBpenphIGRheVxuPiBkYXk1IC0gZGF5MVxuVGltZSBkaWZmZXJlbmNlIG9mIDExIGRheXNcbj5cbiMgQ3JlYXRlIHZlY3RvciBwaXp6YVxuPiBwaXp6YSA8LSBjKGRheTEsIGRheTIsIGRheTMsIGRheTQsIGRheTUpXG4+XG4jIENyZWF0ZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBpenphIGRheXM6IGRheV9kaWZmXG4+IGRheV9kaWZmIDwtIGRpZmYocGl6emEpXG4+XG4jIEF2ZXJhZ2UgcGVyaW9kIGJldHdlZW4gdHdvIGNvbnNlY3V0aXZlIHBpenphIGRheXNcbj4gbWVhbihkYXlfZGlmZilcblRpbWUgZGlmZmVyZW5jZSBvZiAyLjc1IGRheXNcbiIpKSxtZHgoInAiLG51bGwsIkNhbGN1bGF0aW9ucyB1c2luZyBQT1NJWGN0IG9iamVjdHMgYXJlIGNvbXBsZXRlbHkgYW5hbG9nb3VzIHRvIHRob3NlIHVzaW5nIERhdGUgb2JqZWN0cy4gVHJ5IHRvIGV4cGVyaW1lbnQgd2l0aCB0aGlzIGNvZGUgdG8gaW5jcmVhc2Ugb3IgZGVjcmVhc2UgUE9TSVhjdCBvYmplY3RzOiIpLG1keCgicCIsbnVsbCwibm93IDwtIFN5cy50aW1lKClcbm5vdyArIDM2MDAgIyBhZGQgYW4gaG91clxubm93IC0gMzYwMCIsIioiLCIyNCAjIHN1YnRyYWN0IGEgZGF5XG5BZGRpbmcgb3Igc3Vic3RyYWN0aW5nIHRpbWUgb2JqZWN0cyBpcyBhbHNvIHN0cmFpZ2h0Zm9yd2FyZDoiKSxtZHgoInAiLG51bGwsImJpcnRoIDwtIGFzLlBPU0lYY3QoXCIxODc5LTAzLTE0IDE0OjM3OjIzXCIpXG5kZWF0aCA8LSBhcy5QT1NJWGN0KFwiMTk1NS0wNC0xOCAwMzo0NzoxMlwiKVxuZWluc3RlaW4gPC0gZGVhdGggLSBiaXJ0aFxuZWluc3RlaW4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHt9KSwiIyBsb2dpbiBhbmQgbG9nb3V0IGFyZSBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHdvcmtzcGFjZVxuIyBDYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBsb2dpbiBhbmQgbG9nb3V0OiB0aW1lX29ubGluZVxuPiB0aW1lX29ubGluZSA8LSBsb2dvdXQgLSBsb2dpblxuPlxuIyBJbnNwZWN0IHRoZSB2YXJpYWJsZSB0aW1lX29ubGluZVxuPiB0aW1lX29ubGluZVxuVGltZSBkaWZmZXJlbmNlcyBpbiBzZWNzXG5bMV0gMjMwNS4xMTgxOCAgIDM0LjE4NDcyICA4MzcuMTgxODIgMjM5Ny45MDE1MyAxODUxLjMwNDExXG4+XG4jIENhbGN1bGF0ZSB0aGUgdG90YWwgdGltZSBvbmxpbmVcbj4gc3VtKHRpbWVfb25saW5lKVxuVGltZSBkaWZmZXJlbmNlIG9mIDc0MjUuNjkgc2Vjc1xuPlxuIyBDYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgdGltZSBvbmxpbmVcbj4gbWVhbih0aW1lX29ubGluZSlcblRpbWUgZGlmZmVyZW5jZSBvZiAxNDg1LjEzOCBzZWNzXG4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksIj4gYXN0cm9cbiAgICAgICBzcHJpbmcgICAgICAgIHN1bW1lciAgICAgICAgICBmYWxsICAgICAgICB3aW50ZXJcblwiMjAtTWFyLTIwMTVcIiBcIjI1LUp1bi0yMDE1XCIgXCIyMy1TZXAtMjAxNVwiIFwiMjItRGVjLTIwMTVcIlxuXG4+IG1ldGVvXG4gICAgICAgICAgIHNwcmluZyAgICAgICAgICAgIHN1bW1lciAgICAgICAgICAgICAgZmFsbCAgICAgICAgICAgIHdpbnRlclxuICAgIFwiTWFyY2ggMSwgMTVcIiAgICAgIFwiSnVuZSAxLCAxNVwiIFwiU2VwdGVtYmVyIDEsIDE1XCIgIFwiRGVjZW1iZXIgMSwgMTVcIlxuXG4jIENvbnZlcnQgYXN0cm8gdG8gdmVjdG9yIG9mIERhdGUgb2JqZWN0czogYXN0cm9fZGF0ZXNcbj4gYXN0cm9fZGF0ZXMgPC0gYXMuRGF0ZShhc3RybywgZm9ybWF0PVwiJWQtJUItJVlcIilcbj5cbj4gYXN0cm9fZGF0ZXNcblsxXSBcIjIwMTUtMDMtMjBcIiBcIjIwMTUtMDYtMjVcIiBcIjIwMTUtMDktMjNcIiBcIjIwMTUtMTItMjJcIlxuIyBDb252ZXJ0IG1ldGVvIHRvIHZlY3RvciBvZiBEYXRlIG9iamVjdHM6IG1ldGVvX2RhdGVzXG4+IG1ldGVvX2RhdGVzIDwtIGFzLkRhdGUobWV0ZW8sIGZvcm1hdD1cIiVCICVkLCAleVwiKVxuPlxuPiBtZXRlb19kYXRlc1xuWzFdIFwiMjAxNS0wMy0wMVwiIFwiMjAxNS0wNi0wMVwiIFwiMjAxNS0wOS0wMVwiIFwiMjAxNS0xMi0wMVwiXG4jIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gYXN0cm9fZGF0ZXMgYW5kIG1ldGVvX2RhdGVzXG4+IG1heChhYnMoYXN0cm9fZGF0ZXMgLSBtZXRlb19kYXRlcykpXG5UaW1lIGRpZmZlcmVuY2Ugb2YgMjQgZGF5c1xuIikpKTt9aWYodHlwZW9mIE1EWENvbnRlbnQhPT0ndW5kZWZpbmVkJyYmTURYQ29udGVudCYmTURYQ29udGVudD09PU9iamVjdChNRFhDb250ZW50KSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShNRFhDb250ZW50KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KE1EWENvbnRlbnQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6Ik1EWENvbnRlbnQiLGZpbGVuYW1lOiJtYW51YWwvUi9SLUludGVybWVkaWF0ZS5tZCJ9fSk7fU1EWENvbnRlbnQuaXNNRFhDb21wb25lbnQ9dHJ1ZTs="},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/R/R-Intermediate.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"relational-operators\"\n    }}>{`Relational Operators`}</h2>\n    <p>{`R.O.'s are operators that let us see how one R object relates to another eg. equality etc`}</p>\n    <p>{`You can compare arrays, matrices, lists and other types of data structures.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Equality ==\n> TRUE == TRUE\n[1] TRUE\n\n# Inequality !=\n# LT, GT > and <\n\nAlphabetical order with relate to alphabet and T/F will go 1/0\n\n# Relational Operators and Vectors\n> example <- c(12,4,5,3,5)\n> example\n[1] 12 4 5 3 5\n> example > 10\n[1] TRUE FALSE FALSE FALSE FALSE\n\n# Comparison of logicals\n> TRUE == FALSE\n[1] FALSE\n>\n# Comparison of numerics\n> -6 * 14 != 17 - 101\n[1] FALSE\n>\n# Comparison of character strings\n> \"useR\" == \"user\"\n[1] FALSE\n>\n# Compare a logical with a numeric\n> TRUE == 1\n[1] TRUE\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"greater-than-or-less-than\"\n    }}>{`Greater than or less than`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`# Comparison of numerics\n> -6 * 5 + 2 >= -10 + 1\n[1] FALSE\n>\n# Comparison of character strings\n> \"raining\" <= \"raining dogs\"\n[1] TRUE\n>\n# Comparison of logicals\n> TRUE > FALSE\n[1] TRUE\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"compare-vectors\"\n    }}>{`Compare Vectors`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n> facebook <- c(17, 7, 5, 16, 8, 13, 14)\n>\n# Popular days\n> linkedin > 15\n[1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n>\n# Quiet days\n> linkedin <= 5\n[1] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n>\n# LinkedIn more popular than Facebook\n> linkedin > facebook\n[1] FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"compare-matrices\"\n    }}>{`Compare Matrices`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n> facebook <- c(17, 7, 5, 16, 8, 13, 14)\n> views <- matrix(c(linkedin, facebook), nrow = 2, byrow = TRUE)\n>\n# When does views equal 13?\n> views == 13\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]\n[1,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[2,] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n>\n# When is views less than or equal to 14?\n> views <= 14\n      [,1] [,2] [,3]  [,4] [,5]  [,6] [,7]\n[1,] FALSE TRUE TRUE  TRUE TRUE FALSE TRUE\n[2,] FALSE TRUE TRUE FALSE TRUE  TRUE TRUE\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"logical-operators\"\n    }}>{`Logical Operators`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`x <- 12\nx > 5 & x < 15  # evaluates to TRUE\n\n&   // and\n|   // or\n!   // not\n\n# for vectors\n\n&&      // only evaluates the first element of the vector\n||      // only evaluates the first element of the vector\n\n// examples\n\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n> last <- tail(linkedin, 1)\n>\n# Is last under 5 or above 10?\n> last < 5 | last > 10\n[1] TRUE\n>\n# Is last between 15 (exclusive) and 20 (inclusive)?\n> last > 15 & last <= 20\n[1] FALSE\n\n// vector examples\n\n# linkedin exceeds 10 but facebook below 10\n> linkedin > 10 & facebook < 10\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n>\n# When were one or both visited at least 12 times?\n> linkedin >= 12 | facebook >= 12\n[1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n>\n# When is views between 11 (exclusive) and 14 (inclusive)?\n> views > 11 & views <= 14\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6] [,7]\n[1,] FALSE FALSE  TRUE FALSE FALSE FALSE TRUE\n[2,] FALSE FALSE FALSE FALSE FALSE  TRUE TRUE\n\n// tougher exercises\n\n# Select the second column, named day2, from li_df: second\n> second <- li_df[\"day2\"]\n>\n# Build a logical vector, TRUE if value in second is extreme: extremes\n> extremes <- c(second > 25 | second < 5)\n>\n# Count the number of TRUEs in extremes\n> sum(extremes == TRUE)\n[1] 16\n>\n# Solve it with a one-liner\n> sum(li_df[\"day2\"] > 25 | li_df[\"day2\"] < 5)\n[1] 16\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"conditional-statements\"\n    }}>{`Conditional Statements`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`if (condition) {\n    // expr\n}\n\nx <- 3\n\nif (x < 0) {\n    print(\"x is negative\")\n} else if (x < 3) {\n    print(\"else if exec\")\n} else {\n    print(\"x is positive\")\n}\n\n# Variables related to your last day of recordings\n> medium <- \"LinkedIn\"\n> num_views <- 14\n>\n# Examine the if statement for medium\n> if (medium == \"LinkedIn\") {\n    print(\"Showing LinkedIn information\")\n  }\n[1] \"Showing LinkedIn information\"\n>\n# Write the if statement for num_views\n> if (num_views > 15) {\n    print(\"You're popular!\")\n  }\n>\n\n# Variables related to your last day of recordings\n> li <- 15\n> fb <- 9\n>\n# Code the control-flow construct\n> if (li >= 15 & fb >= 15) {\n    sms <- 2 * (li + fb)\n  } else if (li < 10 & fb < 10) {\n    sms <- 0.5 * (li + fb)\n  } else {\n    sms <- li + fb\n  }\n>\n# Print the resulting sms to the console\n> sms\n[1] 24\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"loops\"\n    }}>{`Loops`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`while (condition) {\n  // run the exp\n}\n\nctr <- 1\n\nwhile (ctr <= 7) {\n  // run the expression\n  ctr <- ctr + 1\n}\n`}</code></pre>\n    <p>{`Make sure that the condition for a while loop because false at some stage.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Print out the speed variable\n> speed\n[1] 64\n# Initialize the speed variable\n> speed <- 64\n>\n# Code the while loop\n> while (speed > 30) {\n    print(\"Slow down!\")\n    speed <- speed -7\n  }\n[1] \"Slow down!\"\n[1] \"Slow down!\"\n[1] \"Slow down!\"\n[1] \"Slow down!\"\n[1] \"Slow down!\"\n>\n# Print out the speed variable\n> speed\n[1] 29\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Initialize the speed variable\n> speed <- 64\n>\n# Extend/adapt the while loop\n> while (speed > 30) {\n    print(paste(\"Your speed is\",speed))\n    if (speed > 48) {\n      print(\"Slow down big time!\")\n      speed <- speed - 11\n    } else {\n      print(\"Slow down!\")\n      speed <- speed - 6\n    }\n  }\n[1] \"Your speed is 64\"\n[1] \"Slow down big time!\"\n[1] \"Your speed is 53\"\n[1] \"Slow down big time!\"\n[1] \"Your speed is 42\"\n[1] \"Slow down!\"\n[1] \"Your speed is 36\"\n[1] \"Slow down!\"\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Initialize the speed variable\n> speed <- 88\n>\n> while (speed > 30) {\n    print(paste(\"Your speed is\", speed))\n\n    # Break the while loop when speed exceeds 80\n    if (speed > 80) {\n      break\n    }\n\n    if (speed > 48) {\n      print(\"Slow down big time!\")\n      speed <- speed - 11\n    } else {\n      print(\"Slow down!\")\n      speed <- speed - 6\n    }\n  }\n[1] \"Your speed is 88\"\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Initialize i as 1\n> i <- 1\n>\n# Code the while loop\n> while (i <= 10) {\n    print(3 * i)\n    if (3*i %% 8 == 0) {\n      break\n    }\n    i <- i + 1\n  }\n[1] 3\n[1] 6\n[1] 9\n[1] 12\n[1] 15\n[1] 18\n[1] 21\n[1] 24\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"for-loop\"\n    }}>{`For Loop`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin vector has already been defined for you\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n>\n# Loop version 1\n> for (l in linkedin) {\n    print(l)\n  }\n[1] 16\n[1] 9\n[1] 13\n[1] 5\n[1] 2\n[1] 17\n[1] 14\n>\n>\n# Loop version 2\n> for (i in 1:length(linkedin)) {\n    print(linkedin[i])\n  }\n[1] 16\n[1] 9\n[1] 13\n[1] 5\n[1] 2\n[1] 17\n[1] 14\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"looping-over-a-list\"\n    }}>{`Looping Over a List`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`primes_list <- list(2, 3, 5, 7, 11, 13)\n\n# loop version 1\nfor (p in primes_list) {\n  print(p)\n}\n\n# loop version 2\nfor (i in 1:length(primes_list)) {\n  print(primes_list[[i]])\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# The nyc list is already specified\n> nyc <- list(pop = 8405837,\n              boroughs = c(\"Manhattan\", \"Bronx\", \"Brooklyn\", \"Queens\", \"Staten Island\"),\n              capital = FALSE)\n>\n# Loop version 1\n> for (n in nyc) {\n    print(n)\n  }\n[1] 8405837\n[1] \"Manhattan\"     \"Bronx\"         \"Brooklyn\"      \"Queens\"\n[5] \"Staten Island\"\n[1] FALSE\n>\n# Loop version 2\n> for (i in 1:length(nyc)) {\n    print(nyc[[i]])\n  }\n[1] 8405837\n[1] \"Manhattan\"     \"Bronx\"         \"Brooklyn\"      \"Queens\"\n[5] \"Staten Island\"\n[1] FALSE\n`}</code></pre>\n    <p><strong parentName=\"p\">{`How about printing over a matrix?`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The tic-tac-toe matrix ttt has already been defined for you\n>\n# define the double for loop\n> for (i in 1:nrow(ttt)) {\n    for (j in 1:ncol(ttt)) {\n      print(paste(\"On row\", i, \"and column\", j, \"the board contains\", ttt[i,j]))\n    }\n  }\n[1] \"On row 1 and column 1 the board contains O\"\n[1] \"On row 1 and column 2 the board contains NA\"\n[1] \"On row 1 and column 3 the board contains X\"\n[1] \"On row 2 and column 1 the board contains NA\"\n[1] \"On row 2 and column 2 the board contains O\"\n[1] \"On row 2 and column 3 the board contains O\"\n[1] \"On row 3 and column 1 the board contains X\"\n[1] \"On row 3 and column 2 the board contains NA\"\n[1] \"On row 3 and column 3 the board contains X\"\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Mixing together Control Flow and Loops`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin vector has already been defined for you\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n>\n# Code the for loop with conditionals\n> for (li in linkedin) {\n    if (li > 10) {\n      print(\"You're popular!\")\n    } else {\n      print(\"Be more visible!\")\n    }\n    print(li)\n  }\n[1] \"You're popular!\"\n[1] 16\n[1] \"Be more visible!\"\n[1] 9\n[1] \"You're popular!\"\n[1] 13\n[1] \"Be more visible!\"\n[1] 5\n[1] \"Be more visible!\"\n[1] 2\n[1] \"You're popular!\"\n[1] 17\n[1] \"You're popular!\"\n[1] 14\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Next in Loops`}</strong></p>\n    <p>{`Next does what continue does in a number of other languages`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin vector has already been defined for you\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n>\n# Extend the for loop\n> for (li in linkedin) {\n    if (li > 10) {\n      print(\"You're popular!\")\n    } else {\n      print(\"Be more visible!\")\n    }\n\n    # Add if statement with break\n    if (li > 16) {\n      print(\"This is ridiculous, I'm outta here!\")\n      break\n    }\n\n    # Add if statement with next\n    if (li < 5) {\n      print(\"This is too embarrassing!\")\n      next\n    }\n\n    print(li)\n  }\n[1] \"You're popular!\"\n[1] 16\n[1] \"Be more visible!\"\n[1] 9\n[1] \"You're popular!\"\n[1] 13\n[1] \"Be more visible!\"\n[1] 5\n[1] \"Be more visible!\"\n[1] \"This is too embarrassing!\"\n[1] \"You're popular!\"\n[1] \"This is ridiculous, I'm outta here!\"\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`strsplit()`}</inlineCode>{` function splits the chars into a vector with individual letters.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Pre-defined variables\n> rquote <- \"r's internals are irrefutably intriguing\"\n> chars <- strsplit(rquote, split = \"\")[[1]]\n>\n# Initialize rcount\n> rcount <- 0\n>\n# Finish the for loop\n> for (char in chars) {\n    if (char == 'r') {\n      rcount = rcount + 1\n    }\n\n    if (char == 'u') {\n      break\n    }\n  }\n>\n# Print out rcount\n> rcount\n[1] 5\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"functions\"\n    }}>{`Functions`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`help()\nargs()\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Using functions`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin and facebook vectors have already been created for you\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n> facebook <- c(17, 7, 5, 16, 8, 13, 14)\n>\n# Calculate average number of views\n> avg_li <- mean(linkedin)\n> avg_fb <- mean(facebook)\n>\n# Inspect avg_li and avg_fb\n> avg_li\n[1] 10.85714\n> avg_fb\n[1] 11.42857\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"mean\"\n    }}>{`mean()`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin and facebook vectors have already been created for you\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n> facebook <- c(17, 7, 5, 16, 8, 13, 14)\n>\n# Calculate the mean of the sum\n> avg_sum <- mean(linkedin + facebook)\n>\n# Calculate the trimmed mean of the sum\n> avg_sum_trimmed <- mean(linkedin + facebook, 0.2)\n>\n# Inspect both new variables\n> avg_sum\n[1] 22.28571\n> avg_sum_trimmed\n[1] 22.6\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"mean-continued-sd-and-rmna\"\n    }}>{`mean() continued, sd() and rm.na`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin and facebook vectors have already been created for you\n> linkedin <- c(16, 9, 13, 5, NA, 17, 14)\n> facebook <- c(17, NA, 5, 16, 8, 13, 14)\n>\n# Basic average of linkedin\n> mean(linkedin)\n[1] NA\n>\n# Advanced average of linkedin\n> mean(linkedin, na.rm = TRUE)\n[1] 12.33333\n`}</code></pre>\n    <p>{`Note that you can use function calls within functions calls.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin and facebook vectors have already been created for you\n> linkedin <- c(16, 9, 13, 5, NA, 17, 14)\n> facebook <- c(17, NA, 5, 16, 8, 13, 14)\n>\n# Calculate the mean absolute deviation\n> mean(abs(linkedin - facebook), na.rm = TRUE)\n[1] 4.8\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"writing-functions\"\n    }}>{`Writing Functions`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`# Create a function pow_two()\n> pow_two <- function(x) {\n    return (x^2)\n  }\n>\n>\n# Use the function\n> pow_two(12)\n[1] 144\n>\n# Create a function sum_abs()\n> sum_abs <- function(x, y) {\n    return (abs(x) + abs(y))\n  }\n>\n# Use the function\n> sum_abs(-2, 3)\n[1] 5\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Define the function hello()\n> hello <- function() {\n    print(\"Hi there!\")\n    return (TRUE)\n  }\n>\n# Call the function hello()\n> hello()\n[1] \"Hi there!\"\n[1] TRUE\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Finish the pow_two() function\n> pow_two <- function(x, print_info = TRUE) {\n    y <- x ^ 2\n    if (print_info) {\n      print(paste(x, \"to the power two equals\", y))\n    }\n    return(y)\n  }\n>\n> pow_two(2)\n[1] \"2 to the power two equals 4\"\n[1] 4\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Define the interpret function\n> interpret <- function(num_views) {\n    if (num_views > 15) {\n      print(\"You're popular!\")\n      return (num_views)\n    } else {\n      print(\"Try to be more visible!\")\n      return (0)\n    }\n  }\n>\n# Call the interpret function twice\n> interpret(linkedin[1])\n[1] \"You're popular!\"\n[1] 16\n> interpret(facebook[2])\n[1] \"Try to be more visible!\"\n[1] 0\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin and facebook vectors have already been created for you\n> linkedin <- c(16, 9, 13, 5, 2, 17, 14)\n> facebook <- c(17, 7, 5, 16, 8, 13, 14)\n>\n# The interpret() can be used inside interpret_all()\n> interpret <- function(num_views) {\n    if (num_views > 15) {\n      print(\"You're popular!\")\n      return(num_views)\n    } else {\n      print(\"Try to be more visible!\")\n      return(0)\n    }\n  }\n>\n# Define the interpret_all() function\n# views: vector with data to interpret\n# return_sum: return total number of views on popular days?\n> interpret_all <- function(views, return_sum = TRUE) {\n    count <- 0\n\n    for (v in views) {\n      count <- count + interpret(v)\n    }\n\n    if (return_sum) {\n      return (count)\n    } else {\n      return (NULL)\n    }\n  }\n>\n# Call the interpret_all() function on both linkedin and facebook\n> interpret_all(linkedin)\n[1] \"You're popular!\"\n[1] \"Try to be more visible!\"\n[1] \"Try to be more visible!\"\n[1] \"Try to be more visible!\"\n[1] \"Try to be more visible!\"\n[1] \"You're popular!\"\n[1] \"Try to be more visible!\"\n[1] 33\n> interpret_all(facebook)\n[1] \"You're popular!\"\n[1] \"Try to be more visible!\"\n[1] \"Try to be more visible!\"\n[1] \"You're popular!\"\n[1] \"Try to be more visible!\"\n[1] \"Try to be more visible!\"\n[1] \"Try to be more visible!\"\n[1] 33\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"packages\"\n    }}>{`Packages`}</h3>\n    <p>{`To install... `}<inlineCode parentName=\"p\">{`install.packages(<install package>)`}</inlineCode></p>\n    <p><inlineCode parentName=\"p\">{`library()`}</inlineCode>{` loads packages, attaches them to the search list on your R workspace.`}</p>\n    <p>{`Example - loading the ggplot2`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> search()\n [1] \".GlobalEnv\"          \"package:RBackend\"    \"package:datacampSCT\"\n [4] \"package:stats\"       \"package:graphics\"    \"package:grDevices\"\n [7] \"package:utils\"       \"package:datasets\"    \"package:methods\"\n[10] \"Autoloads\"           \"package:base\"\n> qplot(mtcars$wt, mtcars$hp)\nError: could not find function \"qplot\"\n\n# Load the ggplot2 package\n> library(ggplot2)\n>\n# Retry the qplot() function\n> qplot(mtcars$wt, mtcars$hp)\n>\n# Check out the currently attached packages again\n> search()\n [1] \".GlobalEnv\"          \"package:ggplot2\"     \"package:RBackend\"\n [4] \"package:datacampSCT\" \"package:stats\"       \"package:graphics\"\n [7] \"package:grDevices\"   \"package:utils\"       \"package:datasets\"\n[10] \"package:methods\"     \"Autoloads\"           \"package:base\"\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"the-apply-family\"\n    }}>{`The Apply Family`}</h2>\n    <p><inlineCode parentName=\"p\">{`lapply`}</inlineCode>{` can apply a function to each item in a list, vector etc.`}</p>\n    <p><inlineCode parentName=\"p\">{`lapply`}</inlineCode>{` itself `}<strong parentName=\"p\">{`ALWAYS`}</strong>{` returns a list.`}</p>\n    <p><inlineCode parentName=\"p\">{`unlist(lapply(example_list, nchar))`}</inlineCode>{` could do things like turn a list into a vector of the number of characters in each element of example_list.`}</p>\n    <p><inlineCode parentName=\"p\">{`lapply(X, FUN, ...)`}</inlineCode></p>\n    <p>{`To put it generally, lapply takes a vector or list X, and applies the function FUN to each of its members. If FUN requires additional arguments, you pass them after you've specified X and FUN (...). The output of lapply() is a list, the same length as X, where each element is the result of applying FUN on the corresponding element of X.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The vector pioneers has already been created for you\n> pioneers <- c(\"GAUSS:1777\", \"BAYES:1702\", \"PASCAL:1623\", \"PEARSON:1857\")\n>\n# Split names from birth year\n> split_math <- strsplit(pioneers, split = \":\")\n>\n# Convert to lowercase strings: split_low\n> split_low <- lapply(split_math, tolower)\n>\n# Take a look at the structure of split_low\n> str(split_low)\nList of 4\n $ : chr [1:2] \"gauss\" \"1777\"\n $ : chr [1:2] \"bayes\" \"1702\"\n $ : chr [1:2] \"pascal\" \"1623\"\n $ : chr [1:2] \"pearson\" \"1857\"\n`}</code></pre>\n    <p>{`How about using `}<inlineCode parentName=\"p\">{`lapply`}</inlineCode>{` with your own functions?`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`> pioneers <- c(\"GAUSS:1777\", \"BAYES:1702\", \"PASCAL:1623\", \"PEARSON:1857\")\n> split <- strsplit(pioneers, split = \":\")\n> split_low <- lapply(split, tolower)\n>\n# Write function select_first()\n> select_first <- function(x) {\n   x[1]\n }\n>\n# Apply select_first() over split_low: names\n> names <- lapply(split_low, select_first)\n>\n# Write function select_second()\n> select_second <- function(x) {\n   x[2]\n }\n>\n# Apply select_second() over split_low: years\n> years <- lapply(split_low, select_second)\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"anonymous-functions\"\n    }}>{`Anonymous Functions`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`> pioneers <- c(\"GAUSS:1777\", \"BAYES:1702\", \"PASCAL:1623\", \"PEARSON:1857\")\n> split <- strsplit(pioneers, split = \":\")\n> split_low <- lapply(split, tolower)\n>\n# Transform: use anonymous function inside lapply\n> names <- lapply(split_low, function(x) {\n    x[1]\n  })\n>\n# Transform: use anonymous function inside lapply\n> years <- lapply(split_low, function(x) {\n    x[2]\n  })\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Definition of split_low\n> pioneers <- c(\"GAUSS:1777\", \"BAYES:1702\", \"PASCAL:1623\", \"PEARSON:1857\")\n> split <- strsplit(pioneers, split = \":\")\n> split_low <- lapply(split, tolower)\n>\n# Generic select function\n> select_el <- function(x, index) {\n    x[index]\n  }\n>\n# Use lapply() twice on split_low: names and years\n> names <- lapply(split_low, select_el, index=1)\n> years <- lapply(split_low, select_el, index=2)\n`}</code></pre>\n    <hr></hr>\n    <h3 {...{\n      \"id\": \"sapply\"\n    }}>{`sapply`}</h3>\n    <p>{`Whereas lapply() returns a list, sapply() - instead of unlist() function on that returned list, we can used sapply() for \"simplified apply\" and it will result in a named vector. We can also have matrices retured too!`}</p>\n    <p><inlineCode parentName=\"p\">{`sapply(X, FUNC, USE.NAMES = TRUE)`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{}}>{`> temp\n[[1]]\n[1]  3  7  9  6 -1\n\n[[2]]\n[1]  6  9 12 13  5\n\n[[3]]\n[1]  4  8  3 -1 -3\n\n[[4]]\n[1]  1  4  7  2 -2\n\n[[5]]\n[1] 5 7 9 4 2\n\n[[6]]\n[1] -3  5  8  9  4\n\n[[7]]\n[1] 3 6 9 4 1\n\n# temp has already been defined in the workspace\n>\n# Use lapply() to find each day's minimum temperature\n> lapply(temp, min)\n[[1]]\n[1] -1\n\n[[2]]\n[1] 5\n\n[[3]]\n[1] -3\n\n[[4]]\n[1] -2\n\n[[5]]\n[1] 2\n\n[[6]]\n[1] -3\n\n[[7]]\n[1] 1\n>\n# Use sapply() to find each day's minimum temperature\n> sapply(temp, min)\n[1] -1  5 -3 -2  2 -3  1\n>\n# Use lapply() to find each day's maximum temperature\n> lapply(temp, max)\n[[1]]\n[1] 9\n\n[[2]]\n[1] 13\n\n[[3]]\n[1] 8\n\n[[4]]\n[1] 7\n\n[[5]]\n[1] 9\n\n[[6]]\n[1] 9\n\n[[7]]\n[1] 9\n>\n# Use sapply() to find each day's maximum temperature\n> sapply(temp, max)\n[1]  9 13  8  7  9  9  9\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Finish function definition of extremes_avg\n> extremes_avg <- function(x) {\n    ( min(x) + max(x) ) / 2\n  }\n>\n# Apply extremes_avg() over temp using sapply()\n> sapply(temp, extremes_avg)\n[1] 4.0 9.0 2.5 2.5 5.5 3.0 5.0\n>\n# Apply extremes_avg() over temp using lapply()\n> lapply(temp, extremes_avg)\n[[1]]\n[1] 4\n\n[[2]]\n[1] 9\n\n[[3]]\n[1] 2.5\n\n[[4]]\n[1] 2.5\n\n[[5]]\n[1] 5.5\n\n[[6]]\n[1] 3\n\n[[7]]\n[1] 5\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# temp is already available in the workspace\n>\n# Create a function that returns min and max of a vector: extremes\n> extremes <- function(x) {\n    c(min = min(x), max = max(x))\n  }\n>\n# Apply extremes() over temp with sapply()\n> sapply(temp, extremes)\n    [,1] [,2] [,3] [,4] [,5] [,6] [,7]\nmin   -1    5   -3   -2    2   -3    1\nmax    9   13    8    7    9    9    9\n>\n# Apply extremes() over temp with lapply()\n> lapply(temp, extremes)\n[[1]]\nmin max\n -1   9\n\n[[2]]\nmin max\n  5  13\n\n[[3]]\nmin max\n -3   8\n\n[[4]]\nmin max\n -2   7\n\n[[5]]\nmin max\n  2   9\n\n[[6]]\nmin max\n -3   9\n\n[[7]]\nmin max\n  1   9\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# temp is already prepared for you in the workspace\n>\n# Definition of below_zero()\n> below_zero <- function(x) {\n    return(x[x < 0])\n  }\n>\n# Apply below_zero over temp using sapply(): freezing_s\n> freezing_s <- sapply(temp, below_zero)\n>\n# Apply below_zero over temp using lapply(): freezing_l\n> freezing_l <- lapply(temp, below_zero)\n>\n# Are freezing_s and freezing_l identical?\n> identical(freezing_l, freezing_s)\n[1] TRUE\n`}</code></pre>\n    <p><strong parentName=\"p\">{`sapply with Null values`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Definition of print_info()\n> print_info <- function(x) {\n    cat(\"The average temperature is\", mean(x), \"\\\\n\")\n  }\n>\n# Apply print_info() over temp using sapply()\n> null_s <- sapply(temp, print_info)\nThe average temperature is 4.8\nThe average temperature is 9\nThe average temperature is 2.2\nThe average temperature is 2.4\nThe average temperature is 5.4\nThe average temperature is 4.6\nThe average temperature is 4.6\n>\n# Apply print_info() over temp using lapply()\n> null_l <- lapply(temp, print_info)\nThe average temperature is 4.8\nThe average temperature is 9\nThe average temperature is 2.2\nThe average temperature is 2.4\nThe average temperature is 5.4\nThe average temperature is 4.6\nThe average temperature is 4.6\n>\n> identical(null_l, null_s)\n[1] TRUE\n`}</code></pre>\n    <hr></hr>\n    <h3 {...{\n      \"id\": \"vapply\"\n    }}>{`vapply()`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`lapply() : apply function over list or vector\noutput = list\n\nsapply() : apply function over list or vector\ntry to simplify list to array\n\nvapply() : apply function over list or vector\nexplicitly specify output format\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Definition of basics()\n> basics <- function(x) {\n    c(min = min(x), mean = mean(x), max = max(x))\n  }\n>\n# Apply basics() over temp using vapply()\n> vapply(temp, basics, numeric(3))\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\nmin  -1.0    5 -3.0 -2.0  2.0 -3.0  1.0\nmean  4.8    9  2.2  2.4  5.4  4.6  4.6\nmax   9.0   13  8.0  7.0  9.0  9.0  9.0\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Convert to vapply() expression\n> vapply(temp, max, numeric(1))\n[1]  9 13  8  7  9  9  9\n>\n# Convert to vapply() expression\n> vapply(temp, function(x, y) { mean(x) > y }, y = 5, logical(1))\n[1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"useful-functions\"\n    }}>{`Useful Functions`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`sapply(), lapply(), vapply()\nsort()\nprint()\nidentical()\nmean()\nround()\nabs()\n\n// funcs for data structures\nseq()\nrep() // replicate\nis.*()\nas.*()\nunlist()\nappend()\nrev()\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Math Utils`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`> errors <- c(1.9, -2.6, 4.0, -9.5, -3.4, 7.3)\n>\n# Sum of absolute rounded values of errors\n> sum(round(abs(errors)))\n[1] 29\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# Don't edit these two lines\n> vec1 <- c(1.5, 2.5, 8.4, 3.7, 6.3)\n> vec2 <- rev(vec1)\n>\n# Fix the error\n> mean(c(abs(vec1), abs(vec2)))\n[1] 4.48\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"data-utilities\"\n    }}>{`Data Utilities`}</h3>\n    <p>{`R features a bunch of functions to juggle around with data structures::`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`seq(): Generate sequences, by specifying the from, to and by arguments.\nrep(): Replicate elements of vectors and lists.\nsort(): Sort a vector in ascending order. Works on numerics, but also on character strings and logicals.\nrev(): Reverse the elements in a data structures for which reversal is defined.\nstr(): Display the structure of any R object.\nappend(): Merge vectors or lists.\nis.*(): Check for the class of an R object.\nas.*(): Convert an R object from one class to another.\nunlist(): Flatten (possibly embedded) lists to produce a vector.\n`}</code></pre>\n    <p>{`Remember the social media profile view data? Your LinkedIn and Facebook view counts for the last seven days are already defined as lists on the right.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The linkedin and facebook lists have already been created for you\n> linkedin <- list(16, 9, 13, 5, 2, 17, 14)\n> facebook <- list(17, 7, 5, 16, 8, 13, 14)\n>\n# Convert linkedin and facebook to a vector: li_vec and fb_vec\n> li_vec <- unlist(linkedin)\n> fb_vec <- unlist(facebook)\n>\n# Append fb_vec to li_vec: social_vec\n> social_vec <- append(li_vec, fb_vec)\n>\n# Sort social_vec\n> sort(social_vec, decreasing = TRUE)\n [1] 17 17 16 16 14 14 13 13  9  8  7  5  5  2\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`> rep(seq(1, 7, by = 2), times = 7)\n [1] 1 3 5 7 1 3 5 7 1 3 5 7 1 3 5 7 1 3 5 7 1 3 5 7 1 3 5 7\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"beat-gauss-using-r\"\n    }}>{`Beat Gauss using R`}</h3>\n    <p>{`There is a popular story about young Gauss. As a pupil, he had a lazy teacher who wanted to keep the classroom busy by having them add up the numbers 1 to 100. Gauss came up with an answer almost instantaneously, 5050. On the spot, he had developed a formula for calculating the sum of an arithmetic series. There are more general formulas for calculating the sum of an arithmetic series with different starting values and increments. Instead of deriving such a formula, why not use R to calculate the sum of a sequence?`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Create first sequence: seq1\n> seq1 <- seq(1, 500, 3)\n>\n# Create second sequence: seq2\n> seq2 <- seq(1200, 900, -7)\n>\n# Calculate total sum of the sequences\n> sum(seq1, seq2)\n[1] 87029\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"regex\"\n    }}>{`Regex`}</h3>\n    <pre><code parentName=\"pre\" {...{}}>{`grepl(patter = <regex>, x = <string>)\n\nanimals <- c(\"cat\", \"moose\")\ngrepl(\"a\", animals)\nTRUE FALSE\n\nsub(pattern = <regex>, replacement = <str>, x = <str>)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`# The emails vector has already been defined for you\n> emails <- c(\"john.doe@ivyleague.edu\", \"education@world.gov\", \"dalai.lama@peace.org\",\n              \"invalid.edu\", \"quant@bigdatacollege.edu\", \"cookie.monster@sesame.tv\")\n>\n# Use grepl() to match for \"edu\"\n> grepl(\"edu\", emails)\n[1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n>\n# Use grep() to match for \"edu\", save result to hits\n> hits <- grep(\"edu\", emails)\n>\n# Subset emails using hits\n> emails[hits]\n[1] \"john.doe@ivyleague.edu\"   \"education@world.gov\"\n[3] \"invalid.edu\"              \"quant@bigdatacollege.edu\"\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`@, because a valid email must contain an at-sign.`}</li>\n      <li parentName=\"ul\">{`.`}<em parentName=\"li\">{`, which matches any character (.) zero or more times (`}</em>{`). Both the dot and the asterisk are metacharacters. You can use them to match any character between the at-sign and the \".edu\" portion of an email address.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`# The emails vector has already been defined for you\n> emails <- c(\"john.doe@ivyleague.edu\", \"education@world.gov\", \"dalai.lama@peace.org\",\n              \"invalid.edu\", \"quant@bigdatacollege.edu\", \"cookie.monster@sesame.tv\")\n>\n# Use grepl() to match for .edu addresses more robustly\n> grepl(\"@.*\\\\\\\\.edu$\", emails)\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n>\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"sub--gsub\"\n    }}>{`sub & gsub`}</h3>\n    <p>{`While grep() and grepl() were used to simply check whether a regular expression could be matched with a character vector, sub() and gsub() take it one step further: you can specify a replacement argument. If inside the character vector x, the regular expression pattern is found, the matching element(s) will be replaced with replacement.sub() only replaces the first match, whereas gsub() replaces all matches.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# The emails vector has already been defined for you\n> emails <- c(\"john.doe@ivyleague.edu\", \"education@world.gov\", \"dalai.lama@peace.org\",\n              \"invalid.edu\", \"quant@bigdatacollege.edu\", \"cookie.monster@sesame.tv\")\n>\n# Use sub() to convert the email domains to datacamp.edu\n> sub(\"@.*\\\\\\\\.edu$\", \"@datacamp.edu\", emails)\n[1] \"john.doe@datacamp.edu\"    \"education@world.gov\"\n[3] \"dalai.lama@peace.org\"     \"invalid.edu\"\n[5] \"quant@datacamp.edu\"       \"cookie.monster@sesame.tv\"\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"times--dates\"\n    }}>{`Times & Dates`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`today <- Sys.Date()\ntoday\n# prints date\n\n# for a timestamp\nnow <- Sys.time()\n\nmy_date <- as.Date(\"1975-14-05\", format = \"%Y-%d-%m\")\n\n# format must be specified if you change from Y-m-d\n\n> now <- Sys.time()\n> now\n[1] \"2016-11-20 09:36:43 AEDT\"\n\n# adding days\n\n> mydate\n[1] \"2016-11-20\"\n> mydate + 1\n[1] \"2016-11-21\"\n\n# difference in dates\n\n> mydate2 <- mydate + 40\n> mydate2 - mydate\nTime difference of 40 days\n\n# posix - days since Jan 1, 1970\n# unclass time will do this calculation in seconds\n\n> unclass(mydate)\n[1] 17125\n`}</code></pre>\n    <p>{`In terms of packages that are good for dealing with dates and times:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`lubridate`}</li>\n      <li parentName=\"ul\">{`zoo`}</li>\n      <li parentName=\"ul\">{`xts`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`# Get the current date: today\n> today <- Sys.Date()\n>\n# See what today looks like under the hood\n> unclass(today)\n[1] 17124\n>\n# Get the current time: now\n> now <- Sys.time()\n>\n# See what now looks like under the hood\n> unclass(now)\n[1] 1479595508\n`}</code></pre>\n    <p>{`To create a Date object from a simple character string in R, you can use the as.Date() function. The character string has to obey a format that can be defined using a set of symbols (the examples correspond to 13 January, 1982):`}</p>\n    <p>{`%Y: 4-digit year (1982)\n%y: 2-digit year (82)\n%m: 2-digit month (01)\n%d: 2-digit day of the month (13)\n%A: weekday (Wednesday)\n%a: abbreviated weekday (Wed)\n%B: month (January)\n%b: abbreviated month (Jan)`}</p>\n    <p>{`The following R commands will all create the same Date object for 13 January, 1982:`}</p>\n    <p>{`as.Date(\"1982-01-13\")\nas.Date(\"Jan-13-82\", format = \"%b-%d-%y\")\nas.Date(\"13 January, 1982\", format = \"%d %B, %Y\")`}</p>\n    <p>{`Notice that the first line here did not need a format argument, because by default R matches your character string to the formats \"%Y-%m-%d\" or \"%Y/%m/%d\".`}</p>\n    <p>{`In addition to creating dates, you can also convert dates to character strings that use a different date notation. For this, you use the format() function. Try the following lines of code:`}</p>\n    <p>{`today <- Sys.Date()\nformat(Sys.Date(), format = \"%d %B, %Y\")\nformat(Sys.Date(), format = \"Today is a %A!\")`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Definition of character strings representing dates\n> str1 <- \"May 23, '96\"\n> str2 <- \"2012-03-15\"\n> str3 <- \"30/January/2006\"\n>\n# Convert the strings to dates: date1, date2, date3\n> date1 <- as.Date(str1, format = \"%b %d, '%y\")\n> date2 <- as.Date(str2, format = \"%Y-%m-%d\")\n> date3 <- as.Date(str3, format = \"%d/%B/%Y\")\n>\n>\n# Convert dates to formatted strings\n> format(date1, \"%A\")\n[1] \"Thursday\"\n> format(date2, \"%d\")\n[1] \"15\"\n> format(date3, \"%b %Y\")\n[1] \"Jan 2006\"\n`}</code></pre>\n    <p>{`Similar to working with dates, you can use as.POSIXct() to convert from a character string to a POSIXct object, and format() to convert from a POSIXct object to a character string. Again, you have a wide variety of symbols:`}</p>\n    <p>{`%H: hours as a decimal number (00-23)\n%M: minutes as a decimal number\n%S: seconds as a decimal number\n%T: shorthand notation for the typical format %H:%M:%S`}</p>\n    <p>{`For a full list of conversion symbols, consult the strptime documentation in the console:`}</p>\n    <p>{`?strptime`}</p>\n    <p>{`Again, as.POSIXct() uses a default format to match character strings. In this case, it's %Y-%m-%d %H:%M:%S. In this exercise, abstraction is made of different time zones.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Definition of character strings representing times\n> str1 <- \"May 23, '96 hours:23 minutes:01 seconds:45\"\n> str2 <- \"2012-3-12 14:23:08\"\n>\n# Convert the strings to POSIXct objects: time1, time2\n> time1 <- as.POSIXct(str1, format = \"%B %d, '%y hours:%H minutes:%M seconds:%S\")\n> time2 <- as.POSIXct(str2, format = \"%Y-%m-%d %H:%M:%S\")\n>\n# Convert times to formatted strings\n> format(time1, \"%M\")\n[1] \"01\"\n> format(time2, \"%I:%M %p\")\n[1] \"02:23 PM\"\n`}</code></pre>\n    <p>{`Both Date and POSIXct R objects are represented by simple numerical values under the hood. This makes calculation with time and date objects very straightforward: R performs the calculations using the underlying numerical values, and then converts the result back to human-readable time information again.`}</p>\n    <p>{`You can increment and decrement Date objects, or do actual calculations with them (try it out in the console!):`}</p>\n    <p>{`today <- Sys.Date()\ntoday + 1\ntoday - 1`}</p>\n    <p>{`as.Date(\"2015-03-12\") - as.Date(\"2015-02-27\")`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# Difference between last and first pizza day\n> day5 - day1\nTime difference of 11 days\n>\n# Create vector pizza\n> pizza <- c(day1, day2, day3, day4, day5)\n>\n# Create differences between consecutive pizza days: day_diff\n> day_diff <- diff(pizza)\n>\n# Average period between two consecutive pizza days\n> mean(day_diff)\nTime difference of 2.75 days\n`}</code></pre>\n    <p>{`Calculations using POSIXct objects are completely analogous to those using Date objects. Try to experiment with this code to increase or decrease POSIXct objects:`}</p>\n    <p>{`now <- Sys.time()\nnow + 3600 # add an hour\nnow - 3600`}{`*`}{`24 # subtract a day\nAdding or substracting time objects is also straightforward:`}</p>\n    <p>{`birth <- as.POSIXct(\"1879-03-14 14:37:23\")\ndeath <- as.POSIXct(\"1955-04-18 03:47:12\")\neinstein <- death - birth\neinstein`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`# login and logout are already defined in the workspace\n# Calculate the difference between login and logout: time_online\n> time_online <- logout - login\n>\n# Inspect the variable time_online\n> time_online\nTime differences in secs\n[1] 2305.11818   34.18472  837.18182 2397.90153 1851.30411\n>\n# Calculate the total time online\n> sum(time_online)\nTime difference of 7425.69 secs\n>\n# Calculate the average time online\n> mean(time_online)\nTime difference of 1485.138 secs\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`> astro\n       spring        summer          fall        winter\n\"20-Mar-2015\" \"25-Jun-2015\" \"23-Sep-2015\" \"22-Dec-2015\"\n\n> meteo\n           spring            summer              fall            winter\n    \"March 1, 15\"      \"June 1, 15\" \"September 1, 15\"  \"December 1, 15\"\n\n# Convert astro to vector of Date objects: astro_dates\n> astro_dates <- as.Date(astro, format=\"%d-%B-%Y\")\n>\n> astro_dates\n[1] \"2015-03-20\" \"2015-06-25\" \"2015-09-23\" \"2015-12-22\"\n# Convert meteo to vector of Date objects: meteo_dates\n> meteo_dates <- as.Date(meteo, format=\"%B %d, %y\")\n>\n> meteo_dates\n[1] \"2015-03-01\" \"2015-06-01\" \"2015-09-01\" \"2015-12-01\"\n# Calculate the maximum absolute difference between astro_dates and meteo_dates\n> max(abs(astro_dates - meteo_dates))\nTime difference of 24 days\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}