{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Examples.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Examples.md","mtime":1580448686782},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiaDEiLHsiaWQiOiJweXRob24tZXhhbXBsZXMifSwiUHl0aG9uIEV4YW1wbGVzIiksbWR4KCJwIixudWxsLCJUaGlzIHNlY3Rpb24gaXMganVzdCBhIGNvbGxlY3RvbiBvZiBpbnRlcmVzdGluZyByZWFsIHdvcmxkIHNjcmlwdHMgdGhhdCB3ZXJlIHVzZWQgZm9yIG9uZSByZWFzb24gZm9yIGFub3RoZXIuIiksbWR4KCJoMiIseyJpZCI6InNlbnRyeS1zY3JpcHQtdy1kYXRldGltZS1yZXF1ZXN0cy1jc3YtbXVsdGlwcm9jZXNzaW5nLWFuZC10aHJlYWRpbmcifSwiU2VudHJ5IFNjcmlwdCB3LyBkYXRldGltZSwgcmVxdWVzdHMsIGNzdiwgbXVsdGlwcm9jZXNzaW5nIGFuZCB0aHJlYWRpbmciKSxtZHgoInAiLG51bGwsIkEgc2NyaXB0IHVzZWQgdG8gZmV0Y2ggOTJrIGV2ZW50cyBmcm9tIFNlbnRyeSB1c2luZyBhbGwgT1MgY29yZXMgYW5kIG11bHRpdGhyZWFkaW5nLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1weXRob24ifSksIlwiXCJcIlxuUmVhZCBhbGwgdGhlIGlzc3VlIElEcyBzYXZlZCwgdGhlbiBpdGVyYXRlIHRocm91Z2gsIGZpbmQgYWxsIHRoZWlyIGlzc3VlcyBhbmQgcGFnaW5hdGUgdGhyb3VnaCBhbGxcblwiXCJcIlxuaW1wb3J0IHJlcXVlc3RzXG5pbXBvcnQgY3N2XG5pbXBvcnQgb3NcbmltcG9ydCBzeXNcbmltcG9ydCB1cmxsaWIucmVxdWVzdFxuaW1wb3J0IGRhdGV0aW1lXG5cbmZyb20gbXVsdGlwcm9jZXNzaW5nIGltcG9ydCBQb29sXG5pbXBvcnQgdGhyZWFkaW5nXG5jc3Zfd3JpdGVyX2xvY2sgPSB0aHJlYWRpbmcuTG9jaygpXG50b3RhbF9ldmVudHNfbG9jayA9IHRocmVhZGluZy5Mb2NrKClcbnJlY29yZF9sb2cgPSBUcnVlXG5cbiMgZm9yIGxvZ2dpbmdcbmlmIHJlY29yZF9sb2c6XG4gICAgb2xkX3N0ZG91dCA9IHN5cy5zdGRvdXRcbiAgICBsb2dfZmlsZSA9IG9wZW4oXCJmZXRjaF9ldmVudHNfYnlfaXNzdWUubG9nXCIsXCJ3XCIpXG4gICAgc3lzLnN0ZG91dCA9IGxvZ19maWxlXG5cblxub3JnYW5pemF0aW9uX3NsdWcgPSBcIlJFREFDVEVEXCJcbnByb2plY3Rfc2x1ZyA9IFwiUkVEQUNURURcIlxuYmFzZV91cmwgPSBcImh0dHBzOi8vc2VudHJ5LmlvL2FwaS8wXCJcblxuaGVhZGVycyA9IHtcbiAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgUkVEQUNURUQnXG59XG5cblxuY3Vyc29yID0gMFxuXG5kZWYgcG9zdF90b19zbGFjayhtZXNzYWdlKTpcbiAgICBkYXRhID0gJ3tcInRleHRcIjpcIicgKyBtZXNzYWdlICsgJ1wifSdcbiAgICB1cmwgPSAnaHR0cHM6Ly9ob29rcy5zbGFjay5jb20vc2VydmljZXMvUkVEQUNURUQvUkVEQUNURUQvUkVEQUNURUQnXG4gICAgcmVxID0gdXJsbGliLnJlcXVlc3QuUmVxdWVzdCh1cmwsIGRhdGEuZW5jb2RlKCd1dGYtOCcpLCB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30pXG4gICAgcmVzID0gdXJsbGliLnJlcXVlc3QudXJsb3BlbihyZXEpXG5cblxuIyBub3QgdGhlIGJlc3QgaWRlYSBidXQgd2hhdGV2ZXJcbnRvdGFsX2V2ZW50c193aXRoX2NvbnNvbGVfbG9ncyA9IDBcbmJyZWFkY3J1bWJzID0gRmFsc2VcbmRlZiBoYW5kbGVfZXZlbnQoZXZlbnQpOlxuICAgIHRyeTpcbiAgICAgICAgZ2xvYmFsIHRvdGFsX2V2ZW50c193aXRoX2NvbnNvbGVfbG9nc1xuICAgICAgICBnbG9iYWwgYnJlYWRjcnVtYnNcblxuICAgICAgICBldmVudF9oYXNfY29uc29sZV9icmVhZGNydW1icyA9IEZhbHNlXG4gICAgICAgICMgZ2V0IHNpbmdsZSBldmVudCBmcm9tIHRoZSBBUElcbiAgICAgICAgZXZlbnRfaWQgPSBldmVudC5nZXQoXCJldmVudElEXCIpXG4gICAgICAgIGlzc3VlX2lkID0gZXZlbnQuZ2V0KFwiZ3JvdXBJRFwiKVxuICAgICAgICBwcmludChcIkZvdW5kIGEgc2luZ2xlIGV2ZW50IHdpdGggSUQ6IFwiICsgZXZlbnRfaWQpXG4gICAgICAgIHNpbmdsZV9ldmVudF91cmwgPSBiYXNlX3VybCArIFwiL3Byb2plY3RzL1wiICsgb3JnYW5pemF0aW9uX3NsdWcgKyBcIi9cIiArIHByb2plY3Rfc2x1ZyArIFwiL2V2ZW50cy9cIiArIGV2ZW50X2lkICsgXCIvXCJcbiAgICAgICAgZXZlbnRfcmVzcG9uc2UgPSByZXF1ZXN0cy5nZXQoc2luZ2xlX2V2ZW50X3VybCwgaGVhZGVycz1oZWFkZXJzKVxuXG4gICAgICAgIHJvd19kaWN0ID0ge1xuICAgICAgICAgICAgJ2lzc3VlX2lkJzogaXNzdWVfaWQsXG4gICAgICAgICAgICAnZXZlbnRfaWQnOiBldmVudF9pZCxcbiAgICAgICAgICAgICdjb25zb2xlX291dHB1dCc6ICcnXG4gICAgICAgIH1cbiAgICAgICAgIyByZXRyZWl2ZSB0aGUgbWV0YWRhdGFcbiAgICAgICAgcHJpbnQoZidbe2RhdGV0aW1lLmRhdGV0aW1lLm5vdygpfV0gIFRyeWluZyB0byBmaW5kIGJyZWFkY3J1bWJzIGZvciBldmVudCBJRDoge2V2ZW50X2lkfScpXG4gICAgICAgIGV2ZW50X2RhdGEgPSBldmVudF9yZXNwb25zZS5qc29uKClcblxuICAgICAgICBmb3IgZW50cnkgaW4gZXZlbnRfZGF0YVsnZW50cmllcyddOlxuICAgICAgICAgICAgaWYgZW50cnlbJ3R5cGUnXSA9PSAnYnJlYWRjcnVtYnMnOlxuICAgICAgICAgICAgICAgIGJyZWFkY3J1bWJzID0gZW50cnkuZ2V0KCdkYXRhJywge30pLmdldCgndmFsdWVzJywge30pXG4gICAgICAgIGlmIGJyZWFkY3J1bWJzIGFuZCBsZW4oYnJlYWRjcnVtYnMpID4gMDpcbiAgICAgICAgICAgIGZvciBjcnVtYiBpbiBicmVhZGNydW1iczpcbiAgICAgICAgICAgICAgICBpZiBjcnVtYlsnY2F0ZWdvcnknXSA9PSAnY29uc29sZSc6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50X2hhc19jb25zb2xlX2JyZWFkY3J1bWJzID0gVHJ1ZVxuICAgICAgICAgICAgICAgICAgICBwcmludChmJ1t7ZGF0ZXRpbWUuZGF0ZXRpbWUubm93KCl9XSBGb3VuZCBhIGNvbnNvbGUgYnJlYWRjcnVtYiEnKVxuICAgICAgICAgICAgICAgICAgICByb3dfZGljdFsnY29uc29sZV9vdXRwdXQnXSA9IGNydW1iXG4gICAgICAgICAgICAgICAgICAgIHdpdGggY3N2X3dyaXRlcl9sb2NrOlxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlcm93KHJvd19kaWN0KVxuXG4gICAgICAgIGlmIGV2ZW50X2hhc19jb25zb2xlX2JyZWFkY3J1bWJzOlxuICAgICAgICAgICAgd2l0aCB0b3RhbF9ldmVudHNfbG9jazpcbiAgICAgICAgICAgICAgICB0cnk6XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsX2V2ZW50c193aXRoX2NvbnNvbGVfbG9ncyArPSAxXG4gICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxuICAgICAgICAgICAgICAgICAgICBwcmludChmJ1t7ZGF0ZXRpbWUuZGF0ZXRpbWUubm93KCl9XSBGYWlsZWQgdG8gYXBwZW5kIHRvIHRvdGFsX2V2ZW50c193aXRoX2NvbnNvbGVfbG9ncycpXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBwcmludChmJ1t7ZGF0ZXRpbWUuZGF0ZXRpbWUubm93KCl9XSAgRGlkIG5vdCBmaW5kIGFueSBicmVhZGNydW1icy4nKVxuICAgICAgICAgICAgcm93X2RpY3RbJ2NvbnNvbGVfb3V0cHV0J10gPSAnTm8gY29uc29sZSBvdXRwdXQhJ1xuICAgICAgICAgICAgd2l0aCBjc3Zfd3JpdGVyX2xvY2s6XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlcm93KHJvd19kaWN0KVxuICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZTpcbiAgICAgICAgcHJpbnQoZidGYWlsZWQgZm9yIHtldmVudC5nZXQoXCJldmVudElEXCIpfScsIGUubWVzc2FnZSlcblxuXG5kZWYgaGFuZGxlX2lzc3VlKGlzc3VlX2lkKTpcbiAgICBcIlwiXCJcbiAgICBGb3IgaXNzdWUgSUQsIGNvbnRpbnVhbGx5IGZldGNoIGFsbCBldmVudHMgYW5kIHBhZ2luYXRlIHVudGlsIHRoZXJlIGFyZSBub25lLlxuXG4gICAgV2l0aCBlYWNoIGV2ZW50LCBoYW5kbGUgaXQgc3VjaCB0aGF0IGl0IGZldGNoZXMgYW5kIGFwcGVuZHMgdGhlIHJlcXVpcmVkIGRhdGEuXG4gICAgXCJcIlwiXG4gICAgIyB3cml0ZXIud3JpdGVoZWFkZXIoKVxuICAgIGxpc3RfZXZlbnRzX3VybCA9IGYne2Jhc2VfdXJsfS9pc3N1ZXMve2lzc3VlX2lkfS9ldmVudHMvJ1xuICAgIGF0dGVtcHQgPSAxXG4gICAgd2hpbGUgbGlzdF9ldmVudHNfdXJsIGlzIG5vdCBOb25lOlxuICAgICAgICB0cnk6XG4gICAgICAgICAgICBpZiBhdHRlbXB0ID4gNTpcbiAgICAgICAgICAgICAgICBwb3N0X3RvX3NsYWNrKGYnW3tkYXRldGltZS5kYXRldGltZS5ub3coKX0gRkFJTEVEXTogUmVhY2hlZCA1IGF0dGVtcHRzIGZvciB7bGlzdF9ldmVudHNfdXJsfScpXG4gICAgICAgICAgICAgICAgbGlzdF9ldmVudHNfdXJsID0gTm9uZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAjIGdldCB0aGUgZXZlbnRzXG4gICAgICAgICAgICBwcmludChmJ1t7ZGF0ZXRpbWUuZGF0ZXRpbWUubm93KCl9XSBORVhUXSBHZXR0aW5nIHBhZ2Ugb2YgcmVzdWx0czoge2xpc3RfZXZlbnRzX3VybH0nKVxuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXF1ZXN0cy5nZXQobGlzdF9ldmVudHNfdXJsLCBoZWFkZXJzPWhlYWRlcnMpXG4gICAgICAgICAgICAjIGRhdGEgaXMgYW4gYXJyYXkgb2YgZXZlbnRzXG4gICAgICAgICAgICBkYXRhID0gcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgICBmb3IgZXZlbnQgaW4gZGF0YTpcbiAgICAgICAgICAgICAgICBoYW5kbGVfZXZlbnQoZXZlbnQpXG4gICAgICAgICAgICAjIGlzIHRoZXJlIGFub3RoZXIgcGFnZSBvZiBldmVudHM/XG4gICAgICAgICAgICBsaW5rID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMaW5rXCIpXG4gICAgICAgICAgICAjIHJlc2V0IGF0dGVtcHQgaWYgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgYXR0ZW1wdCA9IDFcbiAgICAgICAgICAgIGlmIGxpbmsgYW5kICdyZWw9XCJuZXh0XCI7IHJlc3VsdHM9XCJ0cnVlXCInIGluIGxpbms6XG4gICAgICAgICAgICAgICAgcG9zdF90b19zbGFjayhmJ1t7ZGF0ZXRpbWUuZGF0ZXRpbWUubm93KCl9IFNVQ0NFU1NdOiBGaW5pc2hlZCByZXN1bHRzIGZvciB7bGlzdF9ldmVudHNfdXJsfScpXG4gICAgICAgICAgICAgICAgbGlzdF9ldmVudHNfdXJsID0gbGluay5zcGxpdCgpWzRdWzE6LTJdXG4gICAgICAgICAgICAgICAgcHJpbnQoZidbe2RhdGV0aW1lLmRhdGV0aW1lLm5vdygpfSBORVhUXTogR2V0dGluZyBhbm90aGVyIHBhZ2Ugb2YgZXZlbnQgZnJvbSBpc3N1ZV9pZCB7aXNzdWVfaWR9IC0gVVJMIHtsaW5rfS4nKVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBwb3N0X3RvX3NsYWNrKGYnW3tkYXRldGltZS5kYXRldGltZS5ub3coKX0gU1VDQ0VTU106IEZpbmlzaGVkIHJlc3VsdHMgZm9yIHtsaXN0X2V2ZW50c191cmx9JylcbiAgICAgICAgICAgICAgICBsaXN0X2V2ZW50c191cmwgPSBOb25lXG4gICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZTpcbiAgICAgICAgICAgIHByaW50KGYnW3tkYXRldGltZS5kYXRldGltZS5ub3coKX0gV0FSTklOR11GZXRjaCBhdHRlbXB0IHthdHRlbXB0fSBmYWlsZWQ6IHtsaXN0X2V2ZW50c191cmx9JywgZSlcbiAgICAgICAgICAgIHBvc3RfdG9fc2xhY2tcbiAgICAgICAgICAgIGF0dGVtcHQgKz0gMVxuXG50cnk6XG4gICAgd2l0aCBvcGVuKCcuL2ZldGNoX2V2ZW50c19ieV9pc3N1ZS5jc3YnLCAndycpIGFzIG91dHB1dF9maWxlOlxuICAgICAgICBmaWVsZG5hbWVzID0gWydpc3N1ZV9pZCcsICdldmVudF9pZCcsICdjb25zb2xlX291dHB1dCddXG4gICAgICAgIHdyaXRlciA9IGNzdi5EaWN0V3JpdGVyKG91dHB1dF9maWxlLCBmaWVsZG5hbWVzPWZpZWxkbmFtZXMpXG4gICAgICAgIHByaW50KGYnW3tkYXRldGltZS5kYXRldGltZS5ub3coKX1Xcml0aW5nIGhlYWRlcnMgZm9yIGNzdicpXG4gICAgICAgIHdpdGggb3BlbignLi9wcm9qZWN0X2lzc3Vlcy5jc3YnLCAncicpIGFzIGZpbGU6XG4gICAgICAgICAgICBkYXRhID0gZmlsZS5yZWFkKCkuc3BsaXRsaW5lcygpXG4gICAgICAgICAgICAjIHVzZSBhdHRlbXB0cyB0byBnaXZlIHVwIGFmdGVyIHRyeWluZyAxMCB0aW1lcyBvbiB0aGUgc2FtZSBVUkxcbiAgICAgICAgICAgIGNodW5rc2l6ZSA9IDFcbiAgICAgICAgICAgIHByb2NfY291bnQgPSBvcy5jcHVfY291bnQoKVxuICAgICAgICAgICAgd2l0aCBQb29sKHByb2Nlc3Nlcz1wcm9jX2NvdW50KSBhcyBwb29sOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBvb2wubWFwKGhhbmRsZV9pc3N1ZSwgZGF0YSwgY2h1bmtzaXplKVxuXG5cbmV4Y2VwdDpcbiAgICBwb3N0X3RvX3NsYWNrKGYnW3tkYXRldGltZS5kYXRldGltZS5ub3coKX0gRkFJTEVEXTogU2NyaXB0IGNyYXNoZWQnKVxuZmluYWxseTpcbiAgICBwb3N0X3RvX3NsYWNrKGYnW3tkYXRldGltZS5kYXRldGltZS5ub3coKX0gQ09NUExFVEVEXTogU2NyaXB0IGZpbmlzaGVkJylcbiAgICBpZiByZWNvcmRfbG9nOlxuICAgICAgICBzeXMuc3Rkb3V0ID0gb2xkX3N0ZG91dFxuICAgICAgICBsb2dfZmlsZS5jbG9zZSgpXG4iKSkpO31pZih0eXBlb2YgTURYQ29udGVudCE9PSd1bmRlZmluZWQnJiZNRFhDb250ZW50JiZNRFhDb250ZW50PT09T2JqZWN0KE1EWENvbnRlbnQpJiZPYmplY3QuaXNFeHRlbnNpYmxlKE1EWENvbnRlbnQpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoTURYQ29udGVudCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiTURYQ29udGVudCIsZmlsZW5hbWU6Im1hbnVhbC9QeXRob24vRXhhbXBsZXMubWQifX0pO31NRFhDb250ZW50LmlzTURYQ29tcG9uZW50PXRydWU7"},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Examples.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"iMAAA,cACE,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,GAAT,KAAoB,eAApB,CACA,cAGF,GAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAAAC,IAAI,QAAI,SAASC,CAAAA,mBAAT,CAA6BC,KAA7B,CAAoC,CAChEC,OAAO,CAACC,IAAR,CAAa,aAAeJ,IAAf,CAAsB,yEAAnC,EACA,MAAO,WAASE,KAAT,CAAP,CACD,CAHyB,EAA1B,CAKA,GAAMG,CAAAA,WAAW,CAAG,EAApB,CAGA,GAAMC,CAAAA,SAAS,CAAG,SAAlB,CACA,cAAe,SAASC,CAAAA,UAAT,MAGZ,IAFDC,CAAAA,UAEC,MAFDA,UAEC,CADEN,KACF,+CACD,MAAO,KAAC,SAAD,kBAAeG,WAAf,CAAgCH,KAAhC,EAAuC,UAAU,CAAEM,UAAnD,CAA+D,OAAO,CAAC,WAAvE,GACL,SAAQ,CACN,KAAM,iBADA,CAAR,mBADK,CAIL,6HAJK,CAKL,SAAQ,CACN,KAAM,qEADA,CAAR,2EALK,CAQL,oGARK,CASL,eAAK,0BAAM,UAAU,CAAC,KAAjB,EAA2B,CAC5B,YAAa,iBADe,CAA3B,kyLAAL,CATK,CAAP,CAqKD,C,qQAEDD,UAAU,CAACE,cAAX,CAA4B,IAA5B","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"python-examples\"\n    }}>{`Python Examples`}</h1>\n    <p>{`This section is just a collecton of interesting real world scripts that were used for one reason for another.`}</p>\n    <h2 {...{\n      \"id\": \"sentry-script-w-datetime-requests-csv-multiprocessing-and-threading\"\n    }}>{`Sentry Script w/ datetime, requests, csv, multiprocessing and threading`}</h2>\n    <p>{`A script used to fetch 92k events from Sentry using all OS cores and multithreading.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`\"\"\"\nRead all the issue IDs saved, then iterate through, find all their issues and paginate through all\n\"\"\"\nimport requests\nimport csv\nimport os\nimport sys\nimport urllib.request\nimport datetime\n\nfrom multiprocessing import Pool\nimport threading\ncsv_writer_lock = threading.Lock()\ntotal_events_lock = threading.Lock()\nrecord_log = True\n\n# for logging\nif record_log:\n    old_stdout = sys.stdout\n    log_file = open(\"fetch_events_by_issue.log\",\"w\")\n    sys.stdout = log_file\n\n\norganization_slug = \"REDACTED\"\nproject_slug = \"REDACTED\"\nbase_url = \"https://sentry.io/api/0\"\n\nheaders = {\n    'Authorization': 'Bearer REDACTED'\n}\n\n\ncursor = 0\n\ndef post_to_slack(message):\n    data = '{\"text\":\"' + message + '\"}'\n    url = 'https://hooks.slack.com/services/REDACTED/REDACTED/REDACTED'\n    req = urllib.request.Request(url, data.encode('utf-8'), {'Content-Type': 'application/json'})\n    res = urllib.request.urlopen(req)\n\n\n# not the best idea but whatever\ntotal_events_with_console_logs = 0\nbreadcrumbs = False\ndef handle_event(event):\n    try:\n        global total_events_with_console_logs\n        global breadcrumbs\n\n        event_has_console_breadcrumbs = False\n        # get single event from the API\n        event_id = event.get(\"eventID\")\n        issue_id = event.get(\"groupID\")\n        print(\"Found a single event with ID: \" + event_id)\n        single_event_url = base_url + \"/projects/\" + organization_slug + \"/\" + project_slug + \"/events/\" + event_id + \"/\"\n        event_response = requests.get(single_event_url, headers=headers)\n\n        row_dict = {\n            'issue_id': issue_id,\n            'event_id': event_id,\n            'console_output': ''\n        }\n        # retreive the metadata\n        print(f'[{datetime.datetime.now()}]  Trying to find breadcrumbs for event ID: {event_id}')\n        event_data = event_response.json()\n\n        for entry in event_data['entries']:\n            if entry['type'] == 'breadcrumbs':\n                breadcrumbs = entry.get('data', {}).get('values', {})\n        if breadcrumbs and len(breadcrumbs) > 0:\n            for crumb in breadcrumbs:\n                if crumb['category'] == 'console':\n                    event_has_console_breadcrumbs = True\n                    print(f'[{datetime.datetime.now()}] Found a console breadcrumb!')\n                    row_dict['console_output'] = crumb\n                    with csv_writer_lock:\n                        writer.writerow(row_dict)\n\n        if event_has_console_breadcrumbs:\n            with total_events_lock:\n                try:\n                    total_events_with_console_logs += 1\n                except Exception as e:\n                    print(f'[{datetime.datetime.now()}] Failed to append to total_events_with_console_logs')\n        else:\n            print(f'[{datetime.datetime.now()}]  Did not find any breadcrumbs.')\n            row_dict['console_output'] = 'No console output!'\n            with csv_writer_lock:\n                writer.writerow(row_dict)\n    except Exception as e:\n        print(f'Failed for {event.get(\"eventID\")}', e.message)\n\n\ndef handle_issue(issue_id):\n    \"\"\"\n    For issue ID, continually fetch all events and paginate until there are none.\n\n    With each event, handle it such that it fetches and appends the required data.\n    \"\"\"\n    # writer.writeheader()\n    list_events_url = f'{base_url}/issues/{issue_id}/events/'\n    attempt = 1\n    while list_events_url is not None:\n        try:\n            if attempt > 5:\n                post_to_slack(f'[{datetime.datetime.now()} FAILED]: Reached 5 attempts for {list_events_url}')\n                list_events_url = None\n                break\n            # get the events\n            print(f'[{datetime.datetime.now()}] NEXT] Getting page of results: {list_events_url}')\n            response = requests.get(list_events_url, headers=headers)\n            # data is an array of events\n            data = response.json()\n            for event in data:\n                handle_event(event)\n            # is there another page of events?\n            link = response.headers.get(\"Link\")\n            # reset attempt if successful\n            attempt = 1\n            if link and 'rel=\"next\"; results=\"true\"' in link:\n                post_to_slack(f'[{datetime.datetime.now()} SUCCESS]: Finished results for {list_events_url}')\n                list_events_url = link.split()[4][1:-2]\n                print(f'[{datetime.datetime.now()} NEXT]: Getting another page of event from issue_id {issue_id} - URL {link}.')\n            else:\n                post_to_slack(f'[{datetime.datetime.now()} SUCCESS]: Finished results for {list_events_url}')\n                list_events_url = None\n        except Exception as e:\n            print(f'[{datetime.datetime.now()} WARNING]Fetch attempt {attempt} failed: {list_events_url}', e)\n            post_to_slack\n            attempt += 1\n\ntry:\n    with open('./fetch_events_by_issue.csv', 'w') as output_file:\n        fieldnames = ['issue_id', 'event_id', 'console_output']\n        writer = csv.DictWriter(output_file, fieldnames=fieldnames)\n        print(f'[{datetime.datetime.now()}Writing headers for csv')\n        with open('./project_issues.csv', 'r') as file:\n            data = file.read().splitlines()\n            # use attempts to give up after trying 10 times on the same URL\n            chunksize = 1\n            proc_count = os.cpu_count()\n            with Pool(processes=proc_count) as pool:\n                result = pool.map(handle_issue, data, chunksize)\n\n\nexcept:\n    post_to_slack(f'[{datetime.datetime.now()} FAILED]: Script crashed')\nfinally:\n    post_to_slack(f'[{datetime.datetime.now()} COMPLETED]: Script finished')\n    if record_log:\n        sys.stdout = old_stdout\n        log_file.close()\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}