{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Go/Go-Tour-Channels.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Go/Go-Tour-Channels.md","mtime":1569490237758},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiaDEiLHsiaWQiOiJnby10b3VyLWNoYW5uZWxzIn0sIkdvIFRvdXIgQ2hhbm5lbHMiKSxtZHgoInAiLG51bGwsIkNoYW5uZWxzIGFyZSBhIHR5cGVkIGNvbmR1aXQgdGhyb3VnaCB3aGljaCB5b3UgY2FuIHNlbmQgYW5kIHJlY2VpdmUgdmFsdWVzIHdpdGggdGhlIGNoYW5uZWwgb3BlcmF0b3IsIDwtLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1nb2xhbmcifSksImNoIDwtIHYgICAgLy8gU2VuZCB2IHRvIGNoYW5uZWwgY2guXG52IDo9IDwtY2ggIC8vIFJlY2VpdmUgZnJvbSBjaCwgYW5kXG4gICAgICAgICAgIC8vIGFzc2lnbiB2YWx1ZSB0byB2LlxuIikpLG1keCgicCIsbnVsbCwiKFRoZSBkYXRhIGZsb3dzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFycm93LikiKSxtZHgoInAiLG51bGwsIkxpa2UgbWFwcyBhbmQgc2xpY2VzLCBjaGFubmVscyBtdXN0IGJlIGNyZWF0ZWQgYmVmb3JlIHVzZToiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtZ29sYW5nIn0pLCJjaCA6PSBtYWtlKGNoYW4gaW50KVxuIikpLG1keCgicCIsbnVsbCwiQnkgZGVmYXVsdCwgc2VuZHMgYW5kIHJlY2VpdmVzIGJsb2NrIHVudGlsIHRoZSBvdGhlciBzaWRlIGlzIHJlYWR5LiBUaGlzIGFsbG93cyBnb3JvdXRpbmVzIHRvIHN5bmNocm9uaXplIHdpdGhvdXQgZXhwbGljaXQgbG9ja3Mgb3IgY29uZGl0aW9uIHZhcmlhYmxlcy4iKSxtZHgoInAiLG51bGwsIlRoZSBleGFtcGxlIGNvZGUgc3VtcyB0aGUgbnVtYmVycyBpbiBhIHNsaWNlLCBkaXN0cmlidXRpbmcgdGhlIHdvcmsgYmV0d2VlbiB0d28gZ29yb3V0aW5lcy4gT25jZSBib3RoIGdvcm91dGluZXMgaGF2ZSBjb21wbGV0ZWQgdGhlaXIgY29tcHV0YXRpb24sIGl0IGNhbGN1bGF0ZXMgdGhlIGZpbmFsIHJlc3VsdC4iKSxtZHgoImgyIix7ImlkIjoiYmFzaWMtZXhhbXBsZSJ9LCJCYXNpYyBFeGFtcGxlIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWdvbGFuZyJ9KSwicGFja2FnZSBtYWluXG5cbmltcG9ydCBcImZtdFwiXG5cbmZ1bmMgc3VtKHMgW11pbnQsIGMgY2hhbiBpbnQpIHtcbiAgICBmbXQuUHJpbnRsbihcIiV2XCIsIHMpXG4gICAgc3VtIDo9IDBcbiAgICBmb3IgXywgdiA6PSByYW5nZSBzIHtcbiAgICAgICAgc3VtICs9IHZcbiAgICB9XG4gICAgYyA8LSBzdW0gLy8gc2VuZCBzdW0gdG8gY1xufVxuXG5mdW5jIG1haW4oKSB7XG4gICAgcyA6PSBbXWludHs3LCAyLCA4LCAtOSwgNCwgMH1cblxuICAgIGMgOj0gbWFrZShjaGFuIGludClcbiAgICBnbyBzdW0oc1s6bGVuKHMpLzJdLCBjKVxuICAgIGdvIHN1bShzW2xlbihzKS8yOl0sIGMpXG4gICAgeCwgeSA6PSA8LWMsIDwtYyAvLyByZWNlaXZlIGZyb20gY1xuXG4gICAgZm10LlByaW50bG4oeCwgeSwgeCt5KVxufVxuIikpLG1keCgicCIsbnVsbCwiUHJpbnRzOiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1zaGVsbCJ9KSwiJXYgWy05IDQgMF1cbiV2IFs3IDIgOF1cbi01IDE3IDEyXG4iKSksbWR4KCJoMiIseyJpZCI6ImJ1ZmZlcmVkLWNoYW5uZWxzIn0sIkJ1ZmZlcmVkIENoYW5uZWxzIiksbWR4KCJwIixudWxsLCJDaGFubmVscyBjYW4gYmUgYnVmZmVyZWQuIFByb3ZpZGUgdGhlIGJ1ZmZlciBsZW5ndGggYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBtYWtlIHRvIGluaXRpYWxpemUgYSBidWZmZXJlZCBjaGFubmVsOiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1nb2xhbmcifSksImNoIDo9IG1ha2UoY2hhbiBpbnQsIDEwMClcbiIpKSxtZHgoInAiLG51bGwsIlNlbmRzIHRvIGEgYnVmZmVyZWQgY2hhbm5lbCBibG9jayBvbmx5IHdoZW4gdGhlIGJ1ZmZlciBpcyBmdWxsLiBSZWNlaXZlcyBibG9jayB3aGVuIHRoZSBidWZmZXIgaXMgZW1wdHkuIiksbWR4KCJwIixudWxsLCJJZiB5b3Ugb3ZlcmZsb3cgdGhlIGJ1ZmZlciwgeW91J2xsIGJlIGhpdCB3aXRoIGEgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImRlYWRsb2NrIiksIiBlcnJvci4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtZ29sYW5nIn0pLCJwYWNrYWdlIG1haW5cblxuaW1wb3J0IFwiZm10XCJcblxuZnVuYyBtYWluKCkge1xuICAgIGNoIDo9IG1ha2UoY2hhbiBpbnQsIDIpXG4gICAgY2ggPC0gMVxuICAgIGNoIDwtIDJcbiAgICBmbXQuUHJpbnRsbig8LWNoKVxuICAgIGZtdC5QcmludGxuKDwtY2gpXG59XG4iKSksbWR4KCJoMiIseyJpZCI6InJhbmdlLWFuZC1jbG9zZSJ9LCJSYW5nZSBhbmQgQ2xvc2UiKSxtZHgoInAiLG51bGwsIkEgc2VuZGVyIGNhbiBjbG9zZSBhIGNoYW5uZWwgdG8gaW5kaWNhdGUgdGhhdCBubyBtb3JlIHZhbHVlcyB3aWxsIGJlIHNlbnQuIFJlY2VpdmVycyBjYW4gdGVzdCB3aGV0aGVyIGEgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQgYnkgYXNzaWduaW5nIGEgc2Vjb25kIHBhcmFtZXRlciB0byB0aGUgcmVjZWl2ZSBleHByZXNzaW9uOiBhZnRlciIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1nb2xhbmcifSksInYsIG9rIDo9IDwtY2hcbiIpKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJvayIpLCIgaXMgZmFsc2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgdmFsdWVzIHRvIHJlY2VpdmUgYW5kIHRoZSBjaGFubmVsIGlzIGNsb3NlZC4iKSxtZHgoInAiLG51bGwsIlRoZSBsb29wIGZvciAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiaSA6PSByYW5nZSBjIiksIiByZWNlaXZlcyB2YWx1ZXMgZnJvbSB0aGUgY2hhbm5lbCByZXBlYXRlZGx5IHVudGlsIGl0IGlzIGNsb3NlZC4iKSxtZHgoInAiLG51bGwsIk5vdGU6IE9ubHkgdGhlIHNlbmRlciBzaG91bGQgY2xvc2UgYSBjaGFubmVsLCBuZXZlciB0aGUgcmVjZWl2ZXIuIFNlbmRpbmcgb24gYSBjbG9zZWQgY2hhbm5lbCB3aWxsIGNhdXNlIGEgcGFuaWMuIiksbWR4KCJwIixudWxsLCJBbm90aGVyIG5vdGU6IENoYW5uZWxzIGFyZW4ndCBsaWtlIGZpbGVzOyB5b3UgZG9uJ3QgdXN1YWxseSBuZWVkIHRvIGNsb3NlIHRoZW0uIENsb3NpbmcgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiB0aGUgcmVjZWl2ZXIgbXVzdCBiZSB0b2xkIHRoZXJlIGFyZSBubyBtb3JlIHZhbHVlcyBjb21pbmcsIHN1Y2ggYXMgdG8gdGVybWluYXRlIGEgcmFuZ2UgbG9vcC4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtZ29sYW5nIn0pLCJwYWNrYWdlIG1haW5cblxuaW1wb3J0IChcbiAgICBcImZtdFwiXG4pXG5cbmZ1bmMgZmlib25hY2NpKG4gaW50LCBjIGNoYW4gaW50KSB7XG4gICAgeCwgeSA6PSAwLCAxXG4gICAgZm9yIGkgOj0gMDsgaSA8IG47IGkrKyB7XG4gICAgICAgIGMgPC0geFxuICAgICAgICB4LCB5ID0geSwgeCt5XG4gICAgfVxuICAgIGNsb3NlKGMpXG59XG5cbmZ1bmMgbWFpbigpIHtcbiAgICBjIDo9IG1ha2UoY2hhbiBpbnQsIDEwKVxuICAgIGdvIGZpYm9uYWNjaShjYXAoYyksIGMpXG4gICAgZm9yIGkgOj0gcmFuZ2UgYyB7XG4gICAgICAgIGZtdC5QcmludGxuKGkpXG4gICAgfVxufVxuIikpLG1keCgicCIsbnVsbCwiVGhpcyBwcmludHM6IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLXNoZWxsIn0pLCIwXG4xXG4xXG4yXG4zXG41XG44XG4xM1xuMjFcbjM0XG4iKSksbWR4KCJoMiIseyJpZCI6InNlbGVjdCJ9LCJTZWxlY3QiKSxtZHgoInAiLG51bGwsIlRoZSBzZWxlY3Qgc3RhdGVtZW50IGxldHMgYSBnb3JvdXRpbmUgd2FpdCBvbiBtdWx0aXBsZSBjb21tdW5pY2F0aW9uIG9wZXJhdGlvbnMuIiksbWR4KCJwIixudWxsLCJBIHNlbGVjdCBibG9ja3MgdW50aWwgb25lIG9mIGl0cyBjYXNlcyBjYW4gcnVuLCB0aGVuIGl0IGV4ZWN1dGVzIHRoYXQgY2FzZS4gSXQgY2hvb3NlcyBvbmUgYXQgcmFuZG9tIGlmIG11bHRpcGxlIGFyZSByZWFkeS4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtZ29sYW5nIn0pLCJwYWNrYWdlIG1haW5cblxuaW1wb3J0IFwiZm10XCJcblxuZnVuYyBmaWJvbmFjY2koYywgcXVpdCBjaGFuIGludCkge1xuICAgIHgsIHkgOj0gMCwgMVxuICAgIGZvciB7XG4gICAgICAgIHNlbGVjdCB7XG4gICAgICAgIGNhc2UgYyA8LSB4OlxuICAgICAgICAgICAgeCwgeSA9IHksIHgreVxuICAgICAgICBjYXNlIDwtcXVpdDpcbiAgICAgICAgICAgIGZtdC5QcmludGxuKFwicXVpdFwiKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmMgbWFpbigpIHtcbiAgICBjIDo9IG1ha2UoY2hhbiBpbnQpXG4gICAgcXVpdCA6PSBtYWtlKGNoYW4gaW50KVxuICAgIGdvIGZ1bmMoKSB7XG4gICAgICAgIGZvciBpIDo9IDA7IGkgPCAxMDsgaSsrIHtcbiAgICAgICAgICAgIGZtdC5QcmludGxuKDwtYylcbiAgICAgICAgfVxuICAgICAgICBxdWl0IDwtIDBcbiAgICB9KClcbiAgICBmaWJvbmFjY2koYywgcXVpdClcbn1cbiIpKSxtZHgoInAiLG51bGwsIkFmdGVyIGxvb3BpbmcgdGhyb3VnaCBpbiB0aGUgSUlGRSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiZ28gZnVuYyIpLCIsIGl0IHdpbGwgc2VuZCBhIDAgdG8gdGhlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJxdWl0IiksIiBjaGFubmVsIGFuZCAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwic2VsZWN0IiksIiB3aWxsIGhhbmRsZSBieSBwcmludGluZyBcInF1aXRcIiBhbmQgcmV0dXJuaW5nIGZyb20gdGhlIGluZmluaXRlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJmb3IiKSwiIGxvb3AuIiksbWR4KCJoMiIseyJpZCI6ImRlZmF1bHQtc2VsZWN0aW9uIn0sIkRlZmF1bHQgU2VsZWN0aW9uIiksbWR4KCJwIixudWxsLCJUaGUgZGVmYXVsdCBjYXNlIGluIGEgc2VsZWN0IGlzIHJ1biBpZiBubyBvdGhlciBjYXNlIGlzIHJlYWR5LiIpLG1keCgicCIsbnVsbCwiVXNlIGEgZGVmYXVsdCBjYXNlIHRvIHRyeSBhIHNlbmQgb3IgcmVjZWl2ZSB3aXRob3V0IGJsb2NraW5nOiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1nb2xhbmcifSksInNlbGVjdCB7XG5jYXNlIGkgOj0gPC1jOlxuICAgIC8vIHVzZSBpXG5kZWZhdWx0OlxuICAgIC8vIHJlY2VpdmluZyBmcm9tIGMgd291bGQgYmxvY2tcbn1cbiIpKSxtZHgoInAiLG51bGwsIkV4YW1wbGU6IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWdvbGFuZyJ9KSwicGFja2FnZSBtYWluXG5cbmltcG9ydCAoXG4gICAgXCJmbXRcIlxuICAgIFwidGltZVwiXG4pXG5cbmZ1bmMgbWFpbigpIHtcbiAgICB0aWNrIDo9IHRpbWUuVGljaygxMDAgKiB0aW1lLk1pbGxpc2Vjb25kKVxuICAgIGJvb20gOj0gdGltZS5BZnRlcig1MDAgKiB0aW1lLk1pbGxpc2Vjb25kKVxuICAgIGZvciB7XG4gICAgICAgIHNlbGVjdCB7XG4gICAgICAgIGNhc2UgPC10aWNrOlxuICAgICAgICAgICAgZm10LlByaW50bG4oXCJ0aWNrLlwiKVxuICAgICAgICBjYXNlIDwtYm9vbTpcbiAgICAgICAgICAgIGZtdC5QcmludGxuKFwiQk9PTSFcIilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZm10LlByaW50bG4oXCIgICAgLlwiKVxuICAgICAgICAgICAgdGltZS5TbGVlcCg1MCAqIHRpbWUuTWlsbGlzZWNvbmQpXG4gICAgICAgIH1cbiAgICB9XG59XG4iKSksbWR4KCJoMiIseyJpZCI6ImV4YW1wbGUtZXF1aXZhbGVudC1iaW5hcnktdHJlZXMifSwiRXhhbXBsZTogRXF1aXZhbGVudCBCaW5hcnkgVHJlZXMiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtZ29sYW5nIn0pLCJwYWNrYWdlIG1haW5cblxuaW1wb3J0IChcbiAgXCJnb2xhbmcub3JnL3gvdG91ci90cmVlXCJcbiAgXCJmbXRcIlxuKVxuXG4vLyBXYWxrIHdhbGtzIHRoZSB0cmVlIHQgc2VuZGluZyBhbGwgdmFsdWVzXG4vLyBmcm9tIHRoZSB0cmVlIHRvIHRoZSBjaGFubmVsIGNoLlxuZnVuYyBXYWxrKHQgKnRyZWUuVHJlZSwgY2ggY2hhbiBpbnQpIHtcbiAgICBkZWZlciBjbG9zZShjaCkgLy8gPC0gY2xvc2VzIHRoZSBjaGFubmVsIHdoZW4gdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gIHZhciB3YWxrIGZ1bmModCAqdHJlZS5UcmVlKVxuICB3YWxrID0gZnVuYyh0ICp0cmVlLlRyZWUpIHtcbiAgICAgIGlmIHQgPT0gbmlsIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHdhbGsodC5MZWZ0KVxuICAgICAgY2ggPC0gdC5WYWx1ZVxuICAgICAgd2Fsayh0LlJpZ2h0KVxuICB9XG4gIHdhbGsodClcbn1cblxuLy8gU2FtZSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRyZWVzXG4vLyB0MSBhbmQgdDIgY29udGFpbiB0aGUgc2FtZSB2YWx1ZXMuXG5mdW5jIFNhbWUodDEsIHQyICp0cmVlLlRyZWUpIGJvb2wge1xuICAgIGRvbmUgOj0gbWFrZSAoY2hhbiBib29sKVxuICAgIGRlZmVyIGNsb3NlKGRvbmUpXG5cbiAgICBjaDEgOj0gbWFrZShjaGFuIGludClcbiAgICBjaDIgOj0gbWFrZShjaGFuIGludClcbiAgICBnbyBXYWxrKHQxLCBjaDEpXG4gICAgZ28gV2Fsayh0MiwgY2gyKVxuXG4gICAgZ28gZnVuYygpIHtcbiAgICAgICAgZm9yIGkgOj0gcmFuZ2UgY2gxIHtcbiAgICAgICAgICAgIGogOj0gPC1jaDJcbiAgICAgICAgICAgIGZtdC5QcmludGxuKFwiaTogJXZcIiwgaSlcbiAgICAgICAgICAgIGZtdC5QcmludGxuKFwiajogJXZcIiwgailcblxuICAgICAgICAgICAgaWYgaSAhPSBqIHtcbiAgICAgICAgICAgICAgICBkb25lIDwtIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA8LSB0cnVlXG4gICAgfSgpXG4gICAgcmV0dXJuIDwtZG9uZVxufVxuXG5mdW5jIG1haW4oKSB7XG4gICAgY2ggOj0gbWFrZShjaGFuIGludClcbiAgICBnbyBXYWxrKHRyZWUuTmV3KDEpLCBjaClcblxuICAgIGZvciBpIDo9IDE7IGkgPD0gMTA7IGkrKyB7XG4gICAgICAgIGZtdC5QcmludGxuKDwtY2gpXG4gICAgfVxuXG4gICAgdDEgOj0gdHJlZS5OZXcoMSlcbiAgICB0MiA6PSB0cmVlLk5ldygyKVxuXG4gICAgcmVzMSA6PSBTYW1lKHQxLCB0MSlcbiAgICBmbXQuUHJpbnRsbihcIlJlcyAxOiAldlwiLCByZXMxKVxuXG4gICAgcmVzMiA6PSBTYW1lKHQxLCB0MilcbiAgICBmbXQuUHJpbnRsbihcIlJlcyAyOiAldlwiLCByZXMyKVxufVxuIikpKTt9aWYodHlwZW9mIE1EWENvbnRlbnQhPT0ndW5kZWZpbmVkJyYmTURYQ29udGVudCYmTURYQ29udGVudD09PU9iamVjdChNRFhDb250ZW50KSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShNRFhDb250ZW50KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KE1EWENvbnRlbnQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6Ik1EWENvbnRlbnQiLGZpbGVuYW1lOiJtYW51YWwvR28vR28tVG91ci1DaGFubmVscy5tZCJ9fSk7fU1EWENvbnRlbnQuaXNNRFhDb21wb25lbnQ9dHJ1ZTs="},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Go/Go-Tour-Channels.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"go-tour-channels\"\n    }}>{`Go Tour Channels`}</h1>\n    <p>{`Channels are a typed conduit through which you can send and receive values with the channel operator, <-.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch <- v    // Send v to channel ch.\nv := <-ch  // Receive from ch, and\n           // assign value to v.\n`}</code></pre>\n    <p>{`(The data flows in the direction of the arrow.)`}</p>\n    <p>{`Like maps and slices, channels must be created before use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int)\n`}</code></pre>\n    <p>{`By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.`}</p>\n    <p>{`The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.`}</p>\n    <h2 {...{\n      \"id\": \"basic-example\"\n    }}>{`Basic Example`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n    fmt.Println(\"%v\", s)\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum // send sum to c\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c // receive from c\n\n    fmt.Println(x, y, x+y)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`%v [-9 4 0]\n%v [7 2 8]\n-5 17 12\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"buffered-channels\"\n    }}>{`Buffered Channels`}</h2>\n    <p>{`Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int, 100)\n`}</code></pre>\n    <p>{`Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.`}</p>\n    <p>{`If you overflow the buffer, you'll be hit with a `}<inlineCode parentName=\"p\">{`deadlock`}</inlineCode>{` error.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan int, 2)\n    ch <- 1\n    ch <- 2\n    fmt.Println(<-ch)\n    fmt.Println(<-ch)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"range-and-close\"\n    }}>{`Range and Close`}</h2>\n    <p>{`A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`v, ok := <-ch\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`ok`}</inlineCode>{` is false if there are no more values to receive and the channel is closed.`}</p>\n    <p>{`The loop for `}<inlineCode parentName=\"p\">{`i := range c`}</inlineCode>{` receives values from the channel repeatedly until it is closed.`}</p>\n    <p>{`Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.`}</p>\n    <p>{`Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n    x, y := 0, 1\n    for i := 0; i < n; i++ {\n        c <- x\n        x, y = y, x+y\n    }\n    close(c)\n}\n\nfunc main() {\n    c := make(chan int, 10)\n    go fibonacci(cap(c), c)\n    for i := range c {\n        fmt.Println(i)\n    }\n}\n`}</code></pre>\n    <p>{`This prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"select\"\n    }}>{`Select`}</h2>\n    <p>{`The select statement lets a goroutine wait on multiple communication operations.`}</p>\n    <p>{`A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n        case c <- x:\n            x, y = y, x+y\n        case <-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}\n`}</code></pre>\n    <p>{`After looping through in the IIFE `}<inlineCode parentName=\"p\">{`go func`}</inlineCode>{`, it will send a 0 to the `}<inlineCode parentName=\"p\">{`quit`}</inlineCode>{` channel and `}<inlineCode parentName=\"p\">{`select`}</inlineCode>{` will handle by printing \"quit\" and returning from the infinite `}<inlineCode parentName=\"p\">{`for`}</inlineCode>{` loop.`}</p>\n    <h2 {...{\n      \"id\": \"default-selection\"\n    }}>{`Default Selection`}</h2>\n    <p>{`The default case in a select is run if no other case is ready.`}</p>\n    <p>{`Use a default case to try a send or receive without blocking:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`select {\ncase i := <-c:\n    // use i\ndefault:\n    // receiving from c would block\n}\n`}</code></pre>\n    <p>{`Example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    tick := time.Tick(100 * time.Millisecond)\n    boom := time.After(500 * time.Millisecond)\n    for {\n        select {\n        case <-tick:\n            fmt.Println(\"tick.\")\n        case <-boom:\n            fmt.Println(\"BOOM!\")\n            return\n        default:\n            fmt.Println(\"    .\")\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"example-equivalent-binary-trees\"\n    }}>{`Example: Equivalent Binary Trees`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n  \"golang.org/x/tour/tree\"\n  \"fmt\"\n)\n\n// Walk walks the tree t sending all values\n// from the tree to the channel ch.\nfunc Walk(t *tree.Tree, ch chan int) {\n    defer close(ch) // <- closes the channel when this function returns\n  var walk func(t *tree.Tree)\n  walk = func(t *tree.Tree) {\n      if t == nil {\n          return\n      }\n      walk(t.Left)\n      ch <- t.Value\n      walk(t.Right)\n  }\n  walk(t)\n}\n\n// Same determines whether the trees\n// t1 and t2 contain the same values.\nfunc Same(t1, t2 *tree.Tree) bool {\n    done := make (chan bool)\n    defer close(done)\n\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go Walk(t1, ch1)\n    go Walk(t2, ch2)\n\n    go func() {\n        for i := range ch1 {\n            j := <-ch2\n            fmt.Println(\"i: %v\", i)\n            fmt.Println(\"j: %v\", j)\n\n            if i != j {\n                done <- false\n            }\n        }\n        done <- true\n    }()\n    return <-done\n}\n\nfunc main() {\n    ch := make(chan int)\n    go Walk(tree.New(1), ch)\n\n    for i := 1; i <= 10; i++ {\n        fmt.Println(<-ch)\n    }\n\n    t1 := tree.New(1)\n    t2 := tree.New(2)\n\n    res1 := Same(t1, t1)\n    fmt.Println(\"Res 1: %v\", res1)\n\n    res2 := Same(t1, t2)\n    fmt.Println(\"Res 2: %v\", res2)\n}\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}