{"remainingRequest":"/Users/okeeffe_d/Business/Documentation/node_modules/babel-loader/lib/index.js?{\"presets\":[[\"/Users/okeeffe_d/Business/Documentation/node_modules/babel-preset-docz/dist/index.js\",{\"flow\":true,\"typescript\":false,\"parseProps\":true}]],\"plugins\":[[\"/Users/okeeffe_d/Business/Documentation/node_modules/docz-utils/lib/named-asset-import.js\",{\"loaderMap\":{\"svg\":{\"ReactComponent\":\"@svgr/webpack?-prettier,-svgo![path]\"}}}],\"/Users/okeeffe_d/Business/Documentation/node_modules/react-hot-loader/babel.js\"],\"babelrc\":false,\"cacheCompression\":false,\"compact\":false}!/Users/okeeffe_d/Business/Documentation/manual/iOS/iOS-Gaming-Intro.md","dependencies":[{"path":"/Users/okeeffe_d/Business/Documentation/manual/iOS/iOS-Gaming-Intro.md","mtime":1548209344498},{"path":"/Users/okeeffe_d/Business/Documentation/node_modules/cache-loader/dist/cjs.js","mtime":1548134640245},{"path":"/Users/okeeffe_d/Business/Documentation/node_modules/babel-loader/lib/index.js","mtime":1548134640227}],"contextDependencies":[],"result":["var _jsxFileName = \"/Users/okeeffe_d/Business/Documentation/manual/iOS/iOS-Gaming-Intro.md\";\n\n(function () {\n  var enterModule = require('react-hot-loader').enterModule;\n\n  enterModule && enterModule(module);\n})();\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport React from 'react';\nimport { MDXTag } from '@mdx-js/tag';\n\nvar MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    _classCallCheck(this, MDXContent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  _createClass(MDXContent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n      return React.createElement(MDXTag, {\n        name: \"wrapper\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 14\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"h1\",\n        components: components,\n        props: {\n          \"id\": \"ios-gaming-intro\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 17\n        },\n        __self: this\n      }, \"iOS Gaming Intro\"), React.createElement(MDXTag, {\n        name: \"h2\",\n        components: components,\n        props: {\n          \"id\": \"iosgame-1-ziggity-gag-using-spritekit\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 18\n        },\n        __self: this\n      }, \"IOSGAME-1: Ziggity Gag using SpriteKit\"), React.createElement(MDXTag, {\n        name: \"h3\",\n        components: components,\n        props: {\n          \"id\": \"-----iosgame-11-creating-the-scene\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 19\n        },\n        __self: this\n      }, \"---- IOSGAME-1.1: Creating the Scene\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 20\n        },\n        __self: this\n      }, \"As a new Xcode Project, let's select Game, name, next and create!\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 21\n        },\n        __self: this\n      }, \"When beginning, you will find a \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 21\n        },\n        __self: this\n      }, \"GameViewController.swift\"), \" file. Starting from scratch, remove everything such that it looks like the following:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 22\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-swift\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 22\n        },\n        __self: this\n      }, \"import UIKit\\nimport SpriteKit\\nimport GameplayKit\\n\\nclass GameViewController: UIViewController {\\n\\n\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 31\n        },\n        __self: this\n      }, \"Then, we begin by creating the scene:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 32\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-swift\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 32\n        },\n        __self: this\n      }, \"import UIKit\\nimport QuartzCore\\nimport SceneKit\\n\\nclass GameViewController: UIViewController {\\n\\n  let scene = SCNScene()\\n  // where the camera is kept essentially\\n  let cameraNode = SCNNode()\\n\\n  let firstBox = SCNNode()\\n\\n  override func viewDidLoad() {\\n    self.createScene()\\n  }\\n\\n  func createScene() {\\n    // adding objects onto this view that's on the storyboard\\n    let sceneView = self.view as! SCNView\\n\\n    sceneView.scene = scene\\n\\n    // Create Camera\\n    cameraNode.camera = SCNCamera()\\n    cameraNode.camera?.usesOrthographicProjection = true\\n    cameraNode.camera?.orthographicScale = 3\\n    cameraNode.position = SCNVector3Make(20, 20, 20)\\n    cameraNode.eulerAngles = SCNVector3Make(-45, 45, 0)\\n    let constraint = SCNLookAtConstraint(target: firstBox)\\n    constraint.isGimbalLockEnabled = true\\n    self.cameraNode.constraints = [constraint]\\n    scene.rootNode.addChildNode(cameraNode)\\n\\n    // Create Box\\n    // This will be the first box that is created\\n    // and every box create later will be due to this box\\n    // chamferRadius is for the edge pointiness\\n    let firstBoxGeo = SCNBox(width: 1, height: 1.5, length: 1, chamferRadius: 0)\\n    firstBox.geometry = firstBoxGeo\\n    firstBox.position = SCNVector3Make(0, 0, 0)\\n    scene.rootNode.addChildNode(firstBox)\\n\\n    // createLight\\n    // this will be used so that we can see our box\\n\\n    let light = SCNNode()\\n    light.light = SCNLight()\\n    light.light?.type = SCNLight.LightType.directional\\n    light.eulerAngles = SCNVector3Make(-45, 45, 0)\\n    scene.rootNode.addChildNode(light)\\n  }\\n\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 86\n        },\n        __self: this\n      }, \"To explore how the camera works, feel free to head to \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 86\n        },\n        __self: this\n      }, \"art.scnassets > ship.scn\"), \" and throw in a camera to see how it works.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 87\n        },\n        __self: this\n      }, \"From this, you can head to position after adding a camera and chang the \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 87\n        },\n        __self: this\n      }, \"Position\"), \" and \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 87\n        },\n        __self: this\n      }, \"Euler\"), \" to see the changes that this makes. \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 87\n        },\n        __self: this\n      }, \"Euler\"), \" essentially rotates it clockwise around the axis.\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 88\n        },\n        __self: this\n      }, \"After changing this, you can select \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 88\n        },\n        __self: this\n      }, \"camera\"), \" from the bottom just to see how it looks.\"), React.createElement(MDXTag, {\n        name: \"h3\",\n        components: components,\n        props: {\n          \"id\": \"-----iosgame-12-adding-colors-and-a-person\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 89\n        },\n        __self: this\n      }, \"---- IOSGAME-1.2: Adding Colors and a Person\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 90\n        },\n        __self: this\n      }, \"Create a global node: \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 90\n        },\n        __self: this\n      }, \"var person = SCNNode()\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 91\n        },\n        __self: this\n      }, \"Then, in \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 91\n        },\n        __self: this\n      }, \"createScene()\"), \" we can add\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 92\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-swift\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 92\n        },\n        __self: this\n      }, \"// Create Person\\n\\nlet personGeo = SCNSphere(radius: 0.2)\\nperson = SCNNode(geometry: personGeo)\\nlet personMat = SCNMaterial()\\npersonMat.diffuse.contents = UIColor.red\\npersonGeo.materials = [personMat]\\nperson.position = SCNVector3Make(0, 1.1, 0)\\nscene.rootNode.addChildNode(person)\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 102\n        },\n        __self: this\n      }, \"For the actions, we can override the \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 102\n        },\n        __self: this\n      }, \"touchesBegan()\"), \" function and apply some logic. Ensure that you create the appropriate global Booleans.\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 103\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-swift\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 103\n        },\n        __self: this\n      }, \"override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\\n    if goingLeft == false {\\n      person.removeAllActions()\\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(-100, 0, 0), duration: 20)))\\n      goingLeft = true\\n    } else {\\n      person.removeAllActions()\\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(0, 0, -100), duration: 20)))\\n      goingLeft = false\\n    }\\n  }\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 115\n        },\n        __self: this\n      }, \"After adjusting the constaint of what we want the camera to look at etc. we can now start using the camera to look our \\\"person\\\". The code up to the end of this section looks as follows:\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 116\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-swift\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 116\n        },\n        __self: this\n      }, \"import UIKit\\nimport QuartzCore\\nimport SceneKit\\n\\nclass GameViewController: UIViewController {\\n\\n  let scene = SCNScene()\\n  // where the camera is kept essentially\\n  let cameraNode = SCNNode()\\n\\n  let firstBox = SCNNode()\\n\\n  var person = SCNNode()\\n\\n  var goingLeft = Bool()\\n\\n  override func viewDidLoad() {\\n    self.createScene()\\n  }\\n\\n  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\\n    if goingLeft == false {\\n      person.removeAllActions()\\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(-100, 0, 0), duration: 20)))\\n      goingLeft = true\\n    } else {\\n      person.removeAllActions()\\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(0, 0, -100), duration: 20)))\\n      goingLeft = false\\n    }\\n  }\\n\\n  func createScene() {\\n\\n    self.view.backgroundColor = UIColor.white\\n\\n    // adding objects onto this view that's on the storyboard\\n    let sceneView = self.view as! SCNView\\n\\n    sceneView.scene = scene\\n\\n    // Create Person\\n\\n    let personGeo = SCNSphere(radius: 0.2)\\n    person = SCNNode(geometry: personGeo)\\n    let personMat = SCNMaterial()\\n    personMat.diffuse.contents = UIColor.red\\n    personGeo.materials = [personMat]\\n    person.position = SCNVector3Make(0, 1.1, 0)\\n    scene.rootNode.addChildNode(person)\\n\\n    // Create Camera\\n    cameraNode.camera = SCNCamera()\\n    cameraNode.camera?.usesOrthographicProjection = true\\n    cameraNode.camera?.orthographicScale = 3\\n    cameraNode.position = SCNVector3Make(20, 20, 20)\\n    cameraNode.eulerAngles = SCNVector3Make(-45, 45, 0)\\n    let constraint = SCNLookAtConstraint(target: person)\\n    constraint.isGimbalLockEnabled = true\\n    self.cameraNode.constraints = [constraint]\\n    scene.rootNode.addChildNode(cameraNode)\\n    person.addChildNode(cameraNode)\\n\\n    // Create Box\\n    // This will be the first box that is created\\n    // and every box create later will be due to this box\\n    // chamferRadius is for the edge pointiness\\n    let firstBoxGeo = SCNBox(width: 1, height: 1.5, length: 1, chamferRadius: 0)\\n    firstBox.geometry = firstBoxGeo\\n    let boxMaterial = SCNMaterial()\\n    boxMaterial.diffuse.contents = UIColor(red: 0.2, green: 0.8, blue: 0.9, alpha: 1.0)\\n    firstBoxGeo.materials = [boxMaterial]\\n    firstBox.position = SCNVector3Make(0, 0, 0)\\n    scene.rootNode.addChildNode(firstBox)\\n\\n    // Create Light\\n    // this will be used so that we can see our box\\n\\n    let light = SCNNode()\\n    light.light = SCNLight()\\n    light.light?.type = SCNLight.LightType.directional\\n    light.eulerAngles = SCNVector3Make(-45, 45, 0)\\n    scene.rootNode.addChildNode(light)\\n\\n    let light2 = SCNNode()\\n    light2.light = SCNLight()\\n    light2.light?.type = SCNLight.LightType.directional\\n    light2.eulerAngles = SCNVector3Make(45, 45, 0)\\n    scene.rootNode.addChildNode(light2)\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"h3\",\n        components: components,\n        props: {\n          \"id\": \"-----iosgame-13-creating-a-path\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 208\n        },\n        __self: this\n      }, \"---- IOSGAME-1.3: Creating a Path\"), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 209\n        },\n        __self: this\n      }, \"Creating the function createBox(), we can use a new SCNNode dynamically generated along with a switch on \", React.createElement(MDXTag, {\n        name: \"inlineCode\",\n        components: components,\n        parentName: \"p\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 209\n        },\n        __self: this\n      }, \"arc4random\"), \" in order to create new boxes.\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 210\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {},\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 210\n        },\n        __self: this\n      }, \"func createBox() {\\n    tempBox = SCNNode(geometry: firstBox.geometry)\\n    let prevBox = scene.rootNode.childNode(withName: \\\"(boxNumber)\\\", recursively: true)\\n\\n    boxNumber += 1\\n    tempBox.name = \\\"(boxNumber)\\\"\\n\\n    let randomNumber = arc4random() % 2\\n\\n    switch randomNumber {\\n      case 0:\\n        tempBox.position = SCNVector3Make((prevBox?.position.x)! - firstBox.scale.x, (prevBox?.position.y)!, (prevBox?.position.z)!)\\n        break\\n      case 1:\\n        tempBox.position = SCNVector3Make((prevBox?.position.x)!, (prevBox?.position.y)!, (prevBox?.position.z)! - firstBox.scale.z)\\n        break\\n      default:\\n        break\\n    }\\n\\n    self.scene.rootNode.addChildNode(tempBox)\\n  }\\n\")), React.createElement(MDXTag, {\n        name: \"p\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 233\n        },\n        __self: this\n      }, \"By the end of this stage, you will end up having a path to follow that has 6 boxes ahead for you to see, but it will not decide whether or not you are on the box.\"), React.createElement(MDXTag, {\n        name: \"pre\",\n        components: components,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 234\n        },\n        __self: this\n      }, React.createElement(MDXTag, {\n        name: \"code\",\n        components: components,\n        parentName: \"pre\",\n        props: {\n          \"className\": \"language-swift\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 234\n        },\n        __self: this\n      }, \"import UIKit\\nimport QuartzCore\\nimport SceneKit\\n\\nclass GameViewController: UIViewController, SCNSceneRendererDelegate {\\n\\n  let scene = SCNScene()\\n  // where the camera is kept essentially\\n  let cameraNode = SCNNode()\\n\\n  let firstBox = SCNNode()\\n\\n  var person = SCNNode()\\n\\n  var goingLeft = Bool()\\n\\n  var tempBox = SCNNode()\\n\\n  var prevBoxNumber = Int()\\n  var boxNumber = Int()\\n\\n  override func viewDidLoad() {\\n    self.createScene()\\n  }\\n\\n  // used to ensure ball is on the path\\n  func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) {\\n    let deleteBox = self.scene.rootNode.childNode(withName: \\\"(prevBoxNumber)\\\", recursively: true)\\n\\n    if (deleteBox?.position.x)! > person.position.x + 1 || (deleteBox?.position.z)! > person.position.z + 1 {\\n      prevBoxNumber+=1\\n\\n      deleteBox?.removeFromParentNode()\\n\\n      createBox()\\n    }\\n  }\\n\\n  func createBox() {\\n    tempBox = SCNNode(geometry: firstBox.geometry)\\n    let prevBox = scene.rootNode.childNode(withName: \\\"(boxNumber)\\\", recursively: true)\\n\\n    boxNumber += 1\\n    tempBox.name = \\\"(boxNumber)\\\"\\n\\n    let randomNumber = arc4random() % 2\\n\\n    switch randomNumber {\\n      case 0:\\n        tempBox.position = SCNVector3Make((prevBox?.position.x)! - firstBox.scale.x, (prevBox?.position.y)!, (prevBox?.position.z)!)\\n        break\\n      case 1:\\n        tempBox.position = SCNVector3Make((prevBox?.position.x)!, (prevBox?.position.y)!, (prevBox?.position.z)! - firstBox.scale.z)\\n        break\\n      default:\\n        break\\n    }\\n\\n    self.scene.rootNode.addChildNode(tempBox)\\n  }\\n\\n  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\\n    if goingLeft == false {\\n      person.removeAllActions()\\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(-100, 0, 0), duration: 20)))\\n      goingLeft = true\\n    } else {\\n      person.removeAllActions()\\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(0, 0, -100), duration: 20)))\\n      goingLeft = false\\n    }\\n  }\\n\\n  func createScene() {\\n\\n    prevBoxNumber = 0\\n    boxNumber = 0\\n\\n    self.view.backgroundColor = UIColor.white\\n\\n    // adding objects onto this view that's on the storyboard\\n    let sceneView = self.view as! SCNView\\n    sceneView.delegate = self\\n    sceneView.scene = scene\\n\\n    // Create Person\\n    let personGeo = SCNSphere(radius: 0.2)\\n    person = SCNNode(geometry: personGeo)\\n    let personMat = SCNMaterial()\\n    personMat.diffuse.contents = UIColor.red\\n    personGeo.materials = [personMat]\\n    person.position = SCNVector3Make(0, 1.1, 0)\\n    scene.rootNode.addChildNode(person)\\n\\n    // Create Camera\\n    cameraNode.camera = SCNCamera()\\n    cameraNode.camera?.usesOrthographicProjection = true\\n    cameraNode.camera?.orthographicScale = 3\\n    cameraNode.position = SCNVector3Make(20, 20, 20)\\n    cameraNode.eulerAngles = SCNVector3Make(-45, 45, 0)\\n    let constraint = SCNLookAtConstraint(target: person)\\n    constraint.isGimbalLockEnabled = true\\n    self.cameraNode.constraints = [constraint]\\n    scene.rootNode.addChildNode(cameraNode)\\n    person.addChildNode(cameraNode)\\n\\n    // Create Box\\n    // This will be the first box that is created\\n    // and every box create later will be due to this box\\n    // chamferRadius is for the edge pointiness\\n    let firstBoxGeo = SCNBox(width: 1, height: 1.5, length: 1, chamferRadius: 0)\\n    firstBox.geometry = firstBoxGeo\\n    let boxMaterial = SCNMaterial()\\n    boxMaterial.diffuse.contents = UIColor(red: 0.2, green: 0.8, blue: 0.9, alpha: 1.0)\\n    firstBoxGeo.materials = [boxMaterial]\\n    firstBox.position = SCNVector3Make(0, 0, 0)\\n    scene.rootNode.addChildNode(firstBox)\\n    firstBox.name = \\\"(boxNumber)\\\"\\n\\n    for i in 0...6 {\\n      createBox()\\n    }\\n\\n    // Create Light\\n    // this will be used so that we can see our box\\n\\n    let light = SCNNode()\\n    light.light = SCNLight()\\n    light.light?.type = SCNLight.LightType.directional\\n    light.eulerAngles = SCNVector3Make(-45, 45, 0)\\n    scene.rootNode.addChildNode(light)\\n\\n    let light2 = SCNNode()\\n    light2.light = SCNLight()\\n    light2.light?.type = SCNLight.LightType.directional\\n    light2.eulerAngles = SCNVector3Make(45, 45, 0)\\n    scene.rootNode.addChildNode(light2)\\n  }\\n}\\n\")), React.createElement(MDXTag, {\n        name: \"h3\",\n        components: components,\n        props: {\n          \"id\": \"-----iosgame-14-keeping-a-person-on-the-path\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 374\n        },\n        __self: this\n      }, \"---- IOSGAME-1.4: Keeping a person on the path\"));\n    }\n  }, {\n    key: \"__reactstandin__regenerateByEval\",\n    // @ts-ignore\n    value: function __reactstandin__regenerateByEval(key, code) {\n      // @ts-ignore\n      this[key] = eval(code);\n    }\n  }]);\n\n  return MDXContent;\n}(React.Component);\n\nexport { MDXContent as default };\n;\n\n(function () {\n  var reactHotLoader = require('react-hot-loader').default;\n\n  var leaveModule = require('react-hot-loader').leaveModule;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(MDXContent, \"MDXContent\", \"/Users/okeeffe_d/Business/Documentation/manual/iOS/iOS-Gaming-Intro.md\");\n  leaveModule(module);\n})();\n\n;\nMDXContent.__docgenInfo = {\n  \"description\": \"\",\n  \"methods\": [],\n  \"displayName\": \"MDXContent\"\n};",{"version":3,"sources":["/Users/okeeffe_d/Business/Documentation/manual/iOS/iOS-Gaming-Intro.md"],"names":["React","MDXTag","MDXContent","props","layout","components","Component"],"mappings":"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","sourcesContent":["\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  \n\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"h1\" components={components} props={{\"id\":\"ios-gaming-intro\"}}>{`iOS Gaming Intro`}</MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"iosgame-1-ziggity-gag-using-spritekit\"}}>{`IOSGAME-1: Ziggity Gag using SpriteKit`}</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"-----iosgame-11-creating-the-scene\"}}>{`---- IOSGAME-1.1: Creating the Scene`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`As a new Xcode Project, let's select Game, name, next and create!`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`When beginning, you will find a `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`GameViewController.swift`}</MDXTag>{` file. Starting from scratch, remove everything such that it looks like the following:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-swift\"}}>{`import UIKit\nimport SpriteKit\nimport GameplayKit\n\nclass GameViewController: UIViewController {\n\n\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`Then, we begin by creating the scene:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-swift\"}}>{`import UIKit\nimport QuartzCore\nimport SceneKit\n\nclass GameViewController: UIViewController {\n\n  let scene = SCNScene()\n  // where the camera is kept essentially\n  let cameraNode = SCNNode()\n\n  let firstBox = SCNNode()\n\n  override func viewDidLoad() {\n    self.createScene()\n  }\n\n  func createScene() {\n    // adding objects onto this view that's on the storyboard\n    let sceneView = self.view as! SCNView\n\n    sceneView.scene = scene\n\n    // Create Camera\n    cameraNode.camera = SCNCamera()\n    cameraNode.camera?.usesOrthographicProjection = true\n    cameraNode.camera?.orthographicScale = 3\n    cameraNode.position = SCNVector3Make(20, 20, 20)\n    cameraNode.eulerAngles = SCNVector3Make(-45, 45, 0)\n    let constraint = SCNLookAtConstraint(target: firstBox)\n    constraint.isGimbalLockEnabled = true\n    self.cameraNode.constraints = [constraint]\n    scene.rootNode.addChildNode(cameraNode)\n\n    // Create Box\n    // This will be the first box that is created\n    // and every box create later will be due to this box\n    // chamferRadius is for the edge pointiness\n    let firstBoxGeo = SCNBox(width: 1, height: 1.5, length: 1, chamferRadius: 0)\n    firstBox.geometry = firstBoxGeo\n    firstBox.position = SCNVector3Make(0, 0, 0)\n    scene.rootNode.addChildNode(firstBox)\n\n    // createLight\n    // this will be used so that we can see our box\n\n    let light = SCNNode()\n    light.light = SCNLight()\n    light.light?.type = SCNLight.LightType.directional\n    light.eulerAngles = SCNVector3Make(-45, 45, 0)\n    scene.rootNode.addChildNode(light)\n  }\n\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`To explore how the camera works, feel free to head to `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`art.scnassets > ship.scn`}</MDXTag>{` and throw in a camera to see how it works.`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`From this, you can head to position after adding a camera and chang the `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Position`}</MDXTag>{` and `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Euler`}</MDXTag>{` to see the changes that this makes. `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Euler`}</MDXTag>{` essentially rotates it clockwise around the axis.`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`After changing this, you can select `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`camera`}</MDXTag>{` from the bottom just to see how it looks.`}</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"-----iosgame-12-adding-colors-and-a-person\"}}>{`---- IOSGAME-1.2: Adding Colors and a Person`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`Create a global node: `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`var person = SCNNode()`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`Then, in `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`createScene()`}</MDXTag>{` we can add`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-swift\"}}>{`// Create Person\n\nlet personGeo = SCNSphere(radius: 0.2)\nperson = SCNNode(geometry: personGeo)\nlet personMat = SCNMaterial()\npersonMat.diffuse.contents = UIColor.red\npersonGeo.materials = [personMat]\nperson.position = SCNVector3Make(0, 1.1, 0)\nscene.rootNode.addChildNode(person)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`For the actions, we can override the `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`touchesBegan()`}</MDXTag>{` function and apply some logic. Ensure that you create the appropriate global Booleans.`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-swift\"}}>{`override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    if goingLeft == false {\n      person.removeAllActions()\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(-100, 0, 0), duration: 20)))\n      goingLeft = true\n    } else {\n      person.removeAllActions()\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(0, 0, -100), duration: 20)))\n      goingLeft = false\n    }\n  }\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`After adjusting the constaint of what we want the camera to look at etc. we can now start using the camera to look our \"person\". The code up to the end of this section looks as follows:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-swift\"}}>{`import UIKit\nimport QuartzCore\nimport SceneKit\n\nclass GameViewController: UIViewController {\n\n  let scene = SCNScene()\n  // where the camera is kept essentially\n  let cameraNode = SCNNode()\n\n  let firstBox = SCNNode()\n\n  var person = SCNNode()\n\n  var goingLeft = Bool()\n\n  override func viewDidLoad() {\n    self.createScene()\n  }\n\n  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    if goingLeft == false {\n      person.removeAllActions()\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(-100, 0, 0), duration: 20)))\n      goingLeft = true\n    } else {\n      person.removeAllActions()\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(0, 0, -100), duration: 20)))\n      goingLeft = false\n    }\n  }\n\n  func createScene() {\n\n    self.view.backgroundColor = UIColor.white\n\n    // adding objects onto this view that's on the storyboard\n    let sceneView = self.view as! SCNView\n\n    sceneView.scene = scene\n\n    // Create Person\n\n    let personGeo = SCNSphere(radius: 0.2)\n    person = SCNNode(geometry: personGeo)\n    let personMat = SCNMaterial()\n    personMat.diffuse.contents = UIColor.red\n    personGeo.materials = [personMat]\n    person.position = SCNVector3Make(0, 1.1, 0)\n    scene.rootNode.addChildNode(person)\n\n    // Create Camera\n    cameraNode.camera = SCNCamera()\n    cameraNode.camera?.usesOrthographicProjection = true\n    cameraNode.camera?.orthographicScale = 3\n    cameraNode.position = SCNVector3Make(20, 20, 20)\n    cameraNode.eulerAngles = SCNVector3Make(-45, 45, 0)\n    let constraint = SCNLookAtConstraint(target: person)\n    constraint.isGimbalLockEnabled = true\n    self.cameraNode.constraints = [constraint]\n    scene.rootNode.addChildNode(cameraNode)\n    person.addChildNode(cameraNode)\n\n    // Create Box\n    // This will be the first box that is created\n    // and every box create later will be due to this box\n    // chamferRadius is for the edge pointiness\n    let firstBoxGeo = SCNBox(width: 1, height: 1.5, length: 1, chamferRadius: 0)\n    firstBox.geometry = firstBoxGeo\n    let boxMaterial = SCNMaterial()\n    boxMaterial.diffuse.contents = UIColor(red: 0.2, green: 0.8, blue: 0.9, alpha: 1.0)\n    firstBoxGeo.materials = [boxMaterial]\n    firstBox.position = SCNVector3Make(0, 0, 0)\n    scene.rootNode.addChildNode(firstBox)\n\n    // Create Light\n    // this will be used so that we can see our box\n\n    let light = SCNNode()\n    light.light = SCNLight()\n    light.light?.type = SCNLight.LightType.directional\n    light.eulerAngles = SCNVector3Make(-45, 45, 0)\n    scene.rootNode.addChildNode(light)\n\n    let light2 = SCNNode()\n    light2.light = SCNLight()\n    light2.light?.type = SCNLight.LightType.directional\n    light2.eulerAngles = SCNVector3Make(45, 45, 0)\n    scene.rootNode.addChildNode(light2)\n  }\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"-----iosgame-13-creating-a-path\"}}>{`---- IOSGAME-1.3: Creating a Path`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`Creating the function createBox(), we can use a new SCNNode dynamically generated along with a switch on `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`arc4random`}</MDXTag>{` in order to create new boxes.`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`func createBox() {\n    tempBox = SCNNode(geometry: firstBox.geometry)\n    let prevBox = scene.rootNode.childNode(withName: \"\\(boxNumber)\", recursively: true)\n\n    boxNumber += 1\n    tempBox.name = \"\\(boxNumber)\"\n\n    let randomNumber = arc4random() % 2\n\n    switch randomNumber {\n      case 0:\n        tempBox.position = SCNVector3Make((prevBox?.position.x)! - firstBox.scale.x, (prevBox?.position.y)!, (prevBox?.position.z)!)\n        break\n      case 1:\n        tempBox.position = SCNVector3Make((prevBox?.position.x)!, (prevBox?.position.y)!, (prevBox?.position.z)! - firstBox.scale.z)\n        break\n      default:\n        break\n    }\n\n    self.scene.rootNode.addChildNode(tempBox)\n  }\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`By the end of this stage, you will end up having a path to follow that has 6 boxes ahead for you to see, but it will not decide whether or not you are on the box.`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-swift\"}}>{`import UIKit\nimport QuartzCore\nimport SceneKit\n\nclass GameViewController: UIViewController, SCNSceneRendererDelegate {\n\n  let scene = SCNScene()\n  // where the camera is kept essentially\n  let cameraNode = SCNNode()\n\n  let firstBox = SCNNode()\n\n  var person = SCNNode()\n\n  var goingLeft = Bool()\n\n  var tempBox = SCNNode()\n\n  var prevBoxNumber = Int()\n  var boxNumber = Int()\n\n  override func viewDidLoad() {\n    self.createScene()\n  }\n\n  // used to ensure ball is on the path\n  func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) {\n    let deleteBox = self.scene.rootNode.childNode(withName: \"\\(prevBoxNumber)\", recursively: true)\n\n    if (deleteBox?.position.x)! > person.position.x + 1 || (deleteBox?.position.z)! > person.position.z + 1 {\n      prevBoxNumber+=1\n\n      deleteBox?.removeFromParentNode()\n\n      createBox()\n    }\n  }\n\n  func createBox() {\n    tempBox = SCNNode(geometry: firstBox.geometry)\n    let prevBox = scene.rootNode.childNode(withName: \"\\(boxNumber)\", recursively: true)\n\n    boxNumber += 1\n    tempBox.name = \"\\(boxNumber)\"\n\n    let randomNumber = arc4random() % 2\n\n    switch randomNumber {\n      case 0:\n        tempBox.position = SCNVector3Make((prevBox?.position.x)! - firstBox.scale.x, (prevBox?.position.y)!, (prevBox?.position.z)!)\n        break\n      case 1:\n        tempBox.position = SCNVector3Make((prevBox?.position.x)!, (prevBox?.position.y)!, (prevBox?.position.z)! - firstBox.scale.z)\n        break\n      default:\n        break\n    }\n\n    self.scene.rootNode.addChildNode(tempBox)\n  }\n\n  override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n    if goingLeft == false {\n      person.removeAllActions()\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(-100, 0, 0), duration: 20)))\n      goingLeft = true\n    } else {\n      person.removeAllActions()\n      person.runAction(SCNAction.repeatForever(SCNAction.move(by: SCNVector3Make(0, 0, -100), duration: 20)))\n      goingLeft = false\n    }\n  }\n\n  func createScene() {\n\n    prevBoxNumber = 0\n    boxNumber = 0\n\n    self.view.backgroundColor = UIColor.white\n\n    // adding objects onto this view that's on the storyboard\n    let sceneView = self.view as! SCNView\n    sceneView.delegate = self\n    sceneView.scene = scene\n\n    // Create Person\n    let personGeo = SCNSphere(radius: 0.2)\n    person = SCNNode(geometry: personGeo)\n    let personMat = SCNMaterial()\n    personMat.diffuse.contents = UIColor.red\n    personGeo.materials = [personMat]\n    person.position = SCNVector3Make(0, 1.1, 0)\n    scene.rootNode.addChildNode(person)\n\n    // Create Camera\n    cameraNode.camera = SCNCamera()\n    cameraNode.camera?.usesOrthographicProjection = true\n    cameraNode.camera?.orthographicScale = 3\n    cameraNode.position = SCNVector3Make(20, 20, 20)\n    cameraNode.eulerAngles = SCNVector3Make(-45, 45, 0)\n    let constraint = SCNLookAtConstraint(target: person)\n    constraint.isGimbalLockEnabled = true\n    self.cameraNode.constraints = [constraint]\n    scene.rootNode.addChildNode(cameraNode)\n    person.addChildNode(cameraNode)\n\n    // Create Box\n    // This will be the first box that is created\n    // and every box create later will be due to this box\n    // chamferRadius is for the edge pointiness\n    let firstBoxGeo = SCNBox(width: 1, height: 1.5, length: 1, chamferRadius: 0)\n    firstBox.geometry = firstBoxGeo\n    let boxMaterial = SCNMaterial()\n    boxMaterial.diffuse.contents = UIColor(red: 0.2, green: 0.8, blue: 0.9, alpha: 1.0)\n    firstBoxGeo.materials = [boxMaterial]\n    firstBox.position = SCNVector3Make(0, 0, 0)\n    scene.rootNode.addChildNode(firstBox)\n    firstBox.name = \"\\(boxNumber)\"\n\n    for i in 0...6 {\n      createBox()\n    }\n\n    // Create Light\n    // this will be used so that we can see our box\n\n    let light = SCNNode()\n    light.light = SCNLight()\n    light.light?.type = SCNLight.LightType.directional\n    light.eulerAngles = SCNVector3Make(-45, 45, 0)\n    scene.rootNode.addChildNode(light)\n\n    let light2 = SCNNode()\n    light2.light = SCNLight()\n    light2.light?.type = SCNLight.LightType.directional\n    light2.eulerAngles = SCNVector3Make(45, 45, 0)\n    scene.rootNode.addChildNode(light2)\n  }\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"-----iosgame-14-keeping-a-person-on-the-path\"}}>{`---- IOSGAME-1.4: Keeping a person on the path`}</MDXTag>\n           </MDXTag>\n  }\n}\n  "]}]}