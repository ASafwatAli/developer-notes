{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-RxJS.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-RxJS.md","mtime":1562563032045},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1564095360956},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1562568123838},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1565139338792},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1564095361765}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiOy8qIEBqc3ggbWR4ICovaW1wb3J0IFJlYWN0IGZyb20ncmVhY3QnO2ltcG9ydHttZHh9ZnJvbSdAbWR4LWpzL3JlYWN0JzsvKiBAanN4IG1keCAqL3ZhciBtYWtlU2hvcnRjb2RlPWZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSl7cmV0dXJuIGZ1bmN0aW9uIE1EWERlZmF1bHRTaG9ydGNvZGUocHJvcHMpe2NvbnNvbGUud2FybigiQ29tcG9uZW50ICIrbmFtZSsiIHdhcyBub3QgaW1wb3J0ZWQsIGV4cG9ydGVkLCBvciBwcm92aWRlZCBieSBNRFhQcm92aWRlciBhcyBnbG9iYWwgc2NvcGUiKTtyZXR1cm4gbWR4KCJkaXYiLHByb3BzKTt9O307dmFyIGxheW91dFByb3BzPXt9O3ZhciBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoX3JlZil7dmFyIGNvbXBvbmVudHM9X3JlZi5jb21wb25lbnRzLHByb3BzPV9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLFsiY29tcG9uZW50cyJdKTtyZXR1cm4gbWR4KE1EWExheW91dCxPYmplY3QuYXNzaWduKHt9LGxheW91dFByb3BzLHByb3BzLHtjb21wb25lbnRzOmNvbXBvbmVudHMsbWR4VHlwZToiTURYTGF5b3V0In0pLG1keCgiaDEiLHsiaWQiOiJyeGpzIn0sIlJ4SlMiKSxtZHgoImgyIix7ImlkIjoiMTAtYS1icmllZi1yZWNhcC1vZi1wcm9ncmFtbWluZy1wYXJhZGlnbXMifSwiMS4wIEEgQnJpZWYgUmVjYXAgb2YgUHJvZ3JhbW1pbmcgUGFyYWRpZ21zIiksbWR4KCJoMyIseyJpZCI6InByb2NlZHVyYWwtcHJvZ3JhbSJ9LCJQcm9jZWR1cmFsIFByb2dyYW0iKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJUaGUgaWRlYXMgdGhhdCBwcm9ncmFtcyBhcmUgYSBzZW5zZSBvZiBmdW5jdGlvbnMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiR29lcyBmcm9tIHRvcCB0byBib3R0b20iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiUmVsaWVzIGhlYXZpbHkgb24gZ2xvYmFsIHN0YXRlLCBidXQgYW55IGxpbmUgY2FuIGNoYW5nZSB0aGUgZ2xvYmFsIHN0YXRlIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkMgYmVpbmcgYSBwcm9jZWR1cmFsIGxhbmd1YWdlIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlwiSW1wZXJhdGl2ZVwiIGV4ZWN1dGlvbiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJFYXN5IHRvIHdyaXRlLCBkaWZmaWN1bHQgdG8gbWFpbnRhaW4iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiUHJvbmUgdG8gZGlmZmljdWx0IGJ1Z3MiKSksbWR4KCJoMyIseyJpZCI6Im9iamVjdC1vcmllbnRlZCJ9LCJPYmplY3QgT3JpZW50ZWQiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJCYXNlZCBhcm91bmQgYSBQcmltaXRpdmU6IG9iamVjdCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJPYmplY3RzIGhhdmUgd2VsbCBkZWZpbmVkIGludGVyZmFjZXMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiTG9jYWxpc2VkIGJlaGF2aW91ciIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJPYmplY3RzIGNvbnRyb2wgc3RhdGUiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ29tcG9zaXRpb24iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ29kZSBpcyBzdGlsbCBpbXBlcmF0aXZlIC0gcHJvIEFORCBjb24hIC0gU3RpbGwgdGVsbGluZyB0aGUgY29tcHV0ZXIgRVhBQ1RMWSB3aGF0IHRvIGRvLiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDYW4gYmUgbW9yZSB2ZXJib3NlIikpLG1keCgiaDMiLHsiaWQiOiJkZWNsYXJhdGl2ZSJ9LCJEZWNsYXJhdGl2ZSIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkRlc2NyaWJpbmcgd2hhdCB5b3Ugd2FudCB0byBoYXBwZW4sIGJ1dCBub3QgdGVsbGluZyB0aGUgY29tcHV0ZXIgaG93IHRvIGRvIGl0IiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkVnLiBTUUwsIFJlZ2V4LCBIVE1MIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkRhdGEgaXMgc2VsZi1kZXNjcmliaW5nIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkFzIHBvd2VyZnVsIGFzIHRoZSBpbnRlcnByZXRlciBhbGxvd3MiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQXMgbGltaXRpbmcgYXMgdGhlIGludGVycHJldGVyIGFsbG93cyAtIFlvdSB3YW50IGJ1aWxkIGEgZ2FtZSBpbiBTUUwgZXRjLiIpKSxtZHgoImgzIix7ImlkIjoiZnVuY3Rpb25hbCJ9LCJGdW5jdGlvbmFsIiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiV2hhdCB3ZSB3YW50IHRvIGhhcHBlbiBidXQgbm90IGhvdyIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJMaXR0bGUgc3RhdGUiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiRmV3IHNpZGUgZWZmZWN0cyIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJFYXN5IHRvIHJlYXNvbiBhYm91dCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDb21wb3NpdGlvbiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJFeHByZXNzaXZlIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIldvcmtzIGdyZWF0IHdpdGggT08iKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQmFzaXMgaW4gaGlnaGVyIG1hdGgiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiQ29ucyB0byB0aGluayBkaWZmZXJlbnRseSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJOb3QgYWx3YXlzIHRoZSBiZXN0IGNob2ljZSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJObyBsb29wcywgbm8gY29udHJvbCBsb2dpYyAtIEp1c3QgdGVsbGluZyBpdCB3aGF0IHdlIHdhbnQgdG8gaGFwcGVuIikpLG1keCgiaDMiLHsiaWQiOiJyZWFjdGl2ZSJ9LCJSZWFjdGl2ZSIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlByaW1pdGl2ZTogT2JzZXJ2YWJsZSIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJJbnN0ZWFkIG9mIGRlc2NyaWJpbmcgZGF0YSBpbiB0ZXJtcyBvZiBvdGhlciBkYXRhLCB3ZSBkZXNjcmliZSBpdCBpbiB0ZXJtcyBvZiBzdHJlYW1zIG9mIGV2ZW50cyAtIEZyb20gdGhpcywgd2UgY3JlYXRlIGEgcGlwZWxpbmUgc3VjaCB0aGF0IHdlIGNlcnRhaW4gZGF0YSBjaGFuZ2VzLCBhIGxvdCBpcyBwcm9jZXNzZWQgYW5kIGNoYW5nZWQgLSBFeGFtcGxlOiBzcHJlYWRzaGVldHMhIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkNvbXBvc2l0aW9uIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkV4cHJlc3NpdmUiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiRGF0YSBmbG93cyB1bmlkaXJlY3Rpb25hbGx5IiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlRvdWdoIHRvIHRoaW5rIGRpZmZlcmVudGx5IiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlN1YnNjcmlwdGlvbnMgaGVscCBjaGFuZ2UgdGhlIGRhdGEiKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksImNvbnN0IGNlbGxDMiQgPSBjZWxsQTIkXG4gIC5jb21iaW5lTGF0ZXN0KGNlbGxCMiQpXG4gIC5tYXAoKGNlbGxzKSA9PiBjZWxsc1swXSArIGNlbGxzWzFdKTtcblxuY2VsbEMyJC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gIGNvbnNvbGUubG9nKHZhbHVlKTtcbn0pO1xuIikpLG1keCgiaDIiLHsiaWQiOiIxMS1jb3JlLXJlYWN0aXZlLWNvbmNlcHRzIn0sIjEuMTogQ29yZSBSZWFjdGl2ZSBDb25jZXB0cyIpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiQ29yZSBDb25jZXB0IDE6IFB1bGwgbW9kZWwgdnMgUHVzaCBtb2RlbCIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJhbnkgZGF0YSBzaXR0aW5nIHRoZXJlIHRoYXQgeW91IFwiYXNrXCIgZm9yIGF0IHNvbWUgcG9pbnQgLSBleGFtcGxlIHJlZnJlc2ggYnV0dG9uIC0gbWFudWFsIGJ1dHRvbiB0cmlnZ2VyIC0gdGltZSBpbnRlcnZhbCIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJvYnNlcnZhYmxlIChzdHJlYW0pIHdoaWNoIGlzIGEgcmVhY3RpdmUgZGF0YSBzb3VyY2UgLSBwcm9kdWNlcyBpdGVtcyBvdmVyIGEgcGVyaW9kIG9mIHRpbWUgdGhhdCB3aWxsIGVpdGhlciBlcnJvciwgY29tcGxldGUsIG9yIG5ldmVyIGNvbXBsZXRlIHVudGlsIGEgcGFnZSBjbG9zZXMgLSBub3QgdGVsbGluZyB0aGUgc3RyZWFtIHdoZW4gdG8gZ2V0IGRhdGEsIGl0IGhhcyBpbmJ1aWx0IGxvZ2ljIG9uIGhvdyB0byBnZXQgZGF0YSAtIHdlIG1heSB0cmFuc2Zvcm0gdGhpcyBkYXRhIC0gdGhlIGRpc3BsYXkgb2YgdGhlIGRhdGEgaXMgYWN0dWFsbHkgcGFydCBvZiB0aGUgZGVzY3JpcHRpb24iKSksbWR4KCJwIixudWxsLCJBbiBhbiBleGFtcGxlIGZvciBhICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJwdWxsIiksIiBiYXNlZCBjb2RlLCB3ZSBjYW4gdGhpbmsgb2YgYSB3aW5kb3cuc2V0SW50ZXJ2YWwoKSB0aGF0IGZpcmVzIGV2ZXJ5IDUwMDAgc2Vjb25kcy4iKSxtZHgoInAiLG51bGwsIkFuIGV4YW1wbGUgb2YgYSBwdXNoIHdvdWxkIGJlIHRvIGhhdmUgYSBmdW5jdGlvbiBmaXJlIGFuZCB0aGVuIHRoZSByZXR1cm4gY29udGludXRlcyB0byBmaWx0ZXIsIGZsYXRNYXAsIG1hcCBhbmQgc3Vic2NyaWJlLiIpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiQ29yZSBDb25jZXB0IDI6IEV2ZXJ5dGhpbmcgaXMgYSBkYXRhYmFzZSIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJtb3VzZSBtb3ZlbWVudHMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiY3VycmVudCB1c2VyIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIndlYiByZXF1ZXN0cyIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJpbnB1dCBib3hlcyIpKSxtZHgoImgyIix7ImlkIjoiMTItY29tcGFyaW5nLXRoZS1hdXRvY29tcGxldGUtZnVuY3Rpb24tdXNpbmctanMtdnMtcnhqcyJ9LCIxLjI6IENvbXBhcmluZyB0aGUgQXV0b2NvbXBsZXRlIGZ1bmN0aW9uIHVzaW5nIEpTIHZzIFJ4SlMiKSxtZHgoInAiLG51bGwsIkluIHRoZSBjb21wYXJpc29uIHdoZXJlIHRoZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiJHRpdGxlLm9uKCdrZXl1cCcsICgpID0+IHt9KSIpLCIgcnVucyB3aXRoIGEgcHJvbWlzZSByZXR1cm5lZC4gVGhlIHF1ZXJ5IGNhbiBydW4gaW50byByYWNlIGNvbmRpdGlvbnMuIiksbWR4KCJwIixudWxsLCJBbHNvIG5vdGUgdGhhdCBldmVyeSBzaW5nbGUgcmVzdWx0IGFsc28gZmlyZXMuIiksbWR4KCJwIixudWxsLCJUaGUgaXNzdWVzOiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIvLyBGaXggdXAgYW5kIGRvd24gYXJyb3dcbi8vIFN0b3AgYWx3YXlzIHF1ZXJ5aW5nXG4vLyBHZXR0aW5nIHJhY2UgY29uZGl0aW9uXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJCYWQgd2F5cyIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJnZW5lcmFsbHkgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJsaSJ9LCJpZiBsYXN0IHF1ZXJ5ID09IGN1cnJlbnRUaXRsZSByZXR1cm4iKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sInVzaW5nIHNldFRpbWVvdXQgdG8gcmVkdWNlIG51bWJlciBvZiBxdWVyaWVzIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlJhY2UgY29uZGl0aW9uIHN0aWxsIGhhcHBlbmluZywgYnV0IGJhZCBhdHRlbXB0cyBtYXkgYmUgaW5jcmVhc2luZyB0aGUgdGltZW91dCAtIENvdWxkIGFsc28gdXNlIGEgY3VycmVudCBpZCBjb21wYXJlZCB0byBuZXh0IHF1ZXJ5IGlkIGFuZCB0aGVuIHJldHVybmluZyBiZWZvcmUgdGhlIGNhbGxiYWNrIG9jY3VycyIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJBIGxvdCBvZiBzdGF0ZSBhY3Jvc3MgdGhlIG1vZHVsZSBiZWluZyBjaGFuZ2VkIikpLG1keCgicCIsbnVsbCxtZHgoInN0cm9uZyIse3BhcmVudE5hbWU6InAifSwiVGhlIFJ4IHdheSIpKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiLy8gbnBtIGluc3RhbGwgcnhqcy1lcyBmb3IgZXM2XG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IFJ4IGZyb20gJ3J4anMvUngnO1xuXG5jb25zdCAkdGl0bGUgPSAkKCcjdGl0bGUnKTtcbmNvbnN0ICRyZXN1bHRzID0gJCgnI3Jlc3VsdHMnKTtcblxuY29uc3Qga2V5VXBzJCA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KCR0aXRsZSwgXCJrZXl1cFwiKTtcbmNvbnN0IHF1ZXJpZXMkID0ga2V5VXBzJFxuICAgIC5tYXAoZSA9PiBlLnRhcmdldC52YWx1ZSlcbiAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgIC5kZWJvdW5jZVRpbWUoMjUwKVxuICAgIC5zd2l0Y2hNYXAoZ2V0SXRlbXMpOyAgIC8vIHNpbWlsYXIgdG8gbWVyZ2UsIGJ1dCBpZiBuZXcgcXVlcnkgY29tZXMgaW4sIGRpc2NhcmQgdGhlIG9sZCBkYXRhXG4gICAgLy8ubWVyZ2VNYXAoZ2V0SXRlbXMpOyAgLy8gYWxpYXMgZm9yIGZsYXRNYXBcblxucXVlcmllcyQuc3Vic2NyaWJlKHF1ZXJ5ID0+IHtcbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBwcm9taXNlIHdpbGwgc3RvcCByYWNlIGNvbmRpdGlvblxuICAgICRyZXN1bHRzLmVtcHR5KCk7XG4gICAgJHJlc3VsdHMuYXBwZW5kKGl0ZW1zLm1hcCggciA9PiAkKGA8bGkgLz5gKS50ZXh0KHIpKSk7XG59KVxuXG48IS0tIHF1ZXJpZXMkLnN1YnNjcmliZShxdWVyeSA9PiB7XG4gICAgY29uc29sZS5sb2coZSk7IC8vIHByaW50cyBvdXQgZXZlbnRcbiAgICBnZXRJdGVtcyhxdWVyeSlcbiAgICAgICAgLnRoZW4oaXRlbXMgPT4ge1xuICAgICAgICAgICAgJHJlc3VsdHMuZW1wdHkoKTtcbiAgICAgICAgICAgICRyZXN1bHRzLmFwcGVuZChpdGVtcy5tYXAoIHIgPT4gJChgPGxpIC8+YCkudGV4dChyKSkpO1xuICAgICAgICB9KTtcbn0pIC0tPlxuIikpLG1keCgicCIsbnVsbCwiQW4gZXZlbiBiZXR0ZXIgd2F5LiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IFJ4IGZyb20gJ3J4anMvUngnO1xuXG5jb25zdCAkdGl0bGUgPSAkKCcjdGl0bGUnKTtcbmNvbnN0ICRyZXN1bHRzID0gJCgnI3Jlc3VsdHMnKTtcblxuUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoJHRpdGxlLCAna2V5dXAnKVxuICAubWFwKChlKSA9PiBlLnRhcmdldC52YWx1ZSlcbiAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgLmRlYm91bmNlVGltZSg1MDApXG4gIC5zd2l0Y2hNYXAoZ2V0SXRlbXMpXG4gIC5zdWJzY3JpYmUoKGl0ZW1zKSA9PiB7XG4gICAgJHJlc3VsdHMuZW1wdHkoKTtcbiAgICAkcmVzdWx0cy5hcHBlbmQoaXRlbXMubWFwKChyKSA9PiAkKGA8bGkgLz5gKS50ZXh0KHIpKSk7XG4gIH0pO1xuIikpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIkFsbCB0aGUgUnggaGFzIG5vIGV4dGVybmFsIHN0YXRlLCB3aGVyZWFzIHRoZSBvdGhlciBjb2RlIGRvZXMuIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlJ4IGRvZXNuJ3QgaGF2ZSB0byB3YWl0IGZvciB1cyB0byB0ZWxsIGl0IHdoZW4gdG8gZG8gaXQuIikpLG1keCgiaHIiLG51bGwpLG1keCgiaDIiLHsiaWQiOiIzLXRoZS1jb3JlLW9mLXJlYWN0aXZlLWV4dGVuc2lvbnMifSwiMzogVGhlIENvcmUgb2YgUmVhY3RpdmUgRXh0ZW5zaW9ucyIpLG1keCgiaDIiLHsiaWQiOiIzMS1vYmVydmFibGVzLW9wZXJhdG9ycy1hbmQtc3Vic2NyaXB0aW9ucyJ9LCIzLjE6IE9iZXJ2YWJsZXMsIE9wZXJhdG9ycyBhbmQgU3Vic2NyaXB0aW9ucyIpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIk9ic2VydmFibGU6IFNvbWV0aGluZyB0aGF0IGNhbiBiZSBvYnNlcnZlZCB3aGljaCBwcm9kdWNlcyB2YWx1ZXMiKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiT3BlcmF0b3I6IEl0J3MgYW4gb3BlcmF0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIGRhdGEgYmVpbmcgcHVzaGVkIGluIGZyb20gdGhlIG9ic2VydmFibGUgLSBUaGV5IGRvbid0IHByb2R1Y2UgdmFsdWVzIGluIGFuZCBvZiB0aGVtc2VsdmVzLCBidXQgbW92ZSB0aGVtIHRocm91Z2ggdGhlIHBpcGVsaW5lLiIpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJTdWJzY3JpcHRpb25zOiBQaWVjZSBvZiBjb2RlIHRoYXQgd2lsbCBkbyBzb21ldGhpbmcgd2l0aCB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBvcGVyYXRvcnMiKSksbWR4KCJwIixudWxsLCJOb3RlLCB5b3UgY2FuIG1vZGVsIGFueXRoaW5nIGluIGEgcmVhY3RpdmUgY29udGV4dCBieSB0aGlua2luZyBhIGxpdHRsZSBiaXQgZGlmZmVyZW50bHkuIiksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJXZWIgQVBJIFJlcXVlc3QgRXhhbXBsZSIpKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJSZWFjdGl2ZSBjYW4gc3RpbGwgY29tcGxldGUsIG9yIGl0IGNhbiBlcnJvciBvdXQgYW5kIHJldHJ5LiIpKSxtZHgoImgyIix7ImlkIjoiMzItY3JlYXRpbmctb2JzZXJ2YWJsZXMifSwiMy4yIENyZWF0aW5nIE9ic2VydmFibGVzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksImltcG9ydCBSeCBmcm9tICdyeGpzL1J4JztcblxuIyBwcm9taXNlIHdpbGwgYWx3YXlzIGV4ZWN1dGUgLSBub3QgbGF6eVxuY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIkluIHByb21pc2VcIik7XG4gICAgcmVzb2x2ZShcImhleVwiKTtcbn0pO1xuXG5wcm9taXNlLnRoZW4oaXRlbSA9PiBjb25zb2xlLmxvZyhpdGVtKSk7XG5cbiMgdGhpcyBkb2Vzbid0IGdpdmUgYW55IG91dHB1dCFcbiMgb2JzZXJ2YWJsZXMgYXJlIGxhenkhXG4jIHdvbid0IHJ1biB3aXRob3V0IGEgc3Vic2NyaXB0aW9uXG5jb25zdCBzaW1wbGUkID0gbmV3IFJ4Lk9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiR2VuZXJhdGluZyBvYnNlcnZhYmxlXCIpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci5uZXh0KFwiQW4gaXRlbXMhXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoXCJBbm90aGVyIGl0ZW0hXCIpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfSwgMTAwMCk7XG59KTtcblxuIyBjcmVhdGluZyBhIHN1YnNjcmlwdGlvblxuIyBmaXJzdCBhcmcgaXMgdGhlIG5leHQgZnVuY3Rpb25cbiMgc2Vjb25kIGFyZyBpcyBlcnJvclxuIyB0aGlyZCBhcmcgaXMgY29tcGxldGVcbnNpbXBsZSQuc3Vic2NyaWJlKFxuICAgIGl0ZW0gPT4gY29uc29sZS5sb2coYG9uZS5uZXh0ICR7aXRlbX1gKSxcbiAgICBlcnJvciA9PiBjb25zb2xlLmxvZyhgb25lLmVycm9yICR7aXRlbX1gKSxcbiAgICAoKSA9PiBjb25zb2xlLmxvZyhcIm9uZS5jb21wbGV0ZVwiKVxuKTtcblxuIyBHZW5lcmF0aW5nIG9ic2VydmFibGVcbiMgb25lLm5leHQgQW4gaXRlbSFcbiMgb25lLm5leHQgQW5vdGhlciBpdGVtIVxuIyBvbmUuY29tcGxldGVcblxuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgc2ltcGxlJC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBpdGVtID0+IGNvbnNvbGUubG9nKGB0d28ubmV4dCAke2l0ZW19YCksXG4gICAgICAgIGVycm9yOiBlcnJvciA9PiBjb25zb2xlLmxvZyhgdHdvLmVycm9yICR7aXRlbX1gKSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKFwidHdvLmNvbXBsZXRlXCIpXG4gICAgfSk7XG59LCAzMDAwKVxuIikpLG1keCgidWwiLG51bGwsbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sIlJlLXN1YnNjcmliaW5nIHRvIGFuIG9ic2VydmFibGUgYWxsb3dzIHlvdSB0byBydW4gdGhhdCBnZW5lcmF0b3IgYWdhaW4iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7fSksImZ1bmN0aW9uIGNyZWF0ZUludGVydmFsKHRpbWUpIHtcbiAgICByZXR1cm4gbmV3IFJ4Lk9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGluZGV4KyspO1xuICAgICAgICB9LCB0aW1lKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2lsbCBydW4gd2hlbiB3ZSB1bnN1YnNjcmliZVxuICAgICAgICAgICAgY2xlYXJuSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmVyKHRhZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoaXRlbSkgeyBjb25zb2xlLmxvZyhgJHt0YWd9Lm5leHQgJHtpdGVtfWApOyB9LFxuICAgICAgICBlcnJvcihlcnJvcikgeyBjb25zb2xlLmxvZyhgJHt0YWd9LmVycm9yICR7ZXJyb3Iuc3RhY2sgfHwgZXJyb3IgfWApOyB9LFxuICAgICAgICBjb21wbGV0ZSgpIHsgY29uc29sZS5sb2coYCR7dGFnfS5jb21wbGV0ZWApOyB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdGFrZShvYnNlcnZhYmxlLCBhbW91bnQpIHtcbiAgICByZXR1cm4gbmV3IFJ4Lk9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuXG4gICAgfSk7XG59XG5cbi8vIHRoaXMgaXMgdGhlIGNvcmUgb2Ygc3Vic2NyaXB0aW9uc1xuZnVuY3Rpb24gdGFrZShzb3VyY2VPYnNlcnZhYmxlLCBhbW91bnQpIHtcbiAgICByZXR1cm4gbmV3IFJ4Lk9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2VPYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0KGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID49IGFtb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcihlcnJvcikgeyBvYnNlcnZlci5lcnJvcihlcnJvcik7IH0sXG4gICAgICAgICAgICBjb21wbGV0ZSgpIHsgb2JzZXJ2ZXIuY29tcGxldGUoKTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGV2ZXJ5U2Vjb25kXyA9IGNyZWF0ZUludGVydmFsKDEwMDApO1xuY29uc3QgZmlyc3RGaXZlU2Vjb25kcyA9IHRha2UoZXZlcnlTZWNvbmRfLCA1KTtcbmNvbnN0IHN1YnNjcmlwdGlvbiA9IGV2ZXJ5U2Vjb25kXy5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9uZVwiKSk7XG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbn0sIDM1MDApO1xuIikpLG1keCgicCIsbnVsbCwiVGhpcyBzdWJzY3JpcHRpb24gd2lsbCBjb25zb2xlLmxvZyBvdXQgZm9yZXZlciBhbmQgZXZlciBhbmQgZXZlci4uLiAtIHVubGVzcywgd2UgZGlzcG9zZSBvZiBhIGRlc2NyaXB0aW9uIiksbWR4KCJwIixudWxsLCJIb3cgZG8gb3BlcmF0b3JzIGNvbWUgaW50byBwbGF5PyIpLG1keCgicCIsbnVsbCwiV2UgY291bGQgcnVuIHNvbWV0aGluZyBsaWtlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJjb25zdCBzdWJzY3JpcHRpb24gPSBldmVyeVNlY29uZF8udGFrZSgzKXN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwib25lXCIpKTsiKSksbWR4KCJwIixudWxsLCJUaGUgc3RlcHMgZm9yIGl0IGFyZSB0aGF0IGl0IGxpc3RlbnMgZm9yIGEgc291cmNlIGFuZCBlbWl0cyBhIHRyYW5zZm9ybWF0aW9uISIpLG1keCgiaDIiLHsiaWQiOiIzMy1idWlsdC1pbi1vYnNlcnZhYmxlcyJ9LCIzLjM6IEJ1aWx0IGluIE9ic2VydmFibGVzIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksImltcG9ydCBSeCBmcm9tICdyeGpzL1J4JztcblxuXG5SeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMClcbiAgICAudGFrZSg1KVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcImludGVydmFsXCIpKTtcblxuUnguT2JzZXJ2YWJsZS50aW1lcigxMDAwLCA1MDApXG4gICAgLnRha2UoMylcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJ0aW1lclwiKTtcblxuLy8gbm90ZSwgYXJyYXkgZG9lc24ndCB3b3JrIC0gdXNlIGZyb21cblJ4Lk9ic2VydmFibGUub2YoXCJIZWxsbyB3b3JsZCFcIiwgNDIsIFwid2hvYVwiKVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9mXCIpKTtcblxuUnguT2JzZXJ2YWJsZS5mcm9tKFtcIkhlbGxvIHdvcmxkIVwiLCA0MiwgXCJ3aG9hXCJdKVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9mXCIpKTtcblxuUnguT2JzZXJ2YWJsZS5mcm9tKGdlbmVyYXRlKCkpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwib2ZcIikpO1xuXG5cblJ4Lk9ic2VydmFibGUuZnJvbShcImhlbGxvIHdvcmxkIVwiKVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIm9mXCIpKTtcblxuLy8gaXQgY2FuIGFsc28gdGFrZSBpbiBhIGdlbmVyYXRvciBmdW5jdGlvbiFcblxuZnVuY3Rpb24qIGdlbmVyYXRlKCkge1xuICAgIHlpZWxkIDE7XG4gICAgeWllbGQgNTtcbiAgICB5aWVsZCBcIkhFWVwiO1xufVxuXG5SeC5PYnNlcnZhYmxlLnRocm93KG5ldyBFcnJvcihcIkhleVwiKSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJlcnJvclwiKSk7XG5cbi8vIGVtcHR5XG5SeC5PYnNlcnZhYmxlLmVtcHR5KClcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJlbXB0eVwiKSk7XG5cbi8vIGRlZmVyXG5sZXQgc2lkZUVmZmVjdCA9IDA7XG5jb25zdCBkZWZlciA9IFJ4Lk9ic2VydmFibGUuZGVmZXIoKCkgPT4ge1xuICAgIHNpZGVFZmZlY3QrKztcbiAgICByZXR1cm4gUnguT2JzZXJhYmxlLm9mKHNpZGVFZmZlY3QpO1xufSk7XG5cbmRlZmVyLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiZGVmZXIub25lXCIpKTtcbmRlZmVyLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiZGVmZXIudHdvXCIpKTtcbmRlZmVyLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiZGVmZXIudGhyZWVcIikpO1xuXG5SeC5PYnNlcnZhYmxlLm5ldmVyKClcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJuZXZlclwiKSk7XG5cblJ4Lk9ic2VydmFibGUucmFuZ2UoMTAsIDMwKVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcInJhbmdlXCIpKTtcbiIpKSxtZHgoInAiLG51bGwsIkJlbmVmaXRzIG9mIHRoZSBpdGVyYWJsZSAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiZnJvbSIpLCI/IiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiRm9yIGV2ZXJ5IGl0ZXJhYmxlLCB3ZSBjb3VsZCBtYXAgZXZlcnkgZWxlbWVudC4iKSksbWR4KCJoMiIseyJpZCI6IjM0LXVzaW5nLXJ4anMtd2l0aC1ub2RlLWpxdWVyeS1hbmQtcHJvbWlzZXMifSwiMy40OiBVc2luZyBSeEpTIHdpdGggTm9kZSwgalF1ZXJ5IGFuZCBQcm9taXNlcyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJSeC5PYnNlcnZhYmxlLmZyb21FdmVudCgkdGl0bGUsICdrZXl1cCcpXG4gIC5tYXAoKGUpID0+IGUudGFyZ2V0LnZhbHVlKVxuICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAuZGVib3VuY2VUaW1lKDUwMClcbiAgLnN3aXRjaE1hcChnZXRJdGVtcylcbiAgLnN1YnNjcmliZSgoaXRlbXMpID0+IHtcbiAgICAkcmVzdWx0cy5lbXB0eSgpO1xuICAgICRyZXN1bHRzLmFwcGVuZChpdGVtcy5tYXAoKGkpID0+ICQoJzxsaSAvPicpLnRleHQoaSkpKTtcbiAgfSk7XG4iKSksbWR4KCJwIixudWxsLCJOT1RFOiBXaXRob3V0IHRoZSBzdWJzY3JpYmUsIGl0IHdpbGwgbmV2ZXIgYmUgc3Vic2NyaWJlZCB0byB0aGUgZG9tISIpLG1keCgicCIsbnVsbCwiSWYgd2UgaGF2ZSB0aGUgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sIi50YWtlKDEwKSIpLCIgLSBpdCB3b3VsZCBjb21wbGV0ZSBhZnRlciB0YWtpbmcgMTAgYW5kIHRoZW4gZnVydGhlcm1vcmUgdW5zdWJzY3JpYmUgYW5kIGJlIGdyZWF0IGZvciBwZXJmb3JtYW5jZSEiKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJmcm9tRXZlbnQiKSwiIGNhbGxzIGZyb20gIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImFkZEV2ZW50TGlzdGVuZXIiKSwiLCBzbyBpdCBjYW4gZG8gcG93ZXJmdWwgdGhpbmdzIGxpa2UgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImtleXVwIiksIiBmb3IgdGhvc2UgdGhhdCBkb24ndCBpbml0aWFsbHkgc3VwcG9ydCBpdC4iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiaW1wb3J0IGZzIGZyb20gJ2ZzJztcblxuZnMucmVhZGRpcignLi9zcmMvc2VydmVyJywgKGVyciwgaXRlbXMpID0+IHtcbiAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKTtcbiAgZWxzZSB7XG4gICAgY29uc29sZS5sb2coaXRlbXMpO1xuICB9XG59KTtcblxuLy8gYWx0ZXJuYXRpdmVcbmNvbnN0IHJlYWRkaXIgPSBSeC5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbEJhY2soZnMucmVhZGRpcik7XG5cbnJlYWRkaXIoJy4vc3JjL3NlcnZlcicpXG4gIC8vIG1lcmdlTWFwIGNyZWF0ZXMgaXRlcmFibGUgY29udmVydGVkIGZyb20gYXJyYXlcbiAgLm1lcmdlTWFwKChmaWxlcykgPT4gUnguT2JzZXJ2YWJsZS5mcm9tKGZpbGVzKSlcbiAgLm1hcCgoZmlsZSkgPT4gYE1BTklQVUxBVEVEICR7ZmlsZX1gKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3JlYWRkaXInKSk7XG5cbi8vIHByb21pc2VzXG5cbmZ1bmN0aW9uIGdldEl0ZW0oKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKCdIZWxsbycpO1xuICAgIH0sIDEwMDApO1xuICB9KTtcbn1cblxuUnguT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZShnZXRJdGVtKCkpLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdwcm9taXNlJykpO1xuIikpLG1keCgiaDIiLHsiaWQiOiIzNS1zdWJqZWN0cyJ9LCIzLjU6IFN1YmplY3RzIiksbWR4KCJwIixudWxsLCJTdWJqZWN0cyBhcmUgYW5vdGhlciBSeCBwcmltaXRpdmUuIFRoZXkgYXJlIGJvdGggYW4gb2JzZXJ2YWJsZSBhbmQgYSBvYnNlcnZlciEgVXNlZCB0byBicmlkZ2Ugbm9uLXJlYWN0aXZlIGNvZGUgd2l0aCByZWFjdGl2ZSBjb2RlLiIpLG1keCgicCIsbnVsbCwiQmVoYXZpb3VyLCByZXBsYXkgc3ViamVjdHMgZXRjLiIpLG1keCgicCIsbnVsbCxtZHgoImVtIix7cGFyZW50TmFtZToicCJ9LCJXYXJuaW5nIiksIjogeW91IHNob3VsZCBvbmx5IHJlYWxseSBjb25zaWRlciB0aGVtIGFzIGEgbGFzdCByZXNvcnQgd2hlbiBicmlkZ2luZyBub24tcmVhY3RpdmUgYW5kIHJlYWN0aXZlIGNvZGUuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksImNvbnN0IHNpbXBsZSA9IG5ldyBSeC5TdWJqZWN0KCk7XG5cbnNpbXBsZS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignc2ltcGxlJykpO1xuXG5zaW1wbGUubmV4dCgnSGVsbG8nKTtcbnNpbXBsZS5uZXh0KCdXb3JsZCcpO1xuc2ltcGxlLmNvbXBsZXRlKCk7XG5cbmNvbnN0IGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDUpO1xuY29uc3QgaW50ZXJ2YWxTdWJqZWN0ID0gbmV3IFJ4LlN1YmplY3QoKTtcbmludGVydmFsU3ViamVjdC5zdWJzY3JpYmUoaW50ZXJ2YWwpO1xuXG5pbnRlcnZhbFN1YmplY3Quc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3N1YjEnKSk7XG5pbnRlcnZhbFN1YmplY3Quc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3N1YjInKSk7XG5pbnRlcnZhbFN1YmplY3Quc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3N1YjMnKSk7XG5cbi8vIHN1YnNjcmliZXMgYWZ0ZXIgdGhyZWUgc2Vjb25kc1xuc2V0VGltZW91dCgoKSA9PiB7XG4gIGludGVydmFsU3ViamVjdC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignTE9PSyBBVCBNRScpKTtcbn0sIDMwMDApO1xuIikpLG1keCgicCIsbnVsbCwiQmVmb3JlLCB3ZSBoYWQgdG8gaW52b2tlIGEgZnVuY3Rpb24gdGhhdCBjYWxsICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJuZXh0IiksIiBhbmQgIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sImNvbXBsZXRlIiksIi4iKSxtZHgoInAiLG51bGwsIkluIHRoZSBhYm92ZSBleGFtcGxlLCBpbnRlcnZhbFN1YmplY3QgaXMgYWN0aW5nIGFzIGEgcHJveHkgdG8gYW5vdGhlciBvYnNlcnZhYmxlLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCIvLyBuZWVkcyBpbml0IHN0YXRlIHBhcmFtZXRlclxuY29uc3QgY3VycmVudFVzZXIgPSBuZXcgUnguQmVoYXZpb3JTdWJqZWN0KHsgaXNMb2dnZWRJbjogZmFsc2UgfSk7XG5jb25zdCBpc0xvZ2dlZEluID0gY3VycmVudFVzZXIubWFwKCh1KSA9PiB1LmlzTG9nZ2VkSW4pO1xuXG5jdXJyZW50VXNlci5uZXh0KHsgaXNMb2dnZWRJbjogZmFsc2UgfSk7XG5pc0xvZ2dlZEluLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdpc0xvZ2dlZEluJykpO1xuXG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgY3VycmVudFVzZXIubmV4dCh7IGlzTG9nZ2VkSW46IHRydWUsIG5hbWU6ICduZWxzb24nIH0pO1xufSwgMzAwMCk7XG5cbnNldFRpbWVvdXQoKCkgPT4ge1xuICBpc0xvZ2dlZC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaXB0aW9uKCdkZWxheWVkJykpO1xufSwgMTUwMCk7XG4iKSksbWR4KCJwIixudWxsLCJIb3cgZG8geW91IHJlbWVtYmVyIG11bHRpcGxlIHN0YXRlcz8iKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiY29uc3QgcmVwbGF5ID0gbmV3IFJ4LlJlcGxheVN1YmplY3QoMyk7XG5yZXBsYXkubmV4dCgxKTtcbnJlcGxheS5uZXh0KDIpO1xuXG5yZXBsYXkuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJvbmVcIikpO1xuXG5yZXBsYXkubmV4dCgzKTtcbnJlcGxheS5uZXh0KDQpO1xucmVwbGF5Lm5leHQoNSk7XG5cbi8vIHRoaXMgc3Vic2NyaXB0aW9uIG9ubHkgZ2V0cyB0aGUgcHJldmlvdXMgdGhyZWUgaXRlbXNcbnJlcGxheS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcInR3b1wiKSk7XG5cbnJlcGxheS5uZXh0KDYpO1xuXG4vLyB3aGF0IHlvdSBzZWVcbm9uZS5uZXh0IDFcbm9uZS5uZXh0IDJcbm9uZS5uZXh0IDNcbm9uZS5uZXh0IDRcbm9uZS5uZXh0IDVcbnR3by5uZXh0IDNcbnR3by5uZXh0IDRcbnR3by5uZXh0IDVcbm9uZS5uZXh0IDZcbnR3by5uZXh0IDZcbiIpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIkFzeW5jIFN1YmplY3RzIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCJjb25zdCBhcGlDYWxsID0gbmV3IFJ4LkFzeW5jU3ViamVjdCgpO1xuYXBpQ2FsbC5uZXh0KDEpO1xuXG5hcGlDYWxsLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwib25lXCIpKTtcbmFwaUNhbGwubmV4dCgyKTtcblxuLy8gb25seSB3aWxsIGVtaXQgdGhlIGZpbmFsIGl0ZW0gYmVmb3JlIGl0IGlzIGNvbXBsZXRlXG5hcGlDYWxsLmNvbXBsZXRlKCk7XG5cbi8vIGlmIHlvdSBzdWJzY3JpYmUgdG8gaXQgYWdhaW4sIHRoYXQgZmluYWwgdmFsdWUgd2lsbCBiZSBlbWl0dGVkXG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICBhcGlDYWxsLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwidHdvXCIpKTtcbn0sIDIwMDApO1xuXG4vLyBvdXRwdXRcbm9uZS5uZXh0IDJcbm9uZS5jb21wbGV0ZVxudHdvLm5leHQgMlxudHdvLmNvbXBsZXRlXG4iKSksbWR4KCJwIixudWxsLG1keCgic3Ryb25nIix7cGFyZW50TmFtZToicCJ9LCJTdWJqZWN0IFN1bW1hcnkiKSksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSwiaWYgeW91IGNhbiBnZXQgYXJvdW5kIGl0LCBkb24ndCB1c2Ugc3ViamVjdHMgdW5sZXNzIHlvdSBoYXZlIHRvIiksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sInlvdSBzaG91bGQgdXNlIGFuIG9ic2VydmFibGUgd29ya2Zsb3cgd2hlcmUgcG9zc2libGUiKSksbWR4KCJoMiIseyJpZCI6IjM2LXJ4anMtcmVzb3VyY2VzLWFuZC1kb2N1bWVudGF0aW9uIn0sIjMuNjogUnhKUyBSZXNvdXJjZXMgYW5kIERvY3VtZW50YXRpb24iKSxtZHgoInAiLG51bGwsIlNvdXJjZXM6IiksbWR4KCJ1bCIsbnVsbCxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoImEiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6ImxpIn0seyJocmVmIjoiaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9yeGpzIn0pLCJSeEpTIEdpdGh1YiIpKSxtZHgoImxpIix7cGFyZW50TmFtZToidWwifSxtZHgoImEiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6ImxpIn0seyJocmVmIjoiaHR0cDovL3J4bWFyYmxlcy5jb20vIn0pLCJSeE1hcmJsZXMiKSksbWR4KCJsaSIse3BhcmVudE5hbWU6InVsIn0sbWR4KCJhIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJsaSJ9LHsiaHJlZiI6Imh0dHA6Ly9qYXJlZGZvcnN5dGguY29tL3J4dmlzaW9uL2V4YW1wbGVzL3BsYXlncm91bmQvIn0pLCJSeFZpc2lvbiBQbGF5Z3JvdW5kIikpKSxtZHgoImgyIix7ImlkIjoiMzctc2hhcmluZy1vYnNlcnZhYmxlLXNlcXVlbmNlcyJ9LCIzLjc6IFNoYXJpbmcgT2JzZXJ2YWJsZSBTZXF1ZW5jZXMiKSxtZHgoInVsIixudWxsLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJIb3QgT2JzZXJ2YWJsZTogSXQgd2lsbCBwcm9kdWNlIGV2ZW50cyByZWdhcmRsZXNzIG9mIGlmIHlvdSdyZSBsaXN0ZW5pbmcgLSBlZy4iLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6ImxpIn0sImZyb21FdmVudCgkdGl0bGUsICdrZXl1cCcpIikpLG1keCgibGkiLHtwYXJlbnROYW1lOiJ1bCJ9LCJDb2xkIE9ic2VyYWJsZTogU3RhcnRzIG9uY2UgeW91IHN1YnNjcmliZSAtIEludGVydmFsIE9ic2VydmFibGVzIGFyZSBhY3R1YWxseSBjb2xkIG9ic2VydmFibGVzIikpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCIvLyB0aGlzIGV4YW1wbGUgc2hvd3Mgd2hlbiBib3RoIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZyBlZyBjb2xkXG5pbXBvcnQgUnggZnJvbSAncnhqcy9SeCc7XG5cbmNvbnN0IGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcblxuc2V0VGltZW91dCgoKSA9PiB7XG4gIGludGVydmFsLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdvbmUnKSk7XG59LCAxMjAwKTtcblxuc2V0VGltZW91dCgoKSA9PiB7XG4gIGludGVydmFsLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCd0d28nKSk7XG59LCAzMjAwKTtcblxuLy8gSE9UXG4vLyBjb25uZWN0YWJsZSBvYnNlcnZhYmxlXG5pbXBvcnQgUnggZnJvbSAncnhqcy9SeCc7XG5cbmNvbnN0IGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKVxuICAudGFrZSgxMClcbiAgLnB1Ymxpc2goKTtcblxuaW50ZXJ2YWwuY29ubmVjdCgpO1xuXG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgaW50ZXJ2YWwuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ29uZScpKTtcbn0sIDEyMDApO1xuXG5zZXRUaW1lb3V0KCgpID0+IHtcbiAgaW50ZXJ2YWwuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3R3bycpKTtcbn0sIDMyMDApO1xuXG4vLyBpZiB5b3UgY29ubmVjdCBhZnRlciBhIHNldCBpbnRlcnZhbCwgdGhlbiBpdCBiZWdpbnMgZXhlY3V0aW5nIGFuZCBzaGFyaW5nIHRoZSB1bmRlcmx5aW5nIG9ic2VydmFibGVcbiIpKSxtZHgoInAiLG51bGwsbWR4KCJzdHJvbmciLHtwYXJlbnROYW1lOiJwIn0sIldoeSB3b3VsZCB5b3Ugd2FudCBhIGhvdCB2YXJpYWJsZT8iKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIi8vIGhlcmUgc3Vic2NyaWJlIGNvbnNvbGUubG9nIHJ1bnMgdHdpY2VcbmNvbnN0IHNvY2tldCA9IHsgb246ICgpID0+IHt9IH07XG5jb25zdCBjaGF0TWVzc2FnZSA9IG5ldyBSeC5PYnNlcnZhYmxlKChvYnNlcnZhYmxlKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdzdWJzY3JpYmVkJyk7XG4gIHNvY2tldC5vbignY2hhdDptZXNzYWdlJywgKG1lc3NhZ2UpID0+IG9ic2VydmVyLm5leHQobWVzc2FnZSkpO1xufSk7XG5cbmNoYXRNZXNzYWdlLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdvbmUnKSk7XG5jaGF0TWVzc2FnZS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigndHdvJykpO1xuXG4vLyB3aXRob3V0IGl0XG5cbmNvbnN0IHNvY2tldCA9IHsgb246ICgpID0+IHt9IH07XG5jb25zdCBjaGF0TWVzc2FnZSA9IG5ldyBSeC5PYnNlcnZhYmxlKChvYnNlcnZhYmxlKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdzdWJzY3JpYmVkJyk7XG4gIHNvY2tldC5vbignY2hhdDptZXNzYWdlJywgKG1lc3NhZ2UpID0+IG9ic2VydmVyLm5leHQobWVzc2FnZSkpO1xufSkucHVibGlzaCgpO1xuXG5jaGF0TWVzc2FnZS5jb25uZWN0KCk7XG5cbmNoYXRNZXNzYWdlLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdvbmUnKSk7XG5jaGF0TWVzc2FnZS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigndHdvJykpO1xuXG4vLyB1c2luZyBwdWJsaXNoTGFzdCgpXG5jb25zdCBzaW1wbGUgPSBuZXcgUnguT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgb2JzZXJ2ZXIubmV4dCgnb25lJyk7XG4gIG9ic2VydmVyLm5leHQoJ3R3bycpO1xuICBvYnNlcnZlci5jb21wbGV0ZSgpO1xufSk7XG5cbi8vIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHZhbHVlXG5jb25zdCBwdWJsaXNoZWQgPSBzaW1wbGUucHVibGlzaExhc3QoKTtcblxuLy8gZXZlbiBpZiB3ZSBzdWJzY3JpYmUgYmVmb3JlIGNvbm5lY3QsIGJvdGggd2lsbCBnZXQgdGhlIGxhc3QgdmFsdWVcbnB1Ymxpc2hlZC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignb25lJykpO1xucHVibGlzaGVkLmNvbm5lY3QoKTtcbnB1Ymxpc2hlZC5zdWJzY3JpYmUoY3JlYVN1YnNjcmliZXIoJ3R3bycpKTtcblxuLy8gdXNpbmcgcHVibGlzaFJlcGxheSgpXG5jb25zdCBzaW1wbGUgPSBuZXcgUnguT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgb2JzZXJ2ZXIubmV4dCgnb25lJyk7XG4gIG9ic2VydmVyLm5leHQoJ3R3bycpO1xuICBvYnNlcnZlci5uZXh0KCd0aHJlZScpO1xuXG4gIHJldHVybiAoKSA9PiBjb25zb2xlLmxvZygnRGlzcG9zZWQnKTtcbn0pO1xuXG4vLyBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB2YWx1ZVxuY29uc3QgcHVibGlzaGVkID0gc2ltcGxlLnB1Ymxpc2hSZXBsYXkoMik7XG5cbi8vIGV2ZW4gaWYgd2Ugc3Vic2NyaWJlIGJlZm9yZSBjb25uZWN0LCBib3RoIHdpbGwgZ2V0IHRoZSBsYXN0IHZhbHVlXG4vLyB0byBkaXNwb3NlIHdpdGhvdXQgcnVubmluZyBjb21wbGV0ZSwgd2UgbmVlZCB0byBkaXNjb25uZWN0IGJ5IHVuc3Vic2NyaWJpbmdcbmNvbnN0IHN1YjEgPSBwdWJsaXNoZWQuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ29uZScpKTtcbmNvbnN0IGNvbm5lY3Rpb24gPSBwdWJsaXNoZWQuY29ubmVjdCgpO1xuY29uc3Qgc3ViMiA9IHB1Ymxpc2hlZC5zdWJzY3JpYmUoY3JlYVN1YnNjcmliZXIoJ3R3bycpKTtcblxuc3ViMS51bnN1YnNjcmliZSgpO1xuc3ViMi51bnN1YnNjcmliZSgpO1xuXG5jb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4iKSksbWR4KCJwIixudWxsLCJSZWZjb3VudCBpcyBhIHdheSB0byBhdXRvbWF0aWNhbGx5IGhhbmRsZSB0aGUgY29ubmVjdGlvbiBhbmQgdGhlIHVuc3Vic2NyaXB0aW9uIG9mIGEgY29ubmVjdGlvbiBvYnNlcnZhYmxlLiIpLG1keCgicCIsbnVsbCwiSXQgd2lsbCBjb25uZWN0IHRvIHRoZSBmaXJzdCBzdWJzY3JpcHRpb24gYW5kIHRoZW4gZGlzY29ubmVjdGVkIG9uIHRoZSBsYXN0IHVuc3Vic2NyaWJlLiIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0se30pLCIvLyB1c2luZyByZWZDb3VudCgpXG5jb25zdCBzaW1wbGUgPSBuZXcgUnguT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgb2JzZXJ2ZXIubmV4dChcIm9uZVwiKTtcbiAgICBvYnNlcnZlci5uZXh0KFwidHdvXCIpO1xuICAgIG9ic2VydmVyLm5leHQoXCJ0aHJlZVwiKTtcblxuICAgIHJldHVybiAoKSA9PiBjb25zb2xlLmxvZyhcIkRpc3Bvc2VkXCIpO1xufSk7XG5cbi8vIGFsd2F5cyByZXR1cm5zIHRoZSBsYXN0IHZhbHVlXG5jb25zdCBwdWJsaXNoZWQgPSBzaW1wbGUucHVibGlzaFJlcGxheSgyKS5yZWZDb3VudCgpO1xuXG4vLyBldmVuIGlmIHdlIHN1YnNjcmliZSBiZWZvcmUgY29ubmVjdCwgYm90aCB3aWxsIGdldCB0aGUgbGFzdCB2YWx1ZVxuLy8gdG8gZGlzcG9zZSB3aXRob3V0IHJ1bm5pbmcgY29tcGxldGUsIHdlIG5lZWQgdG8gZGlzY29ubmVjdCBieSB1bnN1YnNjcmliaW5nXG5jb25zdCBzdWIxID0gcHVibGlzaGVkLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwib25lXCIpKTtcbmNvbnN0IHN1YjIgPSBwdWJsaXNoZWQuc3Vic2NyaWJlKGNyZWFTdWJzY3JpYmVyKFwidHdvXCIpKTtcblxuc3ViMS51bnN1YnNjcmliZSgpO1xuc3ViMi51bnN1YnNjcmliZSgpO1xuIikpLG1keCgicCIsbnVsbCwiVGhlICIsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LCJwdWJsaXNoKCkucmVmQ291bnQoKSIpLCIgaXMgZG9uZSBzbyBvZnRlbiwgdGhhdCBpcyBoYXMgYmVlbiB0dXJuZWQgaW4gIixtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sInNoYXJlKCkiKSwiLiIpLG1keCgicCIsbnVsbCwiVGF4aW5nIHByb2Nlc3NlcyB0aGF0IHlvdSBkb24ndCB3YW50IHRvIHJlcGVhdCBidXQgeW91IHdhbnQgbXVsdGlwbGUgdGhpbmdzIHRvIGhvb2sgaW50byB0aGUgcmVzdWx0LCB0aGVuIHR1cm4gaXQgaW50byBhIGhvdCBzdWJzY3JpcHRpb24uIiksbWR4KCJociIsbnVsbCksbWR4KCJoMiIseyJpZCI6IjQwLW9wZXJhdG9ycy10aGF0LWV2ZXJ5b25lLXNob3VsZC1rbm93In0sIjQuMDogT3BlcmF0b3JzIHRoYXQgZXZlcnlvbmUgc2hvdWxkIGtub3ciKSxtZHgoInAiLG51bGwsIk5vdyB3ZSB3aWxsIGp1c3QgdGFsayBhYm91dCB0aGUgZGlmZmVyZW50IHByaW1hcnkgb3BlcmF0b3JzIHRoYXQgeW91IHdpbGwgd29yayB3aXRoLiIpLG1keCgiaDIiLHsiaWQiOiI0MS1kby0tZmluYWxseS0tc3RhcnR3aXRoLS1maWx0ZXIifSwiNC4xOiBEbyAvIEZpbmFsbHkgLyBTdGFydFdpdGggLyBGaWx0ZXIiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiLy8gZG8gPT4gZ2V0IHRoZSBuZXh0IHZhbHVlIGFuZCBwYXNzIGl0IGJhY2sgdW5jaGFuZ2VkXG4vLyBmaW5hbGx5ID0+IG9ubHkgY29tcGxldGVzIGFmdGVyIHRoZSByYW5nZSBoYXMgY29tcGxldGVkLCBydW5zIHJpZ2h0IGF0IHRoZSBlbmQgb2YgdGhlIGZpbmFsIHZhbHVlXG4vLyBmaWx0ZXIgPT4gZmlsdGVycyBvdXQgZ2l2ZW4gc3RhdGVtZW50XG4vLyBpbnRlcnZhbCA9PiBjYWxsIHRpbWVvdXRcbi8vIHN0YXJ0V2l0aCA9PiBzZXQgaW5pdGlhbCB2YWx1ZVxuXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKVxuICAuZG8oKGEpID0+IGNvbnNvbGUubG9nKGBGcm9tIGRvICR7YX1gKSlcbiAgLm1hcCgoYSkgPT4gYSAqIGEpXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignc2ltcGxlJykpO1xuXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKVxuICAuZmluYWxseSgoKSA9PiBjb25zb2xlLmxvZyhgRnJvbSBmaW5hbGx5YCkpXG4gIC5tYXAoKGEpID0+IGEgKiAyKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ2ZpbmFsbHknKSk7XG5cblJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApXG4gIC5maWx0ZXIoKGEpID0+IGEgPCA1KVxuICAubWFwKChhKSA9PiBhICogMilcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdmaWx0ZXInKSk7XG5cblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMClcbiAgLnN0YXJ0V2l0aCgtMSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdpbnRlcnZhbCcpKTtcbiIpKSxtZHgoImgyIix7ImlkIjoiNDItbWVyZ2UtLWNvbmNhdCJ9LCI0LjI6IE1lcmdlIC8gQ29uY2F0IiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIi8vIG1lcmdlIC0gbWVyZ2UgbWFueSBvYnNlcnZhYmxlcyB0b2dldGhlcnNcbi8vIGNvbmNhdCAtIHRoaXMgY29uY2F0ZW5hdGVzIG9ic2VydmFibGVzIHRvIHRoZSBlbmQgb2YgYW5vdGhlciwgY2FuIGFsc28gdGFrZSBhIGxpc3Qgb2YgT2JzZXJ2YWJsZXNcblxuUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKVxuICAgIC5tZXJnZShSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkpXG4gICAgLnRha2UoNSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJtZXJnZTFcIikpO1xuXG5SeC5PYnNlcnZhYmxlLm1lcmdlKFxuICAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkubWFwKGkgPT4gYCR7aX0gc2Vjb25kcyksXG4gICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLm1hcChpID0+IGAke2l9IGhhbGYgc2Vjb25kcykpXG4gICAgLnRha2UoNSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ21lcmdlMicpKTtcblxuLy8gZGlmZmVyZW50IGV2ZW50cyBmb3IgbWVyZ2VkIG9ic2VydmFibGVzXG5SeC5PYnNlcnZhYmxlLm1lcmdlKFxuICAgIHNvY2tldC5vbiQoXCJsb2dpblwiKS5tYXAodXNlciA9PiBwcm9jZXNzVXNlcih1c2VyKSxcbiAgICBzb2NrZXQub24kKFwibG9nb3V0XCIpLm1hcCgoKSA9PiBudWxsKSk7XG5cblJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgNSlcbiAgICAuY29uY2F0KFJ4Lk9ic2VydmFibGUucmFuZ2UoMTAsMykpXG4gICAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKFwiY29uY2F0MVwiKSk7XG4iKSksbWR4KCJoMiIseyJpZCI6IjQzLW1hcC0tbWVyZ2VtYXAtLXN3aXRjaG1hcCJ9LCI0LjM6IE1hcCAvIE1lcmdlTWFwIC8gU3dpdGNoTWFwIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIi8vIG1hcCAtIGEgcHJvamVjdGlvbiBvbiBldmVyeSBpdGVtIHRoYXQgY29tZXMgaW5cbi8vIG1lcmdlTWFwIC0gc2VsZWN0IG1hbnksIGRvZXMgcHJvamVjdGlvbiBhbmQgdGhlbiBoYXMgYW5vdGhlciB0aGluZyB0aGF0IHdlIHdpbGwgd29yayBvblxuLy8gc3dpdGNoTWFwIC0gc2ltaWxhciB0byBtZXJnZU1hcCBidXQgcmVwbGFjZXMgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlIGlmIGFub3RoZXIgZW1pc3Npb24gY29tZXMgaW5cblxuZnVuY3Rpb24gYXJyYXlNYXAoYXJyLCBwcm9qKSB7XG4gIGxldCByZXR1cm5BcnJheSA9IFtdO1xuICBmb3IgKGxldCBpIG9mIGFycikge1xuICAgIHJldHVybkFycmF5LnB1c2gocHJvaihpdGVtKSk7XG4gIH1cblxuICByZXR1cm4gcmV0dXJuQXJyYXk7XG59XG5cbmFycmF5TWFwKFsxLCAyLCAzXSwgKGEpID0+IGEgKiBhKTtcblxuLy8gaW1hZ2luZSBhcnJheSBvZiBkaWN0c1xuY29uc3QgYWxidW1zID0gW3t9LCB7fV07XG5cbmZ1bmN0aW9uIGFycmF5TWVyZ2VNYXAoYXJyLCBwcm9qKSB7XG4gIGxldCByZXR1cm5BcnJheSA9IFtdO1xuICBmb3IgKGxldCBpIG9mIGFycikge1xuICAgIGxldCBwcm9qQXJyYXkgPSBwcm9qKGl0ZW0pO1xuICAgIGZvciAobGV0IGogb2YgcHJvakFycmF5KSB7XG4gICAgICByZXR1cm5BcnJheS5wdXNoKHByb2ooaXRlbSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5BcnJheTtcbn1cblxuY29uc3QgdHJhY2tzID0gYXJyYXlNZXJnZU1hcChhbGJ1bXMsIChhbGJ1bSkgPT4gYWxidW0udHJhY2tzKTtcblxuUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAzKVxuICAubWVyZ2VNYXAoKGkpID0+XG4gICAgUnguT2JzZXJ2YWJsZS50aW1lcihpICogMTAwMCkubWFwKCgpID0+IGBBZnRlciAke2l9IHNlY29uZHNgKVxuICApXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignbWVyZ2VNYXAnKSk7XG5cblJ4Lk9ic2VydmFibGUuZnJvbVByb21pc2UoZ2V0VHJhY2tzKCkpXG4gIC5tZXJnZU1hcCgodHJhY2tzKSA9PiBSeC5PYnNlcnZhYmxlLmZyb20odHJhY2tzKSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCd0cmFja3MnKSk7XG5cbmZ1bmN0aW9uIGdldFRyYWNrcygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc29sdmUoWyd0cmFjayAxJywgJ3RyYWNrIDInLCAndHJhY2sgMyddKTtcbiAgICB9LCAxMDAwKTtcbiAgfSk7XG59XG5cbi8vIHN5bmNocm9ub3VzIGV4YW1wbGVcblJ4Lk9ic2VydmFibGUub2YoJ215IHF1ZXJ5JylcbiAgLmRvKCgpID0+IGNvbnNvbGUubG9nKCdRdWVyeWluZycpKVxuICAubWVyZ2VNYXAoKGEpID0+IHF1ZXJ5KGEpKVxuICAuZG8oKCkgPT4gY29uc29sZS5sb2coJ0FmdGVyIHF1ZXJ5aW5nJykpXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigncXVlcnknKSk7XG5cbmZ1bmN0aW9uIHF1ZXJ5KHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKCdUaGlzIGlzIHRoZSByZXNvbHZlZCB2YWx1ZScpO1xuICAgIH0sIDEwMDApO1xuICB9KTtcbn1cblxuLy8gc3dpdGNoIG1hcFxuIikpLG1keCgiaDIiLHsiaWQiOiI0NC1yZWR1Y2UtLXNjYW4ifSwiNC40OiBSZWR1Y2UgLyBTY2FuIiksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixPYmplY3QuYXNzaWduKHtwYXJlbnROYW1lOiJwcmUifSx7ImNsYXNzTmFtZSI6Imxhbmd1YWdlLWphdmFzY3JpcHQifSksIi8vIHJlZHVjZXIgKGFjYywgdmFsdWUpIGFuZCB3b3JrcyBvbiB2YWx1ZSAtIGRvZXNuJ3QgZW1pdCB1bnRpbCB0aGUgY29tcGxldGlvblxuLy8gc2NhbiAtIHByb2Nlc3NlcyBhbmQgZW1pdHMgYXMgaXQgY29tZXMgaW5cblJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApXG4gIC5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyArIHZhbHVlKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3JlZHVjZScpKTtcblxuUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMClcbiAgLnNjYW4oKGFjYywgdmFsdWUpID0+IGFjYyArIHZhbHVlKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NjYW4nKSk7XG4iKSksbWR4KCJoMiIseyJpZCI6IjQ1LWJ1ZmZlci0tdG9hcnJheSJ9LCI0LjU6IEJ1ZmZlciAvIFRvQXJyYXkiKSxtZHgoInAiLG51bGwsIlRoZXJlIGhhdmUgYmVlbiBzb21lIGJpZyBjaGFuZ2VzIHRvIGhvdyAiLG1keCgiaW5saW5lQ29kZSIse3BhcmVudE5hbWU6InAifSwiYnVmZmVyIiksIiBoYXMgYmVlbiB1c2VkLiIpLG1keCgicCIsbnVsbCwiQnVmZmVyIHRha2VzIGluIGFuIG9ic2VydmFibGUuIiksbWR4KCJwIixudWxsLCJ0b0FycmF5IHdpbGwgY29udmVydCByZXN1bHRzIGludG8gYW4gYXJyYXkuIC0gc3RpbGwgaGFzIGEgY2xlYW4gZXhpdCBpZiB0aGUgbmV2ZXIoKSBpcyBpbXBsZW1lbnRlZCEiKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLE9iamVjdC5hc3NpZ24oe3BhcmVudE5hbWU6InByZSJ9LHsiY2xhc3NOYW1lIjoibGFuZ3VhZ2UtamF2YXNjcmlwdCJ9KSwiUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMDApXG4gICAgLmJ1ZmZlckNvdW50KDI1KVxuICAgIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihcIml0ZW1zXCIpO1xuXG4vLyB3aWxsIHRha2UgMjUgaXRlbXMgYW5kIHB1c2hpbmcgdGhlbSBpbnRvIGFuIGFycmF5XG5cblxuUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApXG4gICAgLmJ1ZmZlclRpbWUoMjAwMClcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJidWZmZXJUaW1lXCIpO1xuXG4vLyBzYW1lIGJlaGF2aW91ciFcbi8vIGVtaXR0aW5nIGV2ZW50IGNhdXNlcyBidWZmZXIgdG8gZmx1c2hcblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKVxuICAgIC5idWZmZXIoUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKSlcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJidWZmZXJcIik7XG5cbi8vXG4vLyB0b0FycmF5XG4vL1xuXG5SeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKVxuICAgIC50b0FycmF5KClcbiAgICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoXCJyYW5nZVwiKSk7XG4iKSksbWR4KCJoMiIseyJpZCI6IjQ2LWZpcnN0LS1sYXN0LS1zaW5nbGUtLXNraXAtLXRha2UifSwiNC42OiBGaXJzdCAvIExhc3QgLyBTaW5nbGUgLyBTa2lwIC8gVGFrZSIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJjb25zdCBzaW1wbGUgPSBuZXcgUnguT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgY29uc29sZS5sb2coJ0dlbmVyYXRpbmcgc2VxdWVuY2UnKTtcbiAgb2JzZXJ2ZXIubmV4dCgxKTtcbiAgb2JzZXJ2ZXIubmV4dCgyKTtcbiAgb2JzZXJ2ZXIubmV4dCgzKTtcbiAgb2JzZXJ2ZXIubmV4dCg0KTtcbiAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbn0pO1xuXG5zaW1wbGUuZmlyc3QoKS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignZmlyc3QnKSk7XG5cbnNpbXBsZS5sYXN0KCkuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ2xhc3QnKSk7XG5cbi8vIGRpc3BsYXlzIDEgJiA0XG4vLyBpZiBub3RoaW5nIGlzIGluIHRoZXJlLCB0aGVyZSBhcmUgRW1wdHlFcnJvcihzKSB0aHJvd25cblxuLy8gc2luZ2xlLmVycm9yIHRocm93biBpcyBtb3JlIHRoYW4gb25lIGVycm9yIHRocm93blxuc2ltcGxlLnNpbmdsZSgpLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCdzaW5nbGUnKSk7XG5cbi8vIHRha2UgYW5kIHNraXAgd29uJ3QgdGhyb3cgZXJyb3JzXG4vLyB0YWtlIGRvZXMgdGhlIGZpcnN0IGhvd2V2ZXIgZW1pc3Npb25zXG4vLyBza2lwIHdpbGwgdGFrZSB0aGUgZW1pc3Npb25zIGFmdGVyIGEgbnVtYmVyXG5zaW1wbGUudGFrZSgyKS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcigndGFrZScpKTtcblxuc2ltcGxlLnNraXAoMikuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NraXAnKSk7XG5cbi8vIDMsIDRcbnNpbXBsZVxuICAuc2tpcCgyKVxuICAudGFrZSgyKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NraXAnKSk7XG5cbi8vIHNraXBXaGlsZSAvIHRha2VXaGlsZVxuUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApXG4gIC5za2lwV2hpbGUoKGkpID0+IGkgPCA0KVxuICAudGFrZVdoaWxlKChpKSA9PiBpIDwgMTApXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignc2tpcFdoaWxlL3Rha2VXaGlsZScpKTtcblxuLy8gd2hhdCdzIHVudGlsIGFuZCB0YWtlIGVtaXNzaW9ucyB1bnRpbFxuUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApXG4gIC5za2lwVW50aWwoUnguT2JzZXJ2YWJsZS50aW1lcigxMDAwKSlcbiAgLnRha2VVbnRpbChSeC5PYnNlcnZhYmxlLnRpbWVyKDQwMDApKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3NraXBVbnRpbCcpKTtcbiIpKSxtZHgoImgyIix7ImlkIjoiNDctemlwLS13aXRobGF0ZXN0ZnJvbS0tY29tYmluZWxhdGVzdCJ9LCI0Ljc6IFppcCAvIFdpdGhMYXRlc3RGcm9tIC8gQ29tYmluZUxhdGVzdCIpLG1keCgicCIsbnVsbCwiSG93IGNhbiB3ZSBjb21iaW5lIG9ic2VydmFibGVzIGluIGRpZmZlcmVudCB3YXlzPyIpLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsT2JqZWN0LmFzc2lnbih7cGFyZW50TmFtZToicHJlIn0seyJjbGFzc05hbWUiOiJsYW5ndWFnZS1qYXZhc2NyaXB0In0pLCJmdW5jdGlvbiBhcnJheVppcChhcnIxLCBhcnIyLCBzZWxlY3RvckZ1bmMpIHtcbiAgY29uc3QgY291bnQgPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3QgY29tYmluZWQgPSBzZWxlY3RvcihhcnIxW2ldLCBhcnIyW2ldKTtcbiAgICByZXN1bHRzLnB1c2goY29tYmluZWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmNvbnN0IGFycjEgPSBbMzIsIDIsIDUyLCA0MywgNTRdO1xuY29uc3QgYXJyMiA9IFsxLCAwLCAxMCwgNCwgMSwgNCwgNiwgMl07XG5jb25zdCByZXN1bHRzID0gYXJyYXlaaXAoYXJyMSwgYXJyMiwgKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICogcmlnaHQpO1xuXG5jb25zb2xlLmxvZyhyZXN1bHRzKTtcblxuLy8gaW4gUnhKU1xuUnguT2JzZXJ2YWJsZS5yYW5nZSgxLjEpXG4gIC56aXAoXG4gICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLFxuICAgIChsZWZ0LCByaWdodCkgPT4gYGl0ZW06ICR7bGVmdH0sIGF0ICR7cmlnaHQgKiA1MDB9YFxuICApXG4gIC5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcignemlwJykpO1xuXG4vLyBlbWl0cyB2YWx1ZSB3aGVuIHNvdXJjZSBlbWl0c1xuLy8gY2FuIGFsc28gcGFzcyAobGVmdCwgcmlnaHQpIGZ1bmN0aW9uIGxpa2UgemlwIGFzIHNlY29uZCBwYXJhbWV0ZXJcblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMClcbiAgLndpdGhMYXRlc3RGcm9tKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKSlcbiAgLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKCd3aXRoTGF0ZXN0RnJvbScpKTtcblxuLy8gZW1pdCB2YWx1ZSBpZiBlaXRoZXIgZG9cblJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMClcbiAgLmNvbWJpbmVMYXRlc3QoUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApKVxuICAuc3Vic2NyaWJlKGNyZWF0ZVN1YnNjcmliZXIoJ3dpdGhMYXRlc3RGcm9tJykpO1xuIikpLG1keCgiaDIiLHsiaWQiOiI0OC1lcnJvci1oYW5kbGluZy1jYXRjaC1hbmQtcmV0cnkifSwiNC44OiBFcnJvciBIYW5kbGluZyBDYXRjaCBhbmQgUmV0cnkiKSxtZHgoInAiLG51bGwsIklmIGFuIGVycm9yIGhhcHBlbnMsIGFuIG9ic2VydmVyIHN0b3BzIGVtaXR0aW5nIGFuZCBjYW4gcHJldmVudCB2YWx1ZXMgZnJvbSBlbWl0dGluZyBhdCBhbGwuIEVycm9yIGhhbmRsaW5nIGlzIHZlcnkgaW1wb3J0YW50ISIpLG1keCgicCIsbnVsbCxtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sIi5jYXRjaChlcnJvciA9PiBSeC5PYnNlcnZhYmxlLm9mKGVycm9yKSkiKSwiIGNhbiBwYXNzIHRoaXMgZG93biBhcyBhbiBPYnNlcnZhYmxlLiIpLG1keCgicCIsbnVsbCxtZHgoImlubGluZUNvZGUiLHtwYXJlbnROYW1lOiJwIn0sIi5yZXRyeSgpIiksIiB3ZSBjYW4gcGFzcyBpbiB3aXRoIGEgbnVtZXJhbCB0byBlbnN1cmUgdGhhdCB3ZSBlaXRoZXIga2VlcCByZXRyeWluZyBvciByZXRyeSBhIGNlcnRhaW4gbnVtYmVyIG9mIHRpbWVzLiIpKTt9aWYodHlwZW9mIE1EWENvbnRlbnQhPT0ndW5kZWZpbmVkJyYmTURYQ29udGVudCYmTURYQ29udGVudD09PU9iamVjdChNRFhDb250ZW50KSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShNRFhDb250ZW50KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KE1EWENvbnRlbnQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6Ik1EWENvbnRlbnQiLGZpbGVuYW1lOiJtYW51YWwvSmF2YVNjcmlwdC9KUy1SeEpTLm1kIn19KTt9TURYQ29udGVudC5pc01EWENvbXBvbmVudD10cnVlOw=="},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-RxJS.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"rxjs\"\n    }}>{`RxJS`}</h1>\n    {\n      /* TOC -->autoauto- [RxJS](#rxjs)auto    - [1.0 A Brief Recap of Programming Paradigms](#10-a-brief-recap-of-programming-paradigms)auto        - [Procedural Program](#procedural-program)auto        - [Object Oriented](#object-oriented)auto        - [Declarative](#declarative)auto    - [1.1: Core Reactive Concepts](#11-core-reactive-concepts)auto    - [1.2: Comparing the Autocomplete function using JS vs RxJS](#12-comparing-the-autocomplete-function-using-js-vs-rxjs)auto    - [3: The Core of Reactive Extensions](#3-the-core-of-reactive-extensions)auto    - [3.1: Obervables, Operators and Subscriptions](#31-obervables-operators-and-subscriptions)auto    - [3.2 Creating Observables](#32-creating-observables)auto    - [3.3: Built in Observables](#33-built-in-observables)auto    - [3.4: Using RxJS with Node, jQuery and Promises](#34-using-rxjs-with-node-jquery-and-promises)auto    - [3.5: Subjects](#35-subjects)auto    - [3.6: RxJS Resources and Documentation](#36-rxjs-resources-and-documentation)auto    - [3.7: Sharing Observable Sequences](#37-sharing-observable-sequences)auto    - [4.0: Operators that everyone should know](#40-operators-that-everyone-should-know)auto    - [4.1: Do / Finally / StartWith / Filter](#41-do--finally--startwith--filter)auto    - [4.2: Merge / Concat](#42-merge--concat)auto    - [4.3: Map / MergeMap / SwitchMap](#43-map--mergemap--switchmap)auto    - [4.4: Reduce / Scan](#44-reduce--scan)auto    - [4.5: Buffer / ToArray](#45-buffer--toarray)auto    - [4.6: First / Last / Single / Skip / Take](#46-first--last--single--skip--take)auto    - [4.7: Zip / WithLatestFrom / CombineLatest](#47-zip--withlatestfrom--combinelatest)auto    - [4.8: Error Handling Catch and Retry](#48-error-handling-catch-and-retry)autoauto<!-- /TOC */\n    }\n    <h2 {...{\n      \"id\": \"10-a-brief-recap-of-programming-paradigms\"\n    }}>{`1.0 A Brief Recap of Programming Paradigms`}</h2>\n    <h3 {...{\n      \"id\": \"procedural-program\"\n    }}>{`Procedural Program`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`The ideas that programs are a sense of functions`}</li>\n      <li parentName=\"ul\">{`Goes from top to bottom`}</li>\n      <li parentName=\"ul\">{`Relies heavily on global state, but any line can change the global state`}</li>\n      <li parentName=\"ul\">{`C being a procedural language`}</li>\n      <li parentName=\"ul\">{`\"Imperative\" execution`}</li>\n      <li parentName=\"ul\">{`Easy to write, difficult to maintain`}</li>\n      <li parentName=\"ul\">{`Prone to difficult bugs`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"object-oriented\"\n    }}>{`Object Oriented`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Based around a Primitive: object`}</li>\n      <li parentName=\"ul\">{`Objects have well defined interfaces`}</li>\n      <li parentName=\"ul\">{`Localised behaviour`}</li>\n      <li parentName=\"ul\">{`Objects control state`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Code is still imperative - pro AND con! - Still telling the computer EXACTLY what to do.`}</li>\n      <li parentName=\"ul\">{`Can be more verbose`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"declarative\"\n    }}>{`Declarative`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Describing what you want to happen, but not telling the computer how to do it`}</li>\n      <li parentName=\"ul\">{`Eg. SQL, Regex, HTML`}</li>\n      <li parentName=\"ul\">{`Data is self-describing`}</li>\n      <li parentName=\"ul\">{`As powerful as the interpreter allows`}</li>\n      <li parentName=\"ul\">{`As limiting as the interpreter allows - You want build a game in SQL etc.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"functional\"\n    }}>{`Functional`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`What we want to happen but not how`}</li>\n      <li parentName=\"ul\">{`Little state`}</li>\n      <li parentName=\"ul\">{`Few side effects`}</li>\n      <li parentName=\"ul\">{`Easy to reason about`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Expressive`}</li>\n      <li parentName=\"ul\">{`Works great with OO`}</li>\n      <li parentName=\"ul\">{`Basis in higher math`}</li>\n      <li parentName=\"ul\">{`Cons to think differently`}</li>\n      <li parentName=\"ul\">{`Not always the best choice`}</li>\n      <li parentName=\"ul\">{`No loops, no control logic - Just telling it what we want to happen`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"reactive\"\n    }}>{`Reactive`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Primitive: Observable`}</li>\n      <li parentName=\"ul\">{`Instead of describing data in terms of other data, we describe it in terms of streams of events - From this, we create a pipeline such that we certain data changes, a lot is processed and changed - Example: spreadsheets!`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Expressive`}</li>\n      <li parentName=\"ul\">{`Data flows unidirectionally`}</li>\n      <li parentName=\"ul\">{`Tough to think differently`}</li>\n      <li parentName=\"ul\">{`Subscriptions help change the data`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const cellC2$ = cellA2$\n  .combineLatest(cellB2$)\n  .map((cells) => cells[0] + cells[1]);\n\ncellC2$.subscribe((value) => {\n  console.log(value);\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"11-core-reactive-concepts\"\n    }}>{`1.1: Core Reactive Concepts`}</h2>\n    <p><strong parentName=\"p\">{`Core Concept 1: Pull model vs Push model`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`any data sitting there that you \"ask\" for at some point - example refresh button - manual button trigger - time interval`}</li>\n      <li parentName=\"ul\">{`observable (stream) which is a reactive data source - produces items over a period of time that will either error, complete, or never complete until a page closes - not telling the stream when to get data, it has inbuilt logic on how to get data - we may transform this data - the display of the data is actually part of the description`}</li>\n    </ul>\n    <p>{`An an example for a `}<inlineCode parentName=\"p\">{`pull`}</inlineCode>{` based code, we can think of a window.setInterval() that fires every 5000 seconds.`}</p>\n    <p>{`An example of a push would be to have a function fire and then the return continutes to filter, flatMap, map and subscribe.`}</p>\n    <p><strong parentName=\"p\">{`Core Concept 2: Everything is a database`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`mouse movements`}</li>\n      <li parentName=\"ul\">{`current user`}</li>\n      <li parentName=\"ul\">{`web requests`}</li>\n      <li parentName=\"ul\">{`input boxes`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"12-comparing-the-autocomplete-function-using-js-vs-rxjs\"\n    }}>{`1.2: Comparing the Autocomplete function using JS vs RxJS`}</h2>\n    <p>{`In the comparison where the `}<inlineCode parentName=\"p\">{`$title.on('keyup', () => {})`}</inlineCode>{` runs with a promise returned. The query can run into race conditions.`}</p>\n    <p>{`Also note that every single result also fires.`}</p>\n    <p>{`The issues:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`// Fix up and down arrow\n// Stop always querying\n// Getting race condition\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Bad ways`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`generally `}<inlineCode parentName=\"li\">{`if last query == currentTitle return`}</inlineCode></li>\n      <li parentName=\"ul\">{`using setTimeout to reduce number of queries`}</li>\n      <li parentName=\"ul\">{`Race condition still happening, but bad attempts may be increasing the timeout - Could also use a current id compared to next query id and then returning before the callback occurs`}</li>\n      <li parentName=\"ul\">{`A lot of state across the module being changed`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`The Rx way`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// npm install rxjs-es for es6\nimport $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nconst keyUps$ = Rx.Observable.fromEvent($title, \"keyup\");\nconst queries$ = keyUps$\n    .map(e => e.target.value)\n    .distinctUntilChanged()\n    .debounceTime(250)\n    .switchMap(getItems);   // similar to merge, but if new query comes in, discard the old data\n    //.mergeMap(getItems);  // alias for flatMap\n\nqueries$.subscribe(query => {\n    // get rid of the promise will stop race condition\n    $results.empty();\n    $results.append(items.map( r => $(\\`<li />\\`).text(r)));\n})\n\n<!-- queries$.subscribe(query => {\n    console.log(e); // prints out event\n    getItems(query)\n        .then(items => {\n            $results.empty();\n            $results.append(items.map( r => $(\\`<li />\\`).text(r)));\n        });\n}) -->\n`}</code></pre>\n    <p>{`An even better way.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nRx.Observable.fromEvent($title, 'keyup')\n  .map((e) => e.target.value)\n  .distinctUntilChanged()\n  .debounceTime(500)\n  .switchMap(getItems)\n  .subscribe((items) => {\n    $results.empty();\n    $results.append(items.map((r) => $(\\`<li />\\`).text(r)));\n  });\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`All the Rx has no external state, whereas the other code does.`}</li>\n      <li parentName=\"ul\">{`Rx doesn't have to wait for us to tell it when to do it.`}</li>\n    </ul>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"3-the-core-of-reactive-extensions\"\n    }}>{`3: The Core of Reactive Extensions`}</h2>\n    <h2 {...{\n      \"id\": \"31-obervables-operators-and-subscriptions\"\n    }}>{`3.1: Obervables, Operators and Subscriptions`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Observable: Something that can be observed which produces values`}</li>\n      <li parentName=\"ul\">{`Operator: It's an operation that modifies the data being pushed in from the observable - They don't produce values in and of themselves, but move them through the pipeline.`}</li>\n      <li parentName=\"ul\">{`Subscriptions: Piece of code that will do something with the values returned by the operators`}</li>\n    </ul>\n    <p>{`Note, you can model anything in a reactive context by thinking a little bit differently.`}</p>\n    <p><strong parentName=\"p\">{`Web API Request Example`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`Reactive can still complete, or it can error out and retry.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"32-creating-observables\"\n    }}>{`3.2 Creating Observables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Rx from 'rxjs/Rx';\n\n# promise will always execute - not lazy\nconst promise = new Promise((resolve, reject) => {\n    console.log(\"In promise\");\n    resolve(\"hey\");\n});\n\npromise.then(item => console.log(item));\n\n# this doesn't give any output!\n# observables are lazy!\n# won't run without a subscription\nconst simple$ = new Rx.Observable(observer => {\n    console.log(\"Generating observable\");\n    setTimeout(() => {\n        observer.next(\"An items!\");\n        setTimeout(() => {\n            observer.next(\"Another item!\");\n            observer.complete();\n        }, 1000);\n    }, 1000);\n});\n\n# creating a subscription\n# first arg is the next function\n# second arg is error\n# third arg is complete\nsimple$.subscribe(\n    item => console.log(\\`one.next \\${item}\\`),\n    error => console.log(\\`one.error \\${item}\\`),\n    () => console.log(\"one.complete\")\n);\n\n# Generating observable\n# one.next An item!\n# one.next Another item!\n# one.complete\n\nsetTimeout(() => {\n    simple$.subscribe({\n        next: item => console.log(\\`two.next \\${item}\\`),\n        error: error => console.log(\\`two.error \\${item}\\`),\n        complete: () => console.log(\"two.complete\")\n    });\n}, 3000)\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`Re-subscribing to an observable allows you to run that generator again`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`function createInterval(time) {\n    return new Rx.Observable(observer => {\n        let index = 0;\n        let interval = setInterval(() => {\n            observer.next(index++);\n        }, time);\n\n        return () => {\n            // will run when we unsubscribe\n            clearnInterval(interval);\n        };\n    });\n}\n\nfunction createSubscriber(tag) {\n    return {\n        next(item) { console.log(\\`\\${tag}.next \\${item}\\`); },\n        error(error) { console.log(\\`\\${tag}.error \\${error.stack || error }\\`); },\n        complete() { console.log(\\`\\${tag}.complete\\`); }\n    };\n}\n\nfunction take(observable, amount) {\n    return new Rx.Observable(observer => {\n\n    });\n}\n\n// this is the core of subscriptions\nfunction take(sourceObservable, amount) {\n    return new Rx.Observable(observer => {\n        let count = 0;\n        const subscription = sourceObservable.subscribe({\n            next(item) {\n                observer.next(item);\n                if (++count >= amount) {\n                    observer.complete();\n                }\n            },\n            error(error) { observer.error(error); },\n            complete() { observer.complete(); }\n        });\n\n        return () => subscription.unsubscribe();\n    });\n}\n\nconst everySecond_ = createInterval(1000);\nconst firstFiveSeconds = take(everySecond_, 5);\nconst subscription = everySecond_.subscribe(createSubscriber(\"one\"));\nsetTimeout(() => {\n    subscription.unsubscribe();\n}, 3500);\n`}</code></pre>\n    <p>{`This subscription will console.log out forever and ever and ever... - unless, we dispose of a description`}</p>\n    <p>{`How do operators come into play?`}</p>\n    <p>{`We could run something like `}<inlineCode parentName=\"p\">{`const subscription = everySecond_.take(3)subscribe(createSubscriber(\"one\"));`}</inlineCode></p>\n    <p>{`The steps for it are that it listens for a source and emits a transformation!`}</p>\n    <h2 {...{\n      \"id\": \"33-built-in-observables\"\n    }}>{`3.3: Built in Observables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Rx from 'rxjs/Rx';\n\n\nRx.Observable.interval(500)\n    .take(5)\n    .subscribe(createSubscriber(\"interval\"));\n\nRx.Observable.timer(1000, 500)\n    .take(3)\n    .subscribe(createSubscriber(\"timer\");\n\n// note, array doesn't work - use from\nRx.Observable.of(\"Hello world!\", 42, \"whoa\")\n    .subscribe(createSubscriber(\"of\"));\n\nRx.Observable.from([\"Hello world!\", 42, \"whoa\"])\n    .subscribe(createSubscriber(\"of\"));\n\nRx.Observable.from(generate())\n    .subscribe(createSubscriber(\"of\"));\n\n\nRx.Observable.from(\"hello world!\")\n    .subscribe(createSubscriber(\"of\"));\n\n// it can also take in a generator function!\n\nfunction* generate() {\n    yield 1;\n    yield 5;\n    yield \"HEY\";\n}\n\nRx.Observable.throw(new Error(\"Hey\"))\n    .subscribe(createSubscriber(\"error\"));\n\n// empty\nRx.Observable.empty()\n    .subscribe(createSubscriber(\"empty\"));\n\n// defer\nlet sideEffect = 0;\nconst defer = Rx.Observable.defer(() => {\n    sideEffect++;\n    return Rx.Obserable.of(sideEffect);\n});\n\ndefer.subscribe(createSubscriber(\"defer.one\"));\ndefer.subscribe(createSubscriber(\"defer.two\"));\ndefer.subscribe(createSubscriber(\"defer.three\"));\n\nRx.Observable.never()\n    .subscribe(createSubscriber(\"never\"));\n\nRx.Observable.range(10, 30)\n    .subscribe(createSubscriber(\"range\"));\n`}</code></pre>\n    <p>{`Benefits of the iterable `}<inlineCode parentName=\"p\">{`from`}</inlineCode>{`?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`For every iterable, we could map every element.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"34-using-rxjs-with-node-jquery-and-promises\"\n    }}>{`3.4: Using RxJS with Node, jQuery and Promises`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`Rx.Observable.fromEvent($title, 'keyup')\n  .map((e) => e.target.value)\n  .distinctUntilChanged()\n  .debounceTime(500)\n  .switchMap(getItems)\n  .subscribe((items) => {\n    $results.empty();\n    $results.append(items.map((i) => $('<li />').text(i)));\n  });\n`}</code></pre>\n    <p>{`NOTE: Without the subscribe, it will never be subscribed to the dom!`}</p>\n    <p>{`If we have the `}<inlineCode parentName=\"p\">{`.take(10)`}</inlineCode>{` - it would complete after taking 10 and then furthermore unsubscribe and be great for performance!`}</p>\n    <p><inlineCode parentName=\"p\">{`fromEvent`}</inlineCode>{` calls from `}<inlineCode parentName=\"p\">{`addEventListener`}</inlineCode>{`, so it can do powerful things like `}<inlineCode parentName=\"p\">{`keyup`}</inlineCode>{` for those that don't initially support it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import fs from 'fs';\n\nfs.readdir('./src/server', (err, items) => {\n  if (err) console.log(err);\n  else {\n    console.log(items);\n  }\n});\n\n// alternative\nconst readdir = Rx.Observable.bindNodeCallBack(fs.readdir);\n\nreaddir('./src/server')\n  // mergeMap creates iterable converted from array\n  .mergeMap((files) => Rx.Observable.from(files))\n  .map((file) => \\`MANIPULATED \\${file}\\`)\n  .subscribe(createSubscriber('readdir'));\n\n// promises\n\nfunction getItem() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('Hello');\n    }, 1000);\n  });\n}\n\nRx.Observable.fromPromise(getItem()).subscribe(createSubscriber('promise'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"35-subjects\"\n    }}>{`3.5: Subjects`}</h2>\n    <p>{`Subjects are another Rx primitive. They are both an observable and a observer! Used to bridge non-reactive code with reactive code.`}</p>\n    <p>{`Behaviour, replay subjects etc.`}</p>\n    <p><em parentName=\"p\">{`Warning`}</em>{`: you should only really consider them as a last resort when bridging non-reactive and reactive code.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const simple = new Rx.Subject();\n\nsimple.subscribe(createSubscriber('simple'));\n\nsimple.next('Hello');\nsimple.next('World');\nsimple.complete();\n\nconst interval = Rx.Observable.interval(1000).take(5);\nconst intervalSubject = new Rx.Subject();\nintervalSubject.subscribe(interval);\n\nintervalSubject.subscribe(createSubscriber('sub1'));\nintervalSubject.subscribe(createSubscriber('sub2'));\nintervalSubject.subscribe(createSubscriber('sub3'));\n\n// subscribes after three seconds\nsetTimeout(() => {\n  intervalSubject.subscribe(createSubscriber('LOOK AT ME'));\n}, 3000);\n`}</code></pre>\n    <p>{`Before, we had to invoke a function that call `}<inlineCode parentName=\"p\">{`next`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`complete`}</inlineCode>{`.`}</p>\n    <p>{`In the above example, intervalSubject is acting as a proxy to another observable.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// needs init state parameter\nconst currentUser = new Rx.BehaviorSubject({ isLoggedIn: false });\nconst isLoggedIn = currentUser.map((u) => u.isLoggedIn);\n\ncurrentUser.next({ isLoggedIn: false });\nisLoggedIn.subscribe(createSubscriber('isLoggedIn'));\n\nsetTimeout(() => {\n  currentUser.next({ isLoggedIn: true, name: 'nelson' });\n}, 3000);\n\nsetTimeout(() => {\n  isLogged.subscribe(createSubscription('delayed'));\n}, 1500);\n`}</code></pre>\n    <p>{`How do you remember multiple states?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const replay = new Rx.ReplaySubject(3);\nreplay.next(1);\nreplay.next(2);\n\nreplay.subscribe(createSubscriber(\"one\"));\n\nreplay.next(3);\nreplay.next(4);\nreplay.next(5);\n\n// this subscription only gets the previous three items\nreplay.subscribe(createSubscriber(\"two\"));\n\nreplay.next(6);\n\n// what you see\none.next 1\none.next 2\none.next 3\none.next 4\none.next 5\ntwo.next 3\ntwo.next 4\ntwo.next 5\none.next 6\ntwo.next 6\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Async Subjects`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`const apiCall = new Rx.AsyncSubject();\napiCall.next(1);\n\napiCall.subscribe(createSubscriber(\"one\"));\napiCall.next(2);\n\n// only will emit the final item before it is complete\napiCall.complete();\n\n// if you subscribe to it again, that final value will be emitted\nsetTimeout(() => {\n    apiCall.subscribe(createSubscriber(\"two\"));\n}, 2000);\n\n// output\none.next 2\none.complete\ntwo.next 2\ntwo.complete\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Subject Summary`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`if you can get around it, don't use subjects unless you have to`}</li>\n      <li parentName=\"ul\">{`you should use an observable workflow where possible`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"36-rxjs-resources-and-documentation\"\n    }}>{`3.6: RxJS Resources and Documentation`}</h2>\n    <p>{`Sources:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/ReactiveX/rxjs\"\n        }}>{`RxJS Github`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"http://rxmarbles.com/\"\n        }}>{`RxMarbles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"http://jaredforsyth.com/rxvision/examples/playground/\"\n        }}>{`RxVision Playground`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"37-sharing-observable-sequences\"\n    }}>{`3.7: Sharing Observable Sequences`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Hot Observable: It will produce events regardless of if you're listening - eg.`}<inlineCode parentName=\"li\">{`fromEvent($title, 'keyup')`}</inlineCode></li>\n      <li parentName=\"ul\">{`Cold Obserable: Starts once you subscribe - Interval Observables are actually cold observables`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// this example shows when both start from the beginning eg cold\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000).take(10);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// HOT\n// connectable observable\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000)\n  .take(10)\n  .publish();\n\ninterval.connect();\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// if you connect after a set interval, then it begins executing and sharing the underlying observable\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Why would you want a hot variable?`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// here subscribe console.log runs twice\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n  console.log('subscribed');\n  socket.on('chat:message', (message) => observer.next(message));\n});\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// without it\n\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n  console.log('subscribed');\n  socket.on('chat:message', (message) => observer.next(message));\n}).publish();\n\nchatMessage.connect();\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// using publishLast()\nconst simple = new Rx.Observable((observer) => {\n  observer.next('one');\n  observer.next('two');\n  observer.complete();\n});\n\n// always returns the last value\nconst published = simple.publishLast();\n\n// even if we subscribe before connect, both will get the last value\npublished.subscribe(createSubscriber('one'));\npublished.connect();\npublished.subscribe(creaSubscriber('two'));\n\n// using publishReplay()\nconst simple = new Rx.Observable((observer) => {\n  observer.next('one');\n  observer.next('two');\n  observer.next('three');\n\n  return () => console.log('Disposed');\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2);\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber('one'));\nconst connection = published.connect();\nconst sub2 = published.subscribe(creaSubscriber('two'));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n\nconnection.unsubscribe();\n`}</code></pre>\n    <p>{`Refcount is a way to automatically handle the connection and the unsubscription of a connection observable.`}</p>\n    <p>{`It will connect to the first subscription and then disconnected on the last unsubscribe.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`// using refCount()\nconst simple = new Rx.Observable(observer => {\n    observer.next(\"one\");\n    observer.next(\"two\");\n    observer.next(\"three\");\n\n    return () => console.log(\"Disposed\");\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2).refCount();\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber(\"one\"));\nconst sub2 = published.subscribe(creaSubscriber(\"two\"));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`publish().refCount()`}</inlineCode>{` is done so often, that is has been turned in `}<inlineCode parentName=\"p\">{`share()`}</inlineCode>{`.`}</p>\n    <p>{`Taxing processes that you don't want to repeat but you want multiple things to hook into the result, then turn it into a hot subscription.`}</p>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"40-operators-that-everyone-should-know\"\n    }}>{`4.0: Operators that everyone should know`}</h2>\n    <p>{`Now we will just talk about the different primary operators that you will work with.`}</p>\n    <h2 {...{\n      \"id\": \"41-do--finally--startwith--filter\"\n    }}>{`4.1: Do / Finally / StartWith / Filter`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// do => get the next value and pass it back unchanged\n// finally => only completes after the range has completed, runs right at the end of the final value\n// filter => filters out given statement\n// interval => call timeout\n// startWith => set initial value\n\nRx.Observable.range(1, 10)\n  .do((a) => console.log(\\`From do \\${a}\\`))\n  .map((a) => a * a)\n  .subscribe(createSubscriber('simple'));\n\nRx.Observable.range(1, 10)\n  .finally(() => console.log(\\`From finally\\`))\n  .map((a) => a * 2)\n  .subscribe(createSubscriber('finally'));\n\nRx.Observable.range(1, 10)\n  .filter((a) => a < 5)\n  .map((a) => a * 2)\n  .subscribe(createSubscriber('filter'));\n\nRx.Observable.interval(1000)\n  .startWith(-1)\n  .subscribe(createSubscriber('interval'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"42-merge--concat\"\n    }}>{`4.2: Merge / Concat`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// merge - merge many observables togethers\n// concat - this concatenates observables to the end of another, can also take a list of Observables\n\nRx.Observable.interval(1000)\n    .merge(Rx.Observable.interval(500))\n    .take(5)\n    .subscribe(createSubscriber(\"merge1\"));\n\nRx.Observable.merge(\n    Rx.Observable.interval(1000).map(i => \\`\\${i} seconds),\n    Rx.Observable.interval(500).map(i => \\`\\${i} half seconds))\n    .take(5)\n    .subscribe(createSubscriber('merge2'));\n\n// different events for merged observables\nRx.Observable.merge(\n    socket.on$(\"login\").map(user => processUser(user),\n    socket.on$(\"logout\").map(() => null));\n\nRx.Observable.range(1, 5)\n    .concat(Rx.Observable.range(10,3))\n    .subscribe(createSubscriber(\"concat1\"));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"43-map--mergemap--switchmap\"\n    }}>{`4.3: Map / MergeMap / SwitchMap`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// map - a projection on every item that comes in\n// mergeMap - select many, does projection and then has another thing that we will work on\n// switchMap - similar to mergeMap but replaces with the latest value if another emission comes in\n\nfunction arrayMap(arr, proj) {\n  let returnArray = [];\n  for (let i of arr) {\n    returnArray.push(proj(item));\n  }\n\n  return returnArray;\n}\n\narrayMap([1, 2, 3], (a) => a * a);\n\n// imagine array of dicts\nconst albums = [{}, {}];\n\nfunction arrayMergeMap(arr, proj) {\n  let returnArray = [];\n  for (let i of arr) {\n    let projArray = proj(item);\n    for (let j of projArray) {\n      returnArray.push(proj(item));\n    }\n  }\n\n  return returnArray;\n}\n\nconst tracks = arrayMergeMap(albums, (album) => album.tracks);\n\nRx.Observable.range(1, 3)\n  .mergeMap((i) =>\n    Rx.Observable.timer(i * 1000).map(() => \\`After \\${i} seconds\\`)\n  )\n  .subscribe(createSubscriber('mergeMap'));\n\nRx.Observable.fromPromise(getTracks())\n  .mergeMap((tracks) => Rx.Observable.from(tracks))\n  .subscribe(createSubscriber('tracks'));\n\nfunction getTracks() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(['track 1', 'track 2', 'track 3']);\n    }, 1000);\n  });\n}\n\n// synchronous example\nRx.Observable.of('my query')\n  .do(() => console.log('Querying'))\n  .mergeMap((a) => query(a))\n  .do(() => console.log('After querying'))\n  .subscribe(createSubscriber('query'));\n\nfunction query(value) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('This is the resolved value');\n    }, 1000);\n  });\n}\n\n// switch map\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"44-reduce--scan\"\n    }}>{`4.4: Reduce / Scan`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// reducer (acc, value) and works on value - doesn't emit until the completion\n// scan - processes and emits as it comes in\nRx.Observable.range(1, 10)\n  .reduce((acc, value) => acc + value)\n  .subscribe(createSubscriber('reduce'));\n\nRx.Observable.range(1, 10)\n  .scan((acc, value) => acc + value)\n  .subscribe(createSubscriber('scan'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"45-buffer--toarray\"\n    }}>{`4.5: Buffer / ToArray`}</h2>\n    <p>{`There have been some big changes to how `}<inlineCode parentName=\"p\">{`buffer`}</inlineCode>{` has been used.`}</p>\n    <p>{`Buffer takes in an observable.`}</p>\n    <p>{`toArray will convert results into an array. - still has a clean exit if the never() is implemented!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`Rx.Observable.range(1, 100)\n    .bufferCount(25)\n    .subscribe(createSubscriber(\"items\");\n\n// will take 25 items and pushing them into an array\n\n\nRx.Observable.interval(500)\n    .bufferTime(2000)\n    .subscribe(createSubscriber(\"bufferTime\");\n\n// same behaviour!\n// emitting event causes buffer to flush\nRx.Observable.interval(500)\n    .buffer(Rx.Observable.interval(2000))\n    .subscribe(createSubscriber(\"buffer\");\n\n//\n// toArray\n//\n\nRx.Observable.range(1, 10)\n    .toArray()\n    .subscribe(createSubscriber(\"range\"));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"46-first--last--single--skip--take\"\n    }}>{`4.6: First / Last / Single / Skip / Take`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const simple = new Rx.Observable((observer) => {\n  console.log('Generating sequence');\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.next(4);\n  observer.complete();\n});\n\nsimple.first().subscribe(createSubscriber('first'));\n\nsimple.last().subscribe(createSubscriber('last'));\n\n// displays 1 & 4\n// if nothing is in there, there are EmptyError(s) thrown\n\n// single.error thrown is more than one error thrown\nsimple.single().subscribe(createSubscriber('single'));\n\n// take and skip won't throw errors\n// take does the first however emissions\n// skip will take the emissions after a number\nsimple.take(2).subscribe(createSubscriber('take'));\n\nsimple.skip(2).subscribe(createSubscriber('skip'));\n\n// 3, 4\nsimple\n  .skip(2)\n  .take(2)\n  .subscribe(createSubscriber('skip'));\n\n// skipWhile / takeWhile\nRx.Observable.interval(500)\n  .skipWhile((i) => i < 4)\n  .takeWhile((i) => i < 10)\n  .subscribe(createSubscriber('skipWhile/takeWhile'));\n\n// what's until and take emissions until\nRx.Observable.interval(500)\n  .skipUntil(Rx.Observable.timer(1000))\n  .takeUntil(Rx.Observable.timer(4000))\n  .subscribe(createSubscriber('skipUntil'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"47-zip--withlatestfrom--combinelatest\"\n    }}>{`4.7: Zip / WithLatestFrom / CombineLatest`}</h2>\n    <p>{`How can we combine observables in different ways?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function arrayZip(arr1, arr2, selectorFunc) {\n  const count = Math.min(arr1.length, arr2.length);\n  const results = [];\n\n  for (let i = 0; i < count; i++) {\n    const combined = selector(arr1[i], arr2[i]);\n    results.push(combined);\n  }\n\n  return results;\n}\n\nconst arr1 = [32, 2, 52, 43, 54];\nconst arr2 = [1, 0, 10, 4, 1, 4, 6, 2];\nconst results = arrayZip(arr1, arr2, (left, right) => left * right);\n\nconsole.log(results);\n\n// in RxJS\nRx.Observable.range(1.1)\n  .zip(\n    Rx.Observable.interval(500),\n    (left, right) => \\`item: \\${left}, at \\${right * 500}\\`\n  )\n  .subscribe(createSubscriber('zip'));\n\n// emits value when source emits\n// can also pass (left, right) function like zip as second parameter\nRx.Observable.interval(1000)\n  .withLatestFrom(Rx.Observable.interval(500))\n  .subscribe(createSubscriber('withLatestFrom'));\n\n// emit value if either do\nRx.Observable.interval(1000)\n  .combineLatest(Rx.Observable.interval(500))\n  .subscribe(createSubscriber('withLatestFrom'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"48-error-handling-catch-and-retry\"\n    }}>{`4.8: Error Handling Catch and Retry`}</h2>\n    <p>{`If an error happens, an observer stops emitting and can prevent values from emitting at all. Error handling is very important!`}</p>\n    <p><inlineCode parentName=\"p\">{`.catch(error => Rx.Observable.of(error))`}</inlineCode>{` can pass this down as an Observable.`}</p>\n    <p><inlineCode parentName=\"p\">{`.retry()`}</inlineCode>{` we can pass in with a numeral to ensure that we either keep retrying or retry a certain number of times.`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}