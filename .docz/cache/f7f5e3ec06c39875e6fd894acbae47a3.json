{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md","mtime":1562563032045},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1581496618588},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1578565694890},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1581496618277},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1580255490569}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbm9kZV9tb2R1bGVzL2JhYmVsLXByZXNldC1yZWFjdC1hcHAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIjsKdmFyIF9qc3hGaWxlTmFtZSA9ICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbWFudWFsL0phdmFTY3JpcHQvSlMtRDMtVWRlbXkubWQiOwoKKGZ1bmN0aW9uICgpIHsKICB2YXIgZW50ZXJNb2R1bGUgPSAodHlwZW9mIHJlYWN0SG90TG9hZGVyR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IHJlYWN0SG90TG9hZGVyR2xvYmFsIDogcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpKS5lbnRlck1vZHVsZTsKICBlbnRlck1vZHVsZSAmJiBlbnRlck1vZHVsZShtb2R1bGUpOwp9KSgpOwoKdmFyIF9fc2lnbmF0dXJlX18gPSB0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWxbImRlZmF1bHQiXS5zaWduYXR1cmUgOiBmdW5jdGlvbiAoYSkgewogIHJldHVybiBhOwp9OwoKLyogQGpzeCBtZHggKi8KaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JzsKaW1wb3J0IHsgbWR4IH0gZnJvbSAnQG1keC1qcy9yZWFjdCc7Ci8qIEBqc3ggbWR4ICovCgp2YXIgbWFrZVNob3J0Y29kZSA9IGZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSkgewogIHJldHVybiBmdW5jdGlvbiBNRFhEZWZhdWx0U2hvcnRjb2RlKHByb3BzKSB7CiAgICBjb25zb2xlLndhcm4oIkNvbXBvbmVudCAiICsgbmFtZSArICIgd2FzIG5vdCBpbXBvcnRlZCwgZXhwb3J0ZWQsIG9yIHByb3ZpZGVkIGJ5IE1EWFByb3ZpZGVyIGFzIGdsb2JhbCBzY29wZSIpOwogICAgcmV0dXJuIG1keCgiZGl2IiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsKICAgICAgX19zb3VyY2U6IHsKICAgICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICAgIGxpbmVOdW1iZXI6IDkKICAgICAgfSwKICAgICAgX19zZWxmOiB0aGlzCiAgICB9KSk7CiAgfTsKfTsKCnZhciBsYXlvdXRQcm9wcyA9IHt9Owp2YXIgTURYTGF5b3V0ID0gIndyYXBwZXIiOwpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KF9yZWYpIHsKICB2YXIgY29tcG9uZW50cyA9IF9yZWYuY29tcG9uZW50cywKICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyJjb21wb25lbnRzIl0pOwoKICByZXR1cm4gbWR4KE1EWExheW91dCwgT2JqZWN0LmFzc2lnbih7fSwgbGF5b3V0UHJvcHMsIHByb3BzLCB7CiAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLAogICAgbWR4VHlwZTogIk1EWExheW91dCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAicmVhZGluZy10aGUtZDMtZG9jdW1lbnRhdGlvbiIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiUmVhZGluZyB0aGUgRDMgRG9jdW1lbnRhdGlvbiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiLSBbUmVhZGluZyB0aGUgRDMgRG9jdW1lbnRhdGlvbl0oI3JlYWRpbmctdGhlLWQzLWRvY3VtZW50YXRpb24pXG4tIFttYXAoKSBhbmQgZmlsdGVyKCkgbWV0aG9kc10oI21hcC1hbmQtZmlsdGVyLW1ldGhvZHMpXG4tIFtkMyBtZXRob2RzXSgjZDMtbWV0aG9kcylcbi0gW1Byb2dyYW1tYXRpYyBTVkdzXSgjcHJvZ3JhbW1hdGljLXN2Z3MpXG4tIFtTY2FsaW5nIERhdGFdKCNzY2FsaW5nLWRhdGEpXG4tIFtTdHlsaW5nIHdpdGggQ1NTXSgjc3R5bGluZy13aXRoLWNzcylcbi0gW0FkZGluZyBUZXh0IHRvIHRoZSBjaGFydF0oI2FkZGluZy10ZXh0LXRvLXRoZS1jaGFydClcbi0gW1VzaW5nIFNWRyBncm91cHNdKCN1c2luZy1zdmctZ3JvdXBzKVxuIikpLCBtZHgoInVsIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJhIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAibGkiCiAgfSwgewogICAgImhyZWYiOiAiI3NlY3Rpb24tNC1tYWtpbmctYS1jb21wbGV4LWNoYXJ0IgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJTZWN0aW9uIDQ6IE1ha2luZyBhIENvbXBsZXggQ2hhcnQiKSwgbWR4KCJ1bCIsIHsKICAgIHBhcmVudE5hbWU6ICJsaSIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzOQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDAKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImEiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJsaSIKICB9LCB7CiAgICAiaHJlZiI6ICIjd29ya2luZy13aXRoLWFycmF5cy1vZi1vYmplY3RzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDQwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJXb3JraW5nIHdpdGggQXJyYXlzIG9mIE9iamVjdHMiKSksIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDMKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImEiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJsaSIKICB9LCB7CiAgICAiaHJlZiI6ICIjY3JlYXRpbmctYW4tb3JkaW5hbC1zY2FsZSIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0MwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiQ3JlYXRpbmcgYW4gT3JkaW5hbCBTY2FsZSIpKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiYSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogImxpIgogIH0sIHsKICAgICJocmVmIjogIiNzZXR0aW5nLWNvbG91ci13aXRoLWNvbG91ci1zY2FsZXMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlNldHRpbmcgY29sb3VyIHdpdGggY29sb3VyIHNjYWxlcyIpKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0OQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiYSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogImxpIgogIH0sIHsKICAgICJocmVmIjogIiNhZGRpbmcteC1hbmQteS1heGlzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDQ5CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJBZGRpbmcgWCBhbmQgWSBheGlzIikpLCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDUyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJhIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAibGkiCiAgfSwgewogICAgImhyZWYiOiAiI2ZsaXBwaW5nLXRoZS1heGVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDUyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJGbGlwcGluZyB0aGUgYXhlcyIpKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA1NQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiYSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogImxpIgogIH0sIHsKICAgICJocmVmIjogIiNhZGRpbmctZ3JpZGxpbmVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDU1CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJBZGRpbmcgR3JpZGxpbmVzIikpLCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDU4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJhIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAibGkiCiAgfSwgewogICAgImhyZWYiOiAiI3JvdGF0aW5nLXRoZS14LWF4aXMtdGl0bGVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDU4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJSb3RhdGluZyB0aGUgWCBheGlzIHRpdGxlcyIpKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA2MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiYSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogImxpIgogIH0sIHsKICAgICJocmVmIjogIiNhZGRpbmctYXhpcy1sYWJlbHMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNjEKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIkFkZGluZyBheGlzIGxhYmVscyIpKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA2NAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiYSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogImxpIgogIH0sIHsKICAgICJocmVmIjogIiN1cGRhdGluZy10aGUtcGxvdC1mdW5jdGlvbi13aXRoLWJlc3QtcHJhY3Rpc2VzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDY0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJVcGRhdGluZyB0aGUgcGxvdCBmdW5jdGlvbiB3aXRoIGJlc3QgcHJhY3Rpc2VzIikpKSksIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNjgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImEiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJsaSIKICB9LCB7CiAgICAiaHJlZiI6ICIjc2Vjb250aW9uLTUtbWFraW5nLXRoZS1jaGFydC1pbnRlcmFjdGl2ZSIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA2OAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiU2Vjb250aW9uIDU6IE1ha2luZyB0aGUgQ2hhcnQgSW50ZXJhY3RpdmUiKSkpLCBtZHgoInVsIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNzUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDc2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkFQSSBEb2N1bWVudGF0aW9uIGlzIGEgZ3JlYXQgbGluayB0byBib29rbWFyayIpKSwgbWR4KCJociIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDc4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJtYXAtYW5kLWZpbHRlci1tZXRob2RzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDc5CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJtYXAoKSBhbmQgZmlsdGVyKCkgbWV0aG9kcyIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDgyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHsKICAgICJjbGFzc05hbWUiOiAibGFuZ3VhZ2UtamF2YXNjcmlwdCIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAidmFyIGRhdGEgPSBbMTIzLCA1MiwgNDYsIDMwLCA0XTtcblxuY29uc3QgcmVzdWx0cyA9IGRhdGEuZmlsdGVyKChlbnRyeSkgPT4ge1xuICAgIHJldHVybiBlbnRyeSA+IDUwO1xufSk7XG5cbmNvbnN0IG1hcHBpbmcgPSBkYXRhLm1hcCgoZW50cnkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhlbnRyeS5rZXkpO1xuICAgIGNvbnNvbGUubG9nKGVudHJ5LnZhbHVlKTtcbn0pO1xuIikpLCBtZHgoImhyIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogImQzLW1ldGhvZHMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgImQzIG1ldGhvZHMiKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5OQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgImNvbnN0IGV4YW1wbGUgPSBkMy5taW4oZGF0YSk7XG5jb25zb2xlLmxvZyhleGFtcGxlKTsgICAgICAgLy8gdmFsdWVzIHJldHVybmVkXG5cbmNvbnN0IGRhdGFMb0hpVmFsdWUgPSBkMy5leHRlbnQoZGF0YSk7ICAvLyByZXR1cm4gbWluL21heCBhcyBhcnJheVxuXG52YXIgZGljdE1pblZhbHVlID0gZDMubWluKGRvdW50cywgKGQsIGkpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbn0pO1xuIikpLCBtZHgoImhyIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTA4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJwcm9ncmFtbWF0aWMtc3ZncyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxMDkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlByb2dyYW1tYXRpYyBTVkdzIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTEyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHsKICAgICJjbGFzc05hbWUiOiAibGFuZ3VhZ2UtamF2YXNjcmlwdCIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxMTIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgInZhciBkYXRhID0gWzEzMiw3MSwzMzcsOTMsNzgsNDMsMjAsMTYsMzAsOCwxNywyMV07XG5sZXQgc3ZnID0gZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdjaGFydCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDQ1MClcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCA4MDApO1xuXG4vLyBjcmVhdGluZyB0aGUgYmFyc1xuLy8gdmVydGljYWwgYmFyIGdyYXBoXG5zdmcuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAuZGF0YShkYXRhKVxuICAgIC5lbnRlcigpICAgICAgICAgICAgICAgIC8vIGVudGVyIHBoYXNlXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpICAgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgLmF0dHIoJ3gnLCAwKVxuICAgIC5hdHRyKCd5JywgKGQgaSkgPT4ge1xuICAgICAgICByZXR1cm4gaSAqIDIwO1xuICAgIH0pXG4gICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfSlcbiAgICAuYXR0cignaGVpZ2h0JywgMTkpO1xuIikpLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAic2NhbGluZy1kYXRhIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDEzNgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiU2NhbGluZyBEYXRhIiksIG1keCgidWwiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxMzkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE0MAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJDcmVhdGluZyBzY2FsaW5nIGZ1bmN0aW9ucyBmb3IgYm90aCB4IGFuZCB5LiIpKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxNDIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwgewogICAgImNsYXNzTmFtZSI6ICJsYW5ndWFnZS1qYXZhc2NyaXB0IgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE0MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAidmFyIGRhdGEgPSBbMTMyLCA3MSwgMzM3LCA5MywgNzgsIDQzLCAyMCwgMTYsIDMwLCA4LCAxNywgMjFdO1xubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCB4ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSldKVxuICAgIC5yYW5nZShbMCwgd10pO1xubGV0IHkgPSBkMy5zY2FsZVxuICAgIC5saW5lYXIoKVxuICAgIC5kb21haW4oWzAsIGRhdGEubGVuZ3RoXSlcbiAgICAucmFuZ2UoWzAsIGhdKTtcblxubGV0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdCgnYm9keScpXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuYXR0cignaWQnLCAnY2hhcnQnKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuICAgIC5hdHRyKCd3aWR0aCcsIHcpO1xuXG4vLyBjcmVhdGluZyB0aGUgYmFyc1xuLy8gdmVydGljYWwgYmFyIGdyYXBoXG5zdmdcbiAgICAuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAuZGF0YShkYXRhKVxuICAgIC5lbnRlcigpIC8vIGVudGVyIHBoYXNlXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ2JhcicpIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgIC5hdHRyKCd4JywgMClcbiAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB5KGkpO1xuICAgIH0pXG4gICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHgoZCk7IC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgfSlcbiAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHkoMSkgLSAxO1xuICAgIH0pO1xuIikpLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAic3R5bGluZy13aXRoLWNzcyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxODIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlN0eWxpbmcgd2l0aCBDU1MiKSwgbWR4KCJ1bCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE4NQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTg2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkdldHRpbmcgcmlkIG9mIHRoZSBhbGlhc2luZyIpKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxODgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwgewogICAgImNsYXNzTmFtZSI6ICJsYW5ndWFnZS1jc3MiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTg4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICIuYmFyIHtcbiAgICBmaWxsOiBwdXJwbGU7XG59XG4iKSksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE5NAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJOb3QgdGhhdCAiLCBtZHgoImlubGluZUNvZGUiLCB7CiAgICBwYXJlbnROYW1lOiAicCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxOTQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiYXR0cignY2xhc3MnLCAnYmFyJykiKSwgIiB3aWxsIG1hbnVhbGx5IHJlc2V0IHRoZSBjbGFzcyB2YWx1ZSwgc28geW91IGNhbiBhbHNvIHVzZSAiLCBtZHgoImlubGluZUNvZGUiLCB7CiAgICBwYXJlbnROYW1lOiAicCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxOTQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiLmNsYXNzZWQoJ2JhcicsIHRydWUpIiksICIgLSB0cnVlIHRvIGFkZCB0aGUgY2xhc3MsIGZhbHNlIHRvIHJlbW92ZS4iKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogImFkZGluZy10ZXh0LXRvLXRoZS1jaGFydCIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxOTUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIkFkZGluZyBUZXh0IHRvIHRoZSBjaGFydCIpLCBtZHgoInVsIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTk4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxOTkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiQ3JlYXRpbmcgc2NhbGluZyBmdW5jdGlvbnMgZm9yIGJvdGggeCBhbmQgeS4iKSksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjAxCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHsKICAgICJjbGFzc05hbWUiOiAibGFuZ3VhZ2UtamF2YXNjcmlwdCIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMDEKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgInZhciBkYXRhID0gWzEzMiwgNzEsIDMzNywgOTMsIDc4LCA0MywgMjAsIDE2LCAzMCwgOCwgMTcsIDIxXTtcbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgeCA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEpXSlcbiAgICAucmFuZ2UoWzAsIHddKTtcbmxldCB5ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgLnJhbmdlKFswLCBoXSk7XG5cbmxldCBzdmcgPSBkM1xuICAgIC5zZWxlY3QoJ2JvZHknKVxuICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgLmF0dHIoJ2lkJywgJ2NoYXJ0JylcbiAgICAuYXR0cignaGVpZ2h0JywgaClcbiAgICAuYXR0cignd2lkdGgnLCB3KTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgLy8gZm9yIGZ1dHVyZSBzZWxlY3Rpb25zXG4gICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkKTsgLy8geCgpIGRvZXMgdGhlIHNjYWxpbmdcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAtIDE7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkKTsgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geSgxKSAvIDEuNSArIDI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG59XG5cbi8vIGZpcnN0IGFyZyB3aWxsIGJlIHdoYXQgaXMgcmVmZXJlbmNlZCBieSBcInRoaXNcIlxucGxvdC5jYWxsKHN2Zywge1xuICAgIGRhdGE6IGRhdGFcbn0pO1xuIikpLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAidXNpbmctc3ZnLWdyb3VwcyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNjYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlVzaW5nIFNWRyBncm91cHMiKSwgbWR4KCJ1bCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI2OQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjcwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIlNWRyBncm91cHMgYXJlIGxpa2UgYSBkaXYgdGhhdCBhcmUgYSBjb252ZW5pZW5jZSBlbGVtZW50IHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG1vdmVkIGFuZCBhZmZlY3RlZCB0b2dldGhlci4iKSksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjcyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHsKICAgICJjbGFzc05hbWUiOiAibGFuZ3VhZ2UtamF2YXNjcmlwdCIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNzIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgInZhciBkYXRhID0gWzEzMiwgNzEsIDMzNywgOTMsIDc4LCA0MywgMjAsIDE2LCAzMCwgOCwgMTcsIDIxXTtcbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgbWFyZ2luID0ge1xuICAgIHRvcDogMjAsXG4gICAgYm90dG9tOiAyMCxcbiAgICBsZWZ0OiAyMCxcbiAgICByaWdodDogMjBcbn07XG5cbnZhciB3aWR0aCA9IHcgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbnZhciBoZWlnaHQgPSBoIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbmxldCB4ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSldKVxuICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbmxldCB5ID0gZDMuc2NhbGVcbiAgICAubGluZWFyKClcbiAgICAuZG9tYWluKFswLCBkYXRhLmxlbmd0aF0pXG4gICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxubGV0IHN2ZyA9IGQzXG4gICAgLnNlbGVjdCgnYm9keScpXG4gICAgLmFwcGVuZCgnc3ZnJylcbiAgICAuYXR0cignaWQnLCAnY2hhcnQnKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoKVxuICAgIC5hdHRyKCd3aWR0aCcsIHcpO1xuXG5sZXQgY2hhcnQgPSBzdmdcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuY2xhc3NlZCgnZGlzcGxheScsIHRydWUpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMjAsIDIwKScpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpOyAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC0gMTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpOyAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC8gMS41ICsgMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbn1cblxuLy8gZmlyc3QgYXJnIHdpbGwgYmUgd2hhdCBpcyByZWZlcmVuY2VkIGJ5IFwidGhpc1wiXG5wbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhXG59KTtcbiIpKSwgbWR4KCJociIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM1MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCBtZHgoImgxIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAic2VjdGlvbi00LW1ha2luZy1hLWNvbXBsZXgtY2hhcnQiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzUzCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJTZWN0aW9uIDQ6IE1ha2luZyBhIENvbXBsZXggQ2hhcnQiKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogIndvcmtpbmctd2l0aC1hcnJheXMtb2Ytb2JqZWN0cyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzNTYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIldvcmtpbmcgd2l0aCBBcnJheXMgb2YgT2JqZWN0cyIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzNTkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiSWYgd29ya2luZyB3aXRoIGEgZGljdCwgd2UgbmVlZCBhbiBhY2Nlc3NvciBmdW5jdGlvbiEiKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzNjAKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwgewogICAgImNsYXNzTmFtZSI6ICJsYW5ndWFnZS1qYXZhc2NyaXB0IgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM2MAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAidmFyIGRhdGEgPSBbXG4gICAgeyBrZXk6ICdHbGF6ZWQnLCB2YWx1ZTogMTMyIH0sXG4gICAgeyBrZXk6ICdKZWxseScsIHZhbHVlOiA3MSB9LFxuICAgIHsga2V5OiAnSG9sZXMnLCB2YWx1ZTogMzM3IH0sXG4gICAgeyBrZXk6ICdTcHJpbmtsZXMnLCB2YWx1ZTogOTMgfSxcbiAgICB7IGtleTogJ0NydW1iJywgdmFsdWU6IDc4IH0sXG4gICAgeyBrZXk6ICdDaG9jb2xhdGUnLCB2YWx1ZTogNDMgfSxcbiAgICB7IGtleTogJ0NvY29udXQnLCB2YWx1ZTogMjAgfSxcbiAgICB7IGtleTogJ0NyZWFtJywgdmFsdWU6IDE2IH0sXG4gICAgeyBrZXk6ICdDcnVsbGVyJywgdmFsdWU6IDMwIH0sXG4gICAgeyBrZXk6ICdceEM5Y2xhaXInLCB2YWx1ZTogOCB9LFxuICAgIHsga2V5OiAnRnJpdHRlcicsIHZhbHVlOiAxNyB9LFxuICAgIHsga2V5OiAnQmVhcmNsYXcnLCB2YWx1ZTogMjEgfVxuXTtcblxubGV0IHcgPSA4MDA7XG5sZXQgaCA9IDQ1MDtcbmxldCBtYXJnaW4gPSB7XG4gICAgdG9wOiAyMCxcbiAgICBib3R0b206IDIwLFxuICAgIGxlZnQ6IDIwLFxuICAgIHJpZ2h0OiAyMFxufTtcblxudmFyIHdpZHRoID0gdyAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xudmFyIGhlaWdodCA9IGggLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxubGV0IHggPSBkMy5zY2FsZVxuICAgIC5saW5lYXIoKVxuICAgIC5kb21haW4oW1xuICAgICAgICAwLFxuICAgICAgICBkMy5tYXgoZGF0YSwgKGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KVxuICAgIF0pXG4gICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG5sZXQgeSA9IGQzLnNjYWxlXG4gICAgLmxpbmVhcigpXG4gICAgLmRvbWFpbihbMCwgZGF0YS5sZW5ndGhdKVxuICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbmxldCBzdmcgPSBkM1xuICAgIC5zZWxlY3QoJ2JvZHknKVxuICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgLmF0dHIoJ3dpZHRoJywgODAwKVxuICAgIC5hdHRyKCdoZWlnaHQnLCA0MjApXG4gICAgLmF0dHIoJ2lkJywgJ2NoYXJ0Jyk7XG5sZXQgY2hhcnQgPSBzdmdcbiAgICAuYXBwZW5kKCdnJylcbiAgICAuY2xhc3NlZCgnZGlzcGxheScsIHRydWUpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMjAsIDIwKScpO1xuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC0gMTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KDEpIC8gMS41ICsgMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KTtcbn1cblxucGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgZGF0YTogZGF0YVxufSk7XG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJjcmVhdGluZy1hbi1vcmRpbmFsLXNjYWxlIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDQ1OAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiQ3JlYXRpbmcgYW4gT3JkaW5hbCBTY2FsZSIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDQ2MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDYxCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJ2YXIgZGF0YSA9IFtcbiAgICB7a2V5OiBcIkdsYXplZFwiLCAgICAgdmFsdWU6IDEzMn0sXG4gICAge2tleTogXCJKZWxseVwiLCAgICAgIHZhbHVlOiA3MX0sXG4gICAge2tleTogXCJIb2xlc1wiLCAgICAgIHZhbHVlOiAzMzd9LFxuICAgIHtrZXk6IFwiU3ByaW5rbGVzXCIsICB2YWx1ZTogOTN9LFxuICAgIHtrZXk6IFwiQ3J1bWJcIiwgICAgICB2YWx1ZTogNzh9LFxuICAgIHtrZXk6IFwiQ2hvY29sYXRlXCIsICB2YWx1ZTogNDN9LFxuICAgIHtrZXk6IFwiQ29jb251dFwiLCAgICB2YWx1ZTogMjB9LFxuICAgIHtrZXk6IFwiQ3JlYW1cIiwgICAgICB2YWx1ZTogMTZ9LFxuICAgIHtrZXk6IFwiQ3J1bGxlclwiLCAgICB2YWx1ZTogMzB9LFxuICAgIHtrZXk6IFwiXHhDOWNsYWlyXCIsICAgICB2YWx1ZTogOH0sXG4gICAge2tleTogXCJGcml0dGVyXCIsICAgIHZhbHVlOiAxN30sXG4gICAge2tleTogXCJCZWFyY2xhd1wiLCAgIHZhbHVlOiAyMX1cbl07XG5cbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgbWFyZ2luID0ge1xuICAgIHRvcDogMjAsXG4gICAgYm90dG9tOiAyMCxcbiAgICBsZWZ0OiAyMCxcbiAgICByaWdodDogMjBcbn07XG5cbnZhciB3aWR0aCA9IHcgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbnZhciBoZWlnaHQgPSBoIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbmxldCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEsIChkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICB9KV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbnZhciB5ID0gZDMuc2NhbGUub3JkaW5hbCgpICAgICAgICAgIC8vIG5lZWQgZGlzdGluY3QgdmFsdWVzIGVnIGtleXNcbiAgICAgICAgLmRvbWFpbihkYXRhLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5rZXk7XG4gICAgICAgIH0pKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgaGVpZ2h0XSk7ICAgLy8gdXNlZCBmb3IgZGlzdGluY3QgdmFsdWVzXG5cbmxldCBzdmcgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCA4MDApXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgNDIwKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2NoYXJ0Jyk7XG5sZXQgY2hhcnQgPSBzdmcuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnZGlzcGxheScsIHRydWUpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDIwLCAyMCknKTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpICAgICAgICAgICAgICAgIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgICAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpIC0gMTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgICAgICAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKS8xLjUrMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KTtcbn1cblxucGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgZGF0YTogZGF0YVxufSk7XG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJzZXR0aW5nLWNvbG91ci13aXRoLWNvbG91ci1zY2FsZXMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNTUwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJTZXR0aW5nIGNvbG91ciB3aXRoIGNvbG91ciBzY2FsZXMiKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA1NTMKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDU1MwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAidmFyIGRhdGEgPSBbXG4gICAge2tleTogXCJHbGF6ZWRcIiwgICAgIHZhbHVlOiAxMzJ9LFxuICAgIHtrZXk6IFwiSmVsbHlcIiwgICAgICB2YWx1ZTogNzF9LFxuICAgIHtrZXk6IFwiSG9sZXNcIiwgICAgICB2YWx1ZTogMzM3fSxcbiAgICB7a2V5OiBcIlNwcmlua2xlc1wiLCAgdmFsdWU6IDkzfSxcbiAgICB7a2V5OiBcIkNydW1iXCIsICAgICAgdmFsdWU6IDc4fSxcbiAgICB7a2V5OiBcIkNob2NvbGF0ZVwiLCAgdmFsdWU6IDQzfSxcbiAgICB7a2V5OiBcIkNvY29udXRcIiwgICAgdmFsdWU6IDIwfSxcbiAgICB7a2V5OiBcIkNyZWFtXCIsICAgICAgdmFsdWU6IDE2fSxcbiAgICB7a2V5OiBcIkNydWxsZXJcIiwgICAgdmFsdWU6IDMwfSxcbiAgICB7a2V5OiBcIlx4QzljbGFpclwiLCAgICAgdmFsdWU6IDh9LFxuICAgIHtrZXk6IFwiRnJpdHRlclwiLCAgICB2YWx1ZTogMTd9LFxuICAgIHtrZXk6IFwiQmVhcmNsYXdcIiwgICB2YWx1ZTogMjF9XG5dO1xuXG5sZXQgdyA9IDgwMDtcbmxldCBoID0gNDUwO1xubGV0IG1hcmdpbiA9IHtcbiAgICB0b3A6IDIwLFxuICAgIGJvdHRvbTogMjAsXG4gICAgbGVmdDogMjAsXG4gICAgcmlnaHQ6IDIwXG59O1xuXG52YXIgd2lkdGggPSB3IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG52YXIgaGVpZ2h0ID0gaCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5sZXQgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIGQzLm1heChkYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgfSldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG52YXIgeSA9IGQzLnNjYWxlLm9yZGluYWwoKSAgICAgICAgICAvLyBuZWVkIGRpc3RpbmN0IHZhbHVlcyBlZyBrZXlzXG4gICAgICAgIC5kb21haW4oZGF0YS5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkua2V5O1xuICAgICAgICB9KSlcbiAgICAgICAgLnJhbmdlQmFuZHMoWzAsIGhlaWdodF0pOyAgIC8vIHVzZWQgZm9yIGRpc3RpbmN0IHZhbHVlc1xuXG4vLyBhbHRlciBjb2xvdXJzIHVzaW5nIGxpbmVhciBzY2FsZVxubGV0IGxpbmVhckNvbG9yU2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgZGF0YS5sZW5ndGhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFsnIzU3MjUwMCcsICcjRjY4MDI2J10pO1xuXG4vLyBvcmRpbmFsIGZvciBkaXN0aW5jdCBjb2xvdXJzXG5sZXQgb3JkaW5hbENvbG9yU2NhbGUgPSBkMy5zY2FsZS5jYXRlZ29yeTIwKCk7XG5cbmxldCBzdmcgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCA4MDApXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgNDIwKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2NoYXJ0Jyk7XG5sZXQgY2hhcnQgPSBzdmcuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnZGlzcGxheScsIHRydWUpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDIwLCAyMCknKTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpICAgICAgICAgICAgICAgIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgICAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAvLyB4KCkgZG9lcyB0aGUgc2NhbGluZ1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpIC0gMTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJDb2xvclNjYWxlKGkpO1xuICAgICAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyLWxhYmVsJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuY2xhc3NlZCgnYmFyLWxhYmVsJywgdHJ1ZSlcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC52YWx1ZSk7ICAgICAgICAgIC8vIHVzZSBjc3MgdG8gY2hhbmdlIHRoZSBhbmNob3JcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R4JywgLTQpXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2R5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5LnJhbmdlQmFuZCgpLzEuNSsyO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pO1xufVxuXG5wbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhXG59KTtcbiIpKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogImFkZGluZy14LWFuZC15LWF4aXMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNjUzCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJBZGRpbmcgWCBhbmQgWSBheGlzIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNjU2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA2NTYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIi8vIGFmdGVyIHRoZSBjb2xvdXIgc2NhbGVzXG5cbmxldCB4QXhpcyA9IGQzLnN2Zy5heGlzKCkgICAgICAgICAgIC8vIHN2ZyBwb3J0aW9uIG9mIHRoZSBkMyBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgLm9yaWVudCgnYm90dG9tJyk7XG5cbmxldCB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAub3JpZW50KCdsZWZ0Jyk7XG5cbi4uLlxuXG5mdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgIC8vIGNyZWF0aW5nIHRoZSBiYXJzXG4gICAgLy8gdmVydGljYWwgYmFyIGdyYXBoXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKCkgICAgICAgICAgICAgICAgLy8gZW50ZXIgcGhhc2VcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXInKSAgIC8vIGZvciBmdXR1cmUgc2VsZWN0aW9uc1xuICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB5KGQua2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgIC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkgLSAxO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckNvbG9yU2NhbGUoaSk7XG4gICAgICAgIH0pO1xuXG4gICAgdGhpcy5zZWxlY3RBbGwoJy5iYXItbGFiZWwnKVxuICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5jbGFzc2VkKCdiYXItbGFiZWwnLCB0cnVlKVxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geChkLnZhbHVlKTsgICAgICAgICAgLy8gdXNlIGNzcyB0byBjaGFuZ2UgdGhlIGFuY2hvclxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHgnLCAtNClcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignZHknLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHkucmFuZ2VCYW5kKCkvMS41KzI7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgdGhpcy5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3ggYXhpcycsIHRydWUpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgMCAgKyAnLCAnICsgaGVpZ2h0ICArICcpJylcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB0aGlzLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgneSBheGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDApJylcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbn1cbiIpKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogImZsaXBwaW5nLXRoZS1heGVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDcxOAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiRmxpcHBpbmcgdGhlIGF4ZXMiKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNzIxCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkhvdyB0byBjcmVhdGUgYSBjb2x1bW4gY2hhcnQ/IiksIG1keCgidWwiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA3MjIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDcyMwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJoZWlnaHQgbmVlZHMgdG8gdGFrZSBhbiBvZmZzZXQiKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA3MjQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAib3RoZXIgdmFsdWVzIGVzc2VudGlhbGx5IGludmVydCIpLCBtZHgoImxpIiwgewogICAgcGFyZW50TmFtZTogInVsIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDcyNQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJ0ZXh0IGFuY2hvciB3aWxsIGJlICIsIG1keCgiaW5saW5lQ29kZSIsIHsKICAgIHBhcmVudE5hbWU6ICJsaSIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA3MjUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAibWlkZGxlIiksICIgaW4gY3NzIikpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDcyNwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNzI3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJ2YXIgZGF0YSA9IFtcbiAgICB7a2V5OiBcIkdsYXplZFwiLCAgICAgdmFsdWU6IDEzMn0sXG4gICAge2tleTogXCJKZWxseVwiLCAgICAgIHZhbHVlOiA3MX0sXG4gICAge2tleTogXCJIb2xlc1wiLCAgICAgIHZhbHVlOiAzMzd9LFxuICAgIHtrZXk6IFwiU3ByaW5rbGVzXCIsICB2YWx1ZTogOTN9LFxuICAgIHtrZXk6IFwiQ3J1bWJcIiwgICAgICB2YWx1ZTogNzh9LFxuICAgIHtrZXk6IFwiQ2hvY29sYXRlXCIsICB2YWx1ZTogNDN9LFxuICAgIHtrZXk6IFwiQ29jb251dFwiLCAgICB2YWx1ZTogMjB9LFxuICAgIHtrZXk6IFwiQ3JlYW1cIiwgICAgICB2YWx1ZTogMTZ9LFxuICAgIHtrZXk6IFwiQ3J1bGxlclwiLCAgICB2YWx1ZTogMzB9LFxuICAgIHtrZXk6IFwiXHhDOWNsYWlyXCIsICAgICB2YWx1ZTogOH0sXG4gICAge2tleTogXCJGcml0dGVyXCIsICAgIHZhbHVlOiAxN30sXG4gICAge2tleTogXCJCZWFyY2xhd1wiLCAgIHZhbHVlOiAyMX1cbl07XG5cbmxldCB3ID0gODAwO1xubGV0IGggPSA0NTA7XG5sZXQgbWFyZ2luID0ge1xuICAgIHRvcDogMjAsXG4gICAgYm90dG9tOiAyMCxcbiAgICBsZWZ0OiAyMCxcbiAgICByaWdodDogMjBcbn07XG5cbnZhciB3aWR0aCA9IHcgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbnZhciBoZWlnaHQgPSBoIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbmxldCB4ID0gZDMuc2NhbGUub3JkaW5hbCgpICAgICAgICAgIC8vIG5lZWQgZGlzdGluY3QgdmFsdWVzIGVnIGtleXNcbiAgICAgICAgLmRvbWFpbihkYXRhLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5rZXk7XG4gICAgICAgIH0pKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgaGVpZ2h0XSk7ICAgLy8gdXNlZCBmb3IgZGlzdGluY3QgdmFsdWVzXG5cbmxldCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEsIChkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pOyAgICAvLyBJTVBPUlRBTlQgQ0hBTkdFIEZST00gWzAsIHdpZHRoXVxuXG4vLyBhbHRlciBjb2xvdXJzIHVzaW5nIGxpbmVhciBzY2FsZVxubGV0IGxpbmVhckNvbG9yU2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgZGF0YS5sZW5ndGhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFsnIzU3MjUwMCcsICcjRjY4MDI2J10pO1xuXG4vLyBvcmRpbmFsIGZvciBkaXN0aW5jdCBjb2xvdXJzXG5sZXQgb3JkaW5hbENvbG9yU2NhbGUgPSBkMy5zY2FsZS5jYXRlZ29yeTIwKCk7XG5cbmxldCBzdmcgPSBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ3N2ZycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCA4MDApXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgNDIwKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2NoYXJ0Jyk7XG5sZXQgY2hhcnQgPSBzdmcuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnZGlzcGxheScsIHRydWUpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDIwLCAyMCknKTtcblxuZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAvLyBjcmVhdGluZyB0aGUgYmFyc1xuICAgIC8vIHZlcnRpY2FsIGJhciBncmFwaFxuICAgIHRoaXMuc2VsZWN0QWxsKCcuYmFyJylcbiAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgIC5lbnRlcigpICAgICAgICAgICAgICAgIC8vIGVudGVyIHBoYXNlXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJykgICAvLyBmb3IgZnV0dXJlIHNlbGVjdGlvbnNcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC5rZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLnZhbHVlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgIC8vIHgoKSBkb2VzIHRoZSBzY2FsaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoZCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHgucmFuZ2VCYW5kKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGluZWFyQ29sb3JTY2FsZShpKTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLnNlbGVjdEFsbCgnLmJhci1sYWJlbCcpXG4gICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmNsYXNzZWQoJ2Jhci1sYWJlbCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4KGQudmFsdWUpOyAgICAgICAgICAvLyB1c2UgY3NzIHRvIGNoYW5nZSB0aGUgYW5jaG9yXG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeCcsIC00KVxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geShkLmtleSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdkeScsIChkLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geS5yYW5nZUJhbmQoKS8xLjUrMjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgneCBheGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAwICArICcsICcgKyBoZWlnaHQgICsgJyknKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICB0aGlzLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgneSBheGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDApJylcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbn1cblxucGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgZGF0YTogZGF0YVxufSk7XG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJhZGRpbmctZ3JpZGxpbmVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDgzOQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiQWRkaW5nIEdyaWRsaW5lcyIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDg0MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogODQyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJ2YXIgeUdyaWRsaW5lcyA9IGQzLnN2Zy5heGlzKCkgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbm90aGVyIFwiYXhpc1wiXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLXdpZHRoLCAwLCAwKSAgICAgICAgICAgICAvLyB1c2VkIHRvIGFkanVzdCB0aGUgYXhpc1xuICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgnJylcbiAgICAgICAgICAgICAgICAgICAgLm9yaWVudCgnbGVmdCcpO1xuXG4vLyBhZGQgdGhlc2UgZ3JpZCBsaW5lcyB3aXRoIHRoZSBjYWxsIGZ1bmN0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcGxvdCBmdW5jdGlvblxuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4NTAKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiVGhlIGdyaWQgbGluZXMgYWxzbyBuZWVkIHRvIGJlIHN0eWxlZCEgSGl0IHVwIHRoZSBDU1MgZmlsZSB0byBkbyB0aGlzLiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDg1MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogODUxCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICIuZ3JpZGxpbmUgcGF0aCxcbi5ncmlkbGluZSBsaW5lIHtcbiAgICBmaWxsOiBub25lO1xuICAgIGNvbG9yOiBibHVlO1xuICAgIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlcztcbn1cbiIpKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogInJvdGF0aW5nLXRoZS14LWF4aXMtdGl0bGVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDg1OAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiUm90YXRpbmcgdGhlIFggYXhpcyB0aXRsZXMiKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4NjEKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDg2MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiLi4uXG50aGlzLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgneCBheGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAwICArICcsICcgKyBoZWlnaHQgICsgJyknKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgLTgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIDgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCksIHJvdGF0ZSgtNDUpJyk7XG50aGlzLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgneSBheGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDApJylcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbi4uLlxuIikpLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAiYWRkaW5nLWF4aXMtbGFiZWxzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDg3NwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiQWRkaW5nIGF4aXMgbGFiZWxzIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogODgwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4ODAKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIi8vIHdpdGhpbiB0aGUgcGxvdCBmdW5jdGlvbiBhdCB0aGUgYm90dG9tXG5cbnRoaXMuc2VsZWN0KCcueS5heGlzJylcbiAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAuYXR0cigneCcsIDApXG4gICAgLmF0dHIoJ3knLCAwKVxuICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgtNTAsICcgKyBoZWlnaHQgLyAyICsgJykgcm90YXRlKC05MCknKVxuICAgIC50ZXh0KCdVbml0cyBzb2xkJyk7XG5cbnRoaXMuc2VsZWN0KCcueC5heGlzJylcbiAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAuYXR0cigneCcsIDApXG4gICAgLmF0dHIoJ3knLCAwKVxuICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgd2lkdGggLyAyICsgJywgODApIHJvdGF0ZSgtOTApJylcbiAgICAudGV4dCgnRG9udXQgVHlwZScpO1xuIikpLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAidXBkYXRpbmctdGhlLXBsb3QtZnVuY3Rpb24td2l0aC1iZXN0LXByYWN0aXNlcyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4OTgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlVwZGF0aW5nIHRoZSBwbG90IGZ1bmN0aW9uIHdpdGggYmVzdCBwcmFjdGlzZXMiKSwgbWR4KCJ1bCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDkwMQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTAyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkFkZCBuZXcgcGFyYW1ldGVyIGVudHJpZXMuIikpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDkwNAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTA0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJwbG90LmNhbGwoY2hhcnQsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIGF4aXM6IHtcbiAgICAgICAgeDogeEF4aXMsXG4gICAgICAgIHk6IHlBeGlzXG4gICAgfSxcbiAgICBncmlkbGluZXM6IHlHcmlkbGluZXNcbn1cbn0pXG4iKSksIG1keCgiaHIiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MTQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgbWR4KCJoMSIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogInNlY29udGlvbi01LW1ha2luZy10aGUtY2hhcnQtaW50ZXJhY3RpdmUiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTE1CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJTZWNvbnRpb24gNTogTWFraW5nIHRoZSBDaGFydCBJbnRlcmFjdGl2ZSIpLCBtZHgoInVsIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTE4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MTkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiU29ydGluZyBkYXRhIHVzaW5nIHRoaW5ncyBsaWtlIGJ1dHRvbnMuIiksIG1keCgibGkiLCB7CiAgICBwYXJlbnROYW1lOiAidWwiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTIwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIlNpbWlsYXJ5IHRvIGpxdWVyeSwgd2l0aCBoYXZlIGQzIG1ldGhvZHMgbGlrZSBcIm9uXCIiKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MjEKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiVXNpbmcgdGhlICcrJyBwcmVmaXggd2lsbCBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXIiKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MjIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiVG8gc2hvdyB1cGRhdGVkICIsIG1keCgiaW5saW5lQ29kZSIsIHsKICAgIHBhcmVudE5hbWU6ICJsaSIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MjIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiZGF0YSIpLCAiIGNoYW5nZXMsIHdlIG5lZWQgdG8ga25vdyBhYm91dCB0aGUgcGhhc2VzIC8vIGVudGVyKCksIHVwZGF0ZSgpLCBleGl0KCkiKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MjMKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAid2UgZW5zdXJlIHRoaXMgY2FuIGhhcHBlbiBieSBzcGxpdHRpbmcgdGhlIHNlbGVjdEFsbCBmdW5jdGlvbiB3aGVyZSB0aGUgdXBkYXRlZCBwaGFzZSBpcyBpbiB0aGUgbGF0dGVyIHBhcnQgLSB0aGVuIGluIHRoZSBleGl0IHBoYXNlIHdlIGdldCByaWQgb2YgYW55IGVsZW1lbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBib3VuZCEiKSwgbWR4KCJsaSIsIHsKICAgIHBhcmVudE5hbWU6ICJ1bCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MjQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAieW91IG11c3QgdXBkYXRlIHRoZSBkb21haW5zIHdoZW4geW91IHVwZGF0ZSBkYXRhISIpKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5MjYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDkyNgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiLy8gZG8gZm9yIGFsbCBlbGVtZW50cyB3ZSB3aXNoIHRvIHJlbW92ZVxudGhpcy5zZWxlY3RBbGwoJy5iYXInKVxuICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgIC5leGl0KClcbiAgICAucmVtb3ZlKCk7XG4iKSkpOwp9CgppZiAodHlwZW9mIE1EWENvbnRlbnQgIT09ICd1bmRlZmluZWQnICYmIE1EWENvbnRlbnQgJiYgTURYQ29udGVudCA9PT0gT2JqZWN0KE1EWENvbnRlbnQpICYmIE9iamVjdC5pc0V4dGVuc2libGUoTURYQ29udGVudCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTURYQ29udGVudCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogIk1EWENvbnRlbnQiLAogICAgICBmaWxlbmFtZTogIm1hbnVhbC9KYXZhU2NyaXB0L0pTLUQzLVVkZW15Lm1kIgogICAgfQogIH0pOwp9CgpNRFhDb250ZW50LmlzTURYQ29tcG9uZW50ID0gdHJ1ZTsKOwoKKGZ1bmN0aW9uICgpIHsKICB2YXIgcmVhY3RIb3RMb2FkZXIgPSAodHlwZW9mIHJlYWN0SG90TG9hZGVyR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IHJlYWN0SG90TG9hZGVyR2xvYmFsIDogcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpKS5kZWZhdWx0OwoKICBpZiAoIXJlYWN0SG90TG9hZGVyKSB7CiAgICByZXR1cm47CiAgfQoKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihtYWtlU2hvcnRjb2RlLCAibWFrZVNob3J0Y29kZSIsICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbWFudWFsL0phdmFTY3JpcHQvSlMtRDMtVWRlbXkubWQiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihsYXlvdXRQcm9wcywgImxheW91dFByb3BzIiwgIi9Vc2Vycy9kZW5uaXMub2tlZWZmZS9Qcm9qZWN0LUltcG9zdGVyL2RldmVsb3Blci1ub3Rlcy9tYW51YWwvSmF2YVNjcmlwdC9KUy1EMy1VZGVteS5tZCIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKE1EWExheW91dCwgIk1EWExheW91dCIsICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbWFudWFsL0phdmFTY3JpcHQvSlMtRDMtVWRlbXkubWQiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihNRFhDb250ZW50LCAiTURYQ29udGVudCIsICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbWFudWFsL0phdmFTY3JpcHQvSlMtRDMtVWRlbXkubWQiKTsKfSkoKTsKCjsKCihmdW5jdGlvbiAoKSB7CiAgdmFyIGxlYXZlTW9kdWxlID0gKHR5cGVvZiByZWFjdEhvdExvYWRlckdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyByZWFjdEhvdExvYWRlckdsb2JhbCA6IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKSkubGVhdmVNb2R1bGU7CiAgbGVhdmVNb2R1bGUgJiYgbGVhdmVNb2R1bGUobW9kdWxlKTsKfSkoKTs="},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/JavaScript/JS-D3-Udemy.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h2 {...{\n      \"id\": \"reading-the-d3-documentation\"\n    }}>{`Reading the D3 Documentation`}</h2>\n    {\n      /* TOC */\n    }\n    <pre><code parentName=\"pre\" {...{}}>{`- [Reading the D3 Documentation](#reading-the-d3-documentation)\n- [map() and filter() methods](#map-and-filter-methods)\n- [d3 methods](#d3-methods)\n- [Programmatic SVGs](#programmatic-svgs)\n- [Scaling Data](#scaling-data)\n- [Styling with CSS](#styling-with-css)\n- [Adding Text to the chart](#adding-text-to-the-chart)\n- [Using SVG groups](#using-svg-groups)\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#section-4-making-a-complex-chart\"\n        }}>{`Section 4: Making a Complex Chart`}</a><ul parentName=\"li\">\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#working-with-arrays-of-objects\"\n            }}>{`Working with Arrays of Objects`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#creating-an-ordinal-scale\"\n            }}>{`Creating an Ordinal Scale`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#setting-colour-with-colour-scales\"\n            }}>{`Setting colour with colour scales`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-x-and-y-axis\"\n            }}>{`Adding X and Y axis`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#flipping-the-axes\"\n            }}>{`Flipping the axes`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-gridlines\"\n            }}>{`Adding Gridlines`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#rotating-the-x-axis-titles\"\n            }}>{`Rotating the X axis titles`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#adding-axis-labels\"\n            }}>{`Adding axis labels`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#updating-the-plot-function-with-best-practises\"\n            }}>{`Updating the plot function with best practises`}</a></li>\n        </ul></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#secontion-5-making-the-chart-interactive\"\n        }}>{`Secontion 5: Making the Chart Interactive`}</a></li>\n    </ul>\n    {\n      /* /TOC */\n    }\n    <ul>\n      <li parentName=\"ul\">{`API Documentation is a great link to bookmark`}</li>\n    </ul>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"map-and-filter-methods\"\n    }}>{`map() and filter() methods`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [123, 52, 46, 30, 4];\n\nconst results = data.filter((entry) => {\n    return entry > 50;\n});\n\nconst mapping = data.map((entry) => {\n    console.log(entry.key);\n    console.log(entry.value);\n});\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"d3-methods\"\n    }}>{`d3 methods`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`const example = d3.min(data);\nconsole.log(example);       // values returned\n\nconst dataLoHiValue = d3.extent(data);  // return min/max as array\n\nvar dictMinValue = d3.min(dounts, (d, i) {\n    return d.value;\n});\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"programmatic-svgs\"\n    }}>{`Programmatic SVGs`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132,71,337,93,78,43,20,16,30,8,17,21];\nlet svg = d3.select('body').append('svg')\n                .attr('id', 'chart')\n                .attr('height', 450)\n                .attr('width', 800);\n\n// creating the bars\n// vertical bar graph\nsvg.selectAll('.bar')\n    .data(data)\n    .enter()                // enter phase\n    .append('rect')\n    .attr('class', 'bar')   // for future selections\n    .attr('x', 0)\n    .attr('y', (d i) => {\n        return i * 20;\n    })\n    .attr('width', (d, i) => {\n        return d;\n    })\n    .attr('height', 19);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"scaling-data\"\n    }}>{`Scaling Data`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Creating scaling functions for both x and y.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, w]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, h]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\n// creating the bars\n// vertical bar graph\nsvg\n    .selectAll('.bar')\n    .data(data)\n    .enter() // enter phase\n    .append('rect')\n    .attr('class', 'bar') // for future selections\n    .attr('x', 0)\n    .attr('y', (d, i) => {\n        return y(i);\n    })\n    .attr('width', (d, i) => {\n        return x(d); // x() does the scaling\n    })\n    .attr('height', (d, i) => {\n        return y(1) - 1;\n    });\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"styling-with-css\"\n    }}>{`Styling with CSS`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Getting rid of the aliasing`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-css\"\n      }}>{`.bar {\n    fill: purple;\n}\n`}</code></pre>\n    <p>{`Not that `}<inlineCode parentName=\"p\">{`attr('class', 'bar')`}</inlineCode>{` will manually reset the class value, so you can also use `}<inlineCode parentName=\"p\">{`.classed('bar', true)`}</inlineCode>{` - true to add the class, false to remove.`}</p>\n    <h2 {...{\n      \"id\": \"adding-text-to-the-chart\"\n    }}>{`Adding Text to the chart`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Creating scaling functions for both x and y.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, w]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, h]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d;\n        });\n}\n\n// first arg will be what is referenced by \"this\"\nplot.call(svg, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"using-svg-groups\"\n    }}>{`Using SVG groups`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`SVG groups are like a div that are a convenience element to allow children to be moved and affected together.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [132, 71, 337, 93, 78, 43, 20, 16, 30, 8, 17, 21];\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale\n    .linear()\n    .domain([0, d3.max(data)])\n    .range([0, width]);\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, height]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('id', 'chart')\n    .attr('height', h)\n    .attr('width', w);\n\nlet chart = svg\n    .append('g')\n    .classed('display', true)\n    .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d;\n        });\n}\n\n// first arg will be what is referenced by \"this\"\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <hr></hr>\n    <h1 {...{\n      \"id\": \"section-4-making-a-complex-chart\"\n    }}>{`Section 4: Making a Complex Chart`}</h1>\n    <h2 {...{\n      \"id\": \"working-with-arrays-of-objects\"\n    }}>{`Working with Arrays of Objects`}</h2>\n    <p>{`If working with a dict, we need an accessor function!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var data = [\n    { key: 'Glazed', value: 132 },\n    { key: 'Jelly', value: 71 },\n    { key: 'Holes', value: 337 },\n    { key: 'Sprinkles', value: 93 },\n    { key: 'Crumb', value: 78 },\n    { key: 'Chocolate', value: 43 },\n    { key: 'Coconut', value: 20 },\n    { key: 'Cream', value: 16 },\n    { key: 'Cruller', value: 30 },\n    { key: 'Éclair', value: 8 },\n    { key: 'Fritter', value: 17 },\n    { key: 'Bearclaw', value: 21 }\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale\n    .linear()\n    .domain([\n        0,\n        d3.max(data, (d) => {\n            return d.value;\n        })\n    ])\n    .range([0, width]);\n\nlet y = d3.scale\n    .linear()\n    .domain([0, data.length])\n    .range([0, height]);\n\nlet svg = d3\n    .select('body')\n    .append('svg')\n    .attr('width', 800)\n    .attr('height', 420)\n    .attr('id', 'chart');\nlet chart = svg\n    .append('g')\n    .classed('display', true)\n    .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter() // enter phase\n        .append('rect')\n        .attr('class', 'bar') // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value); // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y(1) - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value); // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(i);\n        })\n        .attr('dy', (d, i) => {\n            return y(1) / 1.5 + 2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"creating-an-ordinal-scale\"\n    }}>{`Creating an Ordinal Scale`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"Éclair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n    })])\n        .range([0, width]);\nvar y = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"setting-colour-with-colour-scales\"\n    }}>{`Setting colour with colour scales`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"Éclair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n    })])\n        .range([0, width]);\nvar y = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\n// alter colours using linear scale\nlet linearColorScale = d3.scale.linear()\n                        .domain([0, data.length])\n                        .range(['#572500', '#F68026']);\n\n// ordinal for distinct colours\nlet ordinalColorScale = d3.scale.category20();\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-x-and-y-axis\"\n    }}>{`Adding X and Y axis`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`// after the colour scales\n\nlet xAxis = d3.svg.axis()           // svg portion of the d3 library\n                .scale(x)\n                .orient('bottom');\n\nlet yAxis = d3.svg.axis()\n                .scale(y)\n                .orient('left');\n\n...\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', 0)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return y.rangeBand() - 1;\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n    this.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis);\n    this.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"flipping-the-axes\"\n    }}>{`Flipping the axes`}</h2>\n    <p>{`How to create a column chart?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`height needs to take an offset`}</li>\n      <li parentName=\"ul\">{`other values essentially invert`}</li>\n      <li parentName=\"ul\">{`text anchor will be `}<inlineCode parentName=\"li\">{`middle`}</inlineCode>{` in css`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`var data = [\n    {key: \"Glazed\",     value: 132},\n    {key: \"Jelly\",      value: 71},\n    {key: \"Holes\",      value: 337},\n    {key: \"Sprinkles\",  value: 93},\n    {key: \"Crumb\",      value: 78},\n    {key: \"Chocolate\",  value: 43},\n    {key: \"Coconut\",    value: 20},\n    {key: \"Cream\",      value: 16},\n    {key: \"Cruller\",    value: 30},\n    {key: \"Éclair\",     value: 8},\n    {key: \"Fritter\",    value: 17},\n    {key: \"Bearclaw\",   value: 21}\n];\n\nlet w = 800;\nlet h = 450;\nlet margin = {\n    top: 20,\n    bottom: 20,\n    left: 20,\n    right: 20\n};\n\nvar width = w - margin.left - margin.right;\nvar height = h - margin.top - margin.bottom;\n\nlet x = d3.scale.ordinal()          // need distinct values eg keys\n        .domain(data.map((entry) => {\n            return entry.key;\n        }))\n        .rangeBands([0, height]);   // used for distinct values\n\nlet y = d3.scale.linear()\n        .domain([0, d3.max(data, (d) => {\n            return d.value;\n        })])\n        .range([height, 0]);    // IMPORTANT CHANGE FROM [0, width]\n\n// alter colours using linear scale\nlet linearColorScale = d3.scale.linear()\n                        .domain([0, data.length])\n                        .range(['#572500', '#F68026']);\n\n// ordinal for distinct colours\nlet ordinalColorScale = d3.scale.category20();\n\nlet svg = d3.select('body').append('svg')\n                        .attr('width', 800)\n            .attr('height', 420)\n            .attr('id', 'chart');\nlet chart = svg.append('g')\n                .classed('display', true)\n        .attr('transform', 'translate(20, 20)');\n\nfunction plot(params) {\n    // creating the bars\n    // vertical bar graph\n    this.selectAll('.bar')\n        .data(params.data)\n        .enter()                // enter phase\n        .append('rect')\n        .attr('class', 'bar')   // for future selections\n        .attr('x', (d, i) => {\n            return x(d.key);\n        })\n        .attr('y', (d, i) => {\n            return y(d.value);\n        })\n        .attr('width', (d, i) => {\n            return x(d.value);      // x() does the scaling\n        })\n        .attr('height', (d, i) => {\n            return x.rangeBand();\n        })\n        .style('fill', (d, i) => {\n            return linearColorScale(i);\n        });\n\n    this.selectAll('.bar-label')\n        .data(params.data)\n        .enter()\n        .append('text')\n        .classed('bar-label', true)\n        .attr('x', (d, i) => {\n            return x(d.value);          // use css to change the anchor\n        })\n        .attr('dx', -4)\n        .attr('y', (d, i) => {\n            return y(d.key);\n        })\n        .attr('dy', (d, i) => {\n            return y.rangeBand()/1.5+2;\n        })\n        .text((d, i) => {\n            return d.value;\n        });\n\n        this.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis);\n        this.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n}\n\nplot.call(chart, {\n    data: data\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-gridlines\"\n    }}>{`Adding Gridlines`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`var yGridlines = d3.svg.axis()              // create another \"axis\"\n                    .scale(y)\n                    .tickSize(-width, 0, 0)             // used to adjust the axis\n                    .tickFormat('')\n                    .orient('left');\n\n// add these grid lines with the call function at the start of the plot function\n`}</code></pre>\n    <p>{`The grid lines also need to be styled! Hit up the CSS file to do this.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`.gridline path,\n.gridline line {\n    fill: none;\n    color: blue;\n    shape-rendering: crispEdges;\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"rotating-the-x-axis-titles\"\n    }}>{`Rotating the X axis titles`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`...\nthis.append('g')\n            .classed('x axis', true)\n            .attr('transform', 'translate(' + 0  + ', ' + height  + ')')\n            .call(xAxis)\n                .selectAll('text')\n                    .style('text-anchor', 'end')\n                    .attr('dx', -8)\n                    .attr('dy', 8)\n                    .attr('transform', 'translate(0,0), rotate(-45)');\nthis.append('g')\n            .classed('y axis', true)\n            .attr('transform', 'translate(0, 0)')\n            .call(yAxis);\n...\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"adding-axis-labels\"\n    }}>{`Adding axis labels`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`// within the plot function at the bottom\n\nthis.select('.y.axis')\n    .append('text')\n    .attr('x', 0)\n    .attr('y', 0)\n    .style('text-anchor', 'middle')\n    .attr('transform', 'translate(-50, ' + height / 2 + ') rotate(-90)')\n    .text('Units sold');\n\nthis.select('.x.axis')\n    .append('text')\n    .attr('x', 0)\n    .attr('y', 0)\n    .style('text-anchor', 'middle')\n    .attr('transform', 'translate(' + width / 2 + ', 80) rotate(-90)')\n    .text('Donut Type');\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"updating-the-plot-function-with-best-practises\"\n    }}>{`Updating the plot function with best practises`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Add new parameter entries.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`plot.call(chart, {\n    data: data,\n    axis: {\n        x: xAxis,\n        y: yAxis\n    },\n    gridlines: yGridlines\n}\n})\n`}</code></pre>\n    <hr></hr>\n    <h1 {...{\n      \"id\": \"secontion-5-making-the-chart-interactive\"\n    }}>{`Secontion 5: Making the Chart Interactive`}</h1>\n    <ul>\n      <li parentName=\"ul\">{`Sorting data using things like buttons.`}</li>\n      <li parentName=\"ul\">{`Similary to jquery, with have d3 methods like \"on\"`}</li>\n      <li parentName=\"ul\">{`Using the '+' prefix will convert the string to a number`}</li>\n      <li parentName=\"ul\">{`To show updated `}<inlineCode parentName=\"li\">{`data`}</inlineCode>{` changes, we need to know about the phases // enter(), update(), exit()`}</li>\n      <li parentName=\"ul\">{`we ensure this can happen by splitting the selectAll function where the updated phase is in the latter part - then in the exit phase we get rid of any elements that are no longer bound!`}</li>\n      <li parentName=\"ul\">{`you must update the domains when you update data!`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`// do for all elements we wish to remove\nthis.selectAll('.bar')\n    .data(params.data)\n    .exit()\n    .remove();\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}