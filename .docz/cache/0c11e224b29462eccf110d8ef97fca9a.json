{"remainingRequest":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--6-1!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js??ref--6-2!/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js!/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Python-Collections.md","dependencies":[{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Python-Collections.md","mtime":1579078174020},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/cache-loader/dist/cjs.js","mtime":1581496618588},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1578565694890},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/@mdx-js/loader/index.js","mtime":1581496618277},{"path":"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/source-map-loader/index.js","mtime":1580255490569}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbm9kZV9tb2R1bGVzL2JhYmVsLXByZXNldC1yZWFjdC1hcHAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIjsKdmFyIF9qc3hGaWxlTmFtZSA9ICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbWFudWFsL1B5dGhvbi9QeXRob24tQ29sbGVjdGlvbnMubWQiOwoKKGZ1bmN0aW9uICgpIHsKICB2YXIgZW50ZXJNb2R1bGUgPSAodHlwZW9mIHJlYWN0SG90TG9hZGVyR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IHJlYWN0SG90TG9hZGVyR2xvYmFsIDogcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpKS5lbnRlck1vZHVsZTsKICBlbnRlck1vZHVsZSAmJiBlbnRlck1vZHVsZShtb2R1bGUpOwp9KSgpOwoKdmFyIF9fc2lnbmF0dXJlX18gPSB0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWxbImRlZmF1bHQiXS5zaWduYXR1cmUgOiBmdW5jdGlvbiAoYSkgewogIHJldHVybiBhOwp9OwoKLyogQGpzeCBtZHggKi8KaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JzsKaW1wb3J0IHsgbWR4IH0gZnJvbSAnQG1keC1qcy9yZWFjdCc7Ci8qIEBqc3ggbWR4ICovCgp2YXIgbWFrZVNob3J0Y29kZSA9IGZ1bmN0aW9uIG1ha2VTaG9ydGNvZGUobmFtZSkgewogIHJldHVybiBmdW5jdGlvbiBNRFhEZWZhdWx0U2hvcnRjb2RlKHByb3BzKSB7CiAgICBjb25zb2xlLndhcm4oIkNvbXBvbmVudCAiICsgbmFtZSArICIgd2FzIG5vdCBpbXBvcnRlZCwgZXhwb3J0ZWQsIG9yIHByb3ZpZGVkIGJ5IE1EWFByb3ZpZGVyIGFzIGdsb2JhbCBzY29wZSIpOwogICAgcmV0dXJuIG1keCgiZGl2IiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsKICAgICAgX19zb3VyY2U6IHsKICAgICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICAgIGxpbmVOdW1iZXI6IDkKICAgICAgfSwKICAgICAgX19zZWxmOiB0aGlzCiAgICB9KSk7CiAgfTsKfTsKCnZhciBsYXlvdXRQcm9wcyA9IHt9Owp2YXIgTURYTGF5b3V0ID0gIndyYXBwZXIiOwpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KF9yZWYpIHsKICB2YXIgY29tcG9uZW50cyA9IF9yZWYuY29tcG9uZW50cywKICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyJjb21wb25lbnRzIl0pOwoKICByZXR1cm4gbWR4KE1EWExheW91dCwgT2JqZWN0LmFzc2lnbih7fSwgbGF5b3V0UHJvcHMsIHByb3BzLCB7CiAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLAogICAgbWR4VHlwZTogIk1EWExheW91dCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCBtZHgoImhyIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjEKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogImludHJvLXRvLXB5dGhvbi1jb2xsZWN0aW9ucyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiSW50cm8gdG8gUHl0aG9uIENvbGxlY3Rpb25zIiksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI1CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkFwcGVuZGluZyBhbmQgYWRkaW5nIHRvIGxpc3RzLiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHsKICAgICJjbGFzc05hbWUiOiAibGFuZ3VhZ2UtcHl0aG9uIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICIjIyMgYV9saXN0PVsxLDIsM11cbiMjIyBhX2xpc3RcbmFfbGlzdC5hcHBlbmQoWzQsNV0pICMgWzEsMiwzLFs0LDVdXVxub3VyX2xpc3QgPSBsaXN0KHJhbmdlKDEwKSlcbiMjIyBvdXJfbGlzdFxuWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldXG4jIyMgb3VyX2xpc3QgKyBbMTAsMTEsMTJdXG5bMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiMjIyBvdXJfbGlzdFxuWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldXG4jIyMgb3VyX2xpc3Q9b3VyX2xpc3QrWzEwLDExLDEyXVxuIyMjIG91cl9saXN0XG5bMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbiIpKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiRm9yIHNwbGl0dGluZyBzdHJpbmdzIHRoZW1zZWx2ZXMgd2UgY2FuIHVzZSAiLCBtZHgoImlubGluZUNvZGUiLCB7CiAgICBwYXJlbnROYW1lOiAicCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJzdHIuc3BsaXQoc3RyPVwiXCIsIG51bT1zdHJpbmcuY291bnQoc3RyKSkiKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJleHRlbmRpbmctY29sbGVjdGlvbnMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDMKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIkV4dGVuZGluZyBDb2xsZWN0aW9ucyIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJOb3JtYWxseSBjbGVhbmVyIGZvciBsYXJnZXIgbGlzdHMgdGhhbiB0aGUgIiwgbWR4KCJpbmxpbmVDb2RlIiwgewogICAgcGFyZW50TmFtZTogInAiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiKyIpLCAiIHN5bWJvbC4iKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7CiAgICAiY2xhc3NOYW1lIjogImxhbmd1YWdlLXB5dGhvbiIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiPj4+IG91cl9saXN0XG5bMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl1cbj4+PiBvdXJfbGlzdC5leHRlbmQocmFuZ2UoMTMsIDIwKSlcbj4+PiBvdXJfbGlzdFxuWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5XVxuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA1NQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJIb3cgZG8gYWRkIG5ldyBpdGVtcyBpbnNpZGUgdGhlIGxpc3Q/IiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNTYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwgewogICAgImNsYXNzTmFtZSI6ICJsYW5ndWFnZS1weXRob24iCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNTYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIj4+PiBhbHBoYT0gbGlzdCgnYWNkZicpXG4+Pj4gYWxwaGFcblsnYScsICdjJywgJ2QnLCAnZiddXG4+Pj4gYWxwaGEuaW5zZXJ0KDEsJ2InKVxuPj4+IGFscGhhXG5bJ2EnLCAnYicsICdjJywgJ2QnLCAnZiddXG4+Pj4gYWxwaGEuaW5zZXJ0KDQsJ2UnKVxuPj4+IGFscGhhXG5bJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ11cbiIpKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogInNob3BwaW5nLWxpc3QiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNjgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlNob3BwaW5nIExpc3QiKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA3MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNzEKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIiMgbm90ZSAtIHlvdSBzaG91bGQgdXNlIGVudW1lcmF0ZSBvbmNlIHlvdSBnZXQgdGhlcmVcbj4+PiBkZWYgc2hvd19oZWxwKCk6XG4gICAgIHByaW50KFwiXFxuRG9pbmcgYSBwcmludF9cIilcblxuPj4+IGRlZiBzaG93X2xpc3QoKTpcbiAgICAgY291bnQ9MVxuICAgICBmb3IgaXRlbSBpbiBzaG9wcGluZ19saXN0OlxuICAgICAgICAgICAgIHByaW50KFwie306IHt9XCIuZm9ybWF0KGNvdW50LCBpdGVtKSlcbiAgICAgICAgICAgICBjb3VudCs9MVxuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJPdGhlciBoZWxwZnVsIHVzZSBjYXNlcy4uLiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDgyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA4MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAid2hpbGUgVHJ1ZTpcbiAgICAjZG8gc3R1ZmZcbiAgICBuZXdfc3R1ZmYgPSBpbnB1dChcIj4gXCIpXG5cbiAgICBpZiBuZXdfc3R1ZmYgPT0gXCJET05FXCI6XG4gICAgICAgIHByaW50KCdEb25lJylcbiAgICAgICAgYnJlYWtcbiAgICBlbGlmXG4gICAgICAgICNkbyBvdGhlciBzdHVmZlxuICAgICAgICBicmVha1xuICAgIGVsc2VcbiAgICAgICAgLi4uXG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJyZW1vdmluZy1pdGVtcy1mcm9tLWEtbGlzdCIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5NQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiUmVtb3ZpbmcgSXRlbXMgZnJvbSBhIExpc3QiKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA5OAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogOTgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgImFfbGlzdD1saXN0KCdhYnpkZScpXG5hX2xpc3QuaW5kZXgoJ3onKVxuZGVsIGFfbGlzdFsyXVxuXG5hX3N0cmluZyA9IFwiSGVsbG9cIlxuIyB0aGlzIHdpbGwgZGVsZXRlIHRoZSBzdHJpbmcgLSBhbHRob3VnaCB0aGUgZGVsIGNhbid0IGJlIHVzZWQgdG8gZGVsZXRlIHdpdGhpbiB0aGUgc3RyaW5nXG4jIHN0cmluZ3MgdGhlbXNlbHZlcyBhcmUgaW1tdXRhYmxlXG5kZWwgYV9zdHJpbmdcblxuIyByZW1vdmUgZm9yIHRoZSBsaXN0XG5teV9saXN0ID0gWzEsMiwzLDFdXG4jIHJlbW92ZSBPTkxZIHJlbW92ZXMgdGhlIGZpcnN0IGluc3RhbmNlIGZyb20gdGhlIGxpc3Rcbm15X2xpc3QucmVtb3ZlKDEpXG5teV9saXN0XG4jIFsyLDMsMV1cbiIpKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogInJlbW92aW5nLXZvd2Vscy1mcm9tLWEtbGlzdC1vZi13b3Jkcy1hbmQtY2FwaXRhbGlzaW5nLXRoZW0iCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTE0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJSZW1vdmluZyB2b3dlbHMgZnJvbSBhIGxpc3Qgb2Ygd29yZHMgYW5kIGNhcGl0YWxpc2luZyB0aGVtIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTE3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxMTcKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIm5hbWVzID0gW1wiRGVubmlzXCIsIFwiQmlsbHlcIiwgXCJUcm9qYW5cIiwgXCJIb3JzZVwiXVxudm93ZWxzID0gbGlzdCgnYWVpb3UnKVxub3V0cHV0ID0gW11cblxuZm9yIG5hbWUgaW4gbmFtZXM6XG4gICAgbmFtZV9saXN0ID0gbGlzdChuYW1lLmxvd2VyKCkpXG5cbiAgICBmb3Igdm93ZWwgaW4gdm93ZWxzOlxuICAgICAgICB3aGlsZSBUcnVlOlxuICAgICAgICAgICAgdHJ5OlxuICAgICAgICAgICAgICAgIHN0YXRlX2xpc3QucmVtb3ZlKHZvd2VsKVxuICAgICAgICAgICAgZXhjZXB0OlxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgb3V0cHV0LmFwcGVuZCgnJy5qb2luKG5hbWVfbGlzdCkuY2FwaXRhbGl6ZSgpKVxuXG5wcmludChvdXRwdXQpXG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJwb3AtYW4taXRlbS1mcm9tLXRoZS1saXN0IgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDEzNAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiUG9wIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxMzcKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAicG9wKCkgcmVtb3ZlcyBhbiBpdGVtIGJ5IGluZGV4IGJ1dCBnaXZlcyB1cyB0aGUgaXRlbS4iKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxMzgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDEzOAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAibmFtZXMgPSBbXCJEZW5uaXNcIiwgXCJCaWxseVwiLCBcIlRyb2phblwiLCBcIkhvcnNlXCJdXG5maXJzdCA9IG5hbWVzLnBvcCgpIC8vIGdpdmVzIHRoZSBmaXJzdCBuYW1lXG5hbm90aGVyID0gbmFtZXMucG9wKDIpIC8vIGdpdmVzIGluZGV4IDNcbiIpKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxNDIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE0MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiLy8gUXVpeiBDaGFsbGVuZ2VcblxuLy8gMS4gTW92ZSB0aGUgJzEnIHRvIHRoZSBmcm9udCBvZiB0aGUgbGlzdFxuXG50aGVfbGlzdCA9IFtcImFcIiwgMiwgMywgMSwgRmFsc2UsIFsxLCAyLCAzXV1cblxuIyBZb3VyIGNvZGUgZ29lcyBiZWxvdyBoZXJlXG50aGVfbGlzdC5pbnNlcnQoMCwgdGhlX2xpc3QucG9wKDMpKVxuIikpLCBtZHgoImhyIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTUxCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJzbGljZXMiCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTUyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJTbGljZXMiKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTU1CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIlNsaWNlcyBtZWFuIHdlIGNhbiBnZXQgYmFjayBtb3JlIHRoYW4gb25lIGl0ZW0gZnJvbSBhIGxpc3QuIFdlIGNhbGwgdGhpcyAiLCBtZHgoImlubGluZUNvZGUiLCB7CiAgICBwYXJlbnROYW1lOiAicCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxNTUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAic2xpY2luZyIpLCAiLiIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxNTYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiU29tZXRoaW5nIGltcG9ydGFudCB0byBub3QgaXMgdGhlIHVzZWFiaWxpdHkgb2YgaGF2ZSB0aGUgIiwgIls6XSIsICIgY2FsbCBmb3IgYSBjb3B5IG9mIHRoZSBsaXN0ISIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE1NwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTU3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJteV9zdHJpbmc9XCJIZWxsbyB0aGVyZSFcIlxubXlfc3RyaW5nWzA6NV1cblxubXlfbGlzdD1saXN0KHJhbmdlKDEsNikpXG5teV9saXN0WzA6Ml0gLy8gc2FtZSBhcyBteV9saXN0WzoyXVxubXlfbGlzdFsyOmxlbihteV9saXN0KV1cblxubXlfbGlzdFsxOl1cbm15X2xpc3RbOl0gLy8gZ2V0cyBiYWNrIGEgY29weSBvZiB0aGUgbGlzdFxuXG5teV9uZXdfbGlzdCA9IFs0LDIsMSwzLDVdXG5teV9uZXdfbGlzdC5zb3J0KClcbm15X25ld19saXN0XG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJzbGljaW5nLXdpdGgtYS1zdGVwIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE3MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiU2xpY2luZyB3aXRoIGEgU3RlcCIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxNzQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiSG93IGNhbiB3ZSBzbGljZSB0aGF0IG1vdmUgYmFja3dhcmQgb3IgdGhhdCBza2lwIGl0ZW1zPyIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE3NQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTc1CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJteV9saXN0PWxpc3QocmFuZ2UoMjApKVxuXG4jIGxldCdzIGdldCB0aGUgZXZlbiBudW1iZXJzXG5teV9saXN0Wzo6Ml1cblwiVGVzdGluZ1wiWzo6Ml1cblxuIyByZXZlcnNpbmdcblwiU2xhcFwiWzo6LTFdXG5cbiMgZ2V0dGluZyB0aGUgbWlkZGxlIHNsaWNlIC0gbXVzdCBzd2FwIHBvc2l0aW9ucyFcbm15X2xpc3RbODoyOi0xXVxuXG4jIG5lZ2F0aXZlIGluZGV4ZXMgd2lsbCBhbHNvIGdpdmUgeW91IHRoZSBwb3NpdGlvbnMgZnJvbSB0aGUgZW5kXG5teV9saXN0Wy0xXVxuXG4jIGV4YW1wbGUgb2YgZ3JhYmJpbmcgdGhlIGZpcnN0IGZvdXIgaXRlcmFibGVzIHRocm91Z2ggYSBQeXRob24gZnVuY3Rpb25cbmRlZiBmaXJzdF80KGl0ZXIpOlxuICAgIHJldHVybiBpdGVyWzo0XVxuIikpLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAiZGVsZXRpbmctb3ItcmVwbGFjaW5nLXNsaWNlcyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxOTQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIkRlbGV0aW5nIG9yIFJlcGxhY2luZyBTbGljZXMiKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMTk3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIldlIGNhbiBkZWxldGUgYW5kIHJlcGxhY2Ugd2l0aCBsaXN0cy4iKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAxOTgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDE5OAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAibXlfbGlzdCA9IFsxLDIsICdhJywgJ2InLCA1LDYsJ2YnLCdnJ11cblxuIyB3aGF0IGlmIEkganVzdCB3YW50IGxldHRlcnM/XG5teV9saXN0WzQ6N10gPSBbJ2UnLCdmJ11cbiIpKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjAzCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJzdHJvbmciLCB7CiAgICBwYXJlbnROYW1lOiAicCIsCiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMDMKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiQ29kZSBDaGFsbGVuZ2UiKSksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjA0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMDQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgImRlZiBzaWxseWNhc2UoYyk6XG4gICAgcmV0dXJuIGNbOnJvdW5kKGxlbihjKSAvIDIpXS5sb3dlcigpICsgY1tyb3VuZChsZW4oYykgLyAyKTpdLnVwcGVyKClcbiIpKSwgbWR4KCJociIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDIwNwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAiZGljdGlvbmFyaWVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDIwOAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiRGljdGlvbmFyaWVzIiksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDIxMQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJLZXktVmFsdWUgb3JnYW5pc2F0aW9uLiBUaGV5IHRoZW1zZWx2ZXMgZG8gbm90IGhhdmUgYW4gb3JkZXIuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjEyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMTIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIm15X2RpY3QgPSB7J25hbWUnOiAnRGVubmlzJywgJ2pvYic6ICdTb2Z0d2FyZSBFbmdpbmVlcid9XG5cbiMgdG8gYWNjZXNzIGl0LCB5b3UgbmVlZCB0byB1c2UgdGhlIGtleSBuYW1lXG5teV9kaWN0WyduYW1lJ11cbiIpKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjE3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkRpY3Rpb25hcmllcyBjYW4gY29udGFpbiBhbnl0aGluZyAtIGV2ZW4geW91ciBvd24gY3VzdG9tIGNsYXNzZXMuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjE4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMTgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIm5hbWVkX2RpY3QgPSB7ICduYW1lJyA6IHsgJ2ZpcnN0JyA6ICdEZW5uaXMnLCAnbGFzdCc6ICdPS2VlZmZlJ30gfVxubmFtZWRfZGljdFsnbmFtZSddWydmaXJzdCddXG5cbiMgdHVwbGUgZ2FtZSBkaWN0XG5nYW1lX2RpY3QgPSB7KDEsMikgOiBUcnVlfVxuZ2FtZV9kaWN0WygxLDIpXVxuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMjUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiQ2hhbGxlbmdlOiBDaGVjayBpZiBhIGRpY3Qga2V5IGlzIGluIHRoZSBsaXN0IiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjI2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMjYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgImRlZiBtZW1iZXJzKGRpY3QsIGtleXMpOlxuICAgIGNvdW50ZXIgPSAwXG4gICAgZm9yIGtleSBpbiBkaWN0OlxuICAgICAgICBpZiBrZXkgaW4ga2V5czpcbiAgICAgICAgICAgIGNvdW50ZXIgPSBjb3VudGVyICsgMVxuICAgIHJldHVybiBjb3VudGVyXG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJtYW5hZ2luZy1rZXlzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDIzMwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiTWFuYWdpbmcgS2V5cyIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMzYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiV2UgY2FuICIsIG1keCgiaW5saW5lQ29kZSIsIHsKICAgIHBhcmVudE5hbWU6ICJwIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDIzNgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJkZWwiKSwgIiBrZXlzIGV0YyBzaW1pbGFyIHRvIHRoZSB3YXkgd2UgZG8gaXQgZm9yIGtleXMuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjM3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyMzcKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIj4+PiBteV9kaWN0Wyd0ZXN0J10gPSAndmFsdWUnXG4+Pj4gbXlfZGljdFxueyd0ZXN0JzogJ3ZhbHVlJywgJ2pvYic6ICdTb2Z0d2FyZSBFbmdpbmVlcicsICduYW1lJzogJ0Rlbm5pcyd9XG4+Pj4gZGVsIG15X2RpY3RbJ3Rlc3QnXVxuPj4+IG15X2RpY3Rcbnsnam9iJzogJ1NvZnR3YXJlIEVuZ2luZWVyJywgJ25hbWUnOiAnRGVubmlzJ31cblxuIyB3ZSBjYW4gdXNlIHVwZGF0ZSBmb3IgbXVsdGlwbGUga2V5cyBldGNcbj4+PiBteV9kaWN0LnVwZGF0ZSh7J2pvYic6ICdEZXZlbG9wZXInLCAnYWdlJzogMjQsICdzdGF0ZSc6ICdOZXcgU291dGggV2FsZXMnfSlcbj4+PiBteV9kaWN0XG57J2pvYic6ICdEZXZlbG9wZXInLCAnbmFtZSc6ICdEZW5uaXMnLCAnYWdlJzogMjQsICdzdGF0ZSc6ICdOZXcgU291dGggV2FsZXMnfVxuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNDkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiQ2hhbGxlbmdlOiBDcmVhdGUgYSBmdW5jdGlvbiBuYW1lZCB3b3JkX2NvdW50KCkgdGhhdCB0YWtlcyBhIHN0cmluZy4gUmV0dXJuIGEgZGljdGlvbmFyeSB3aXRoIGVhY2ggd29yZCBpbiB0aGUgc3RyaW5nIGFzIHRoZSBrZXkgYW5kIHRoZSBudW1iZXIgb2YgdGltZXMgaXQgYXBwZWFycyBhcyB0aGUgdmFsdWUuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjUwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNTAKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgImRlZiB3b3JkX2NvdW50KHNlbnRlbmNlKTpcbiAgICBuZXdfZGljdCA9IHt9XG4gICAgd29yZF9saXN0ID0gc2VudGVuY2Uuc3BsaXQoKVxuICAgIGNvdW50ID0gMFxuXG4gICAgZm9yIG9yaWdpbmFsX3dvcmQgaW4gd29yZF9saXN0OlxuICAgICAgICBpZiBvcmlnaW5hbF93b3JkIG5vdCBpbiBuZXdfZGljdDpcbiAgICAgICAgICAgIGNvdW50ID0gMFxuICAgICAgICAgICAgZm9yIGNvbXBhcmlzb25fd29yZCBpbiB3b3JkX2xpc3Q6XG4gICAgICAgICAgICAgICAgaWYgb3JpZ2luYWxfd29yZCA9PSBjb21wYXJpc29uX3dvcmQ6XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgbmV3X2RpY3QudXBkYXRlKHtvcmlnaW5hbF93b3JkOiBjb3VudH0pXG4gICAgcmV0dXJuIG5ld19kaWN0XG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJ1bnBhY2tpbmctZGljdGlvbmFyaWVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI2NAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiVW5wYWNraW5nIERpY3Rpb25hcmllcyIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNjcKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiWW91IGNhbiBnaXZlIHBsYWNlaG9sZGVycyBhIG5hbWUgYW5kIHVzZSBkaWN0aW9uYXJpZXMgdG8gbWFrZSBpdCBhIGxpdHRsZSBlYXNpZXIuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjY4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAyNjgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIj4+PiBteV9zdHJpbmcgPSBcIkhpIG15IG5hbWUgaXMge25hbWV9IGFuZCBJIGxpdmUgaW4ge3N0YXRlfVwiXG4+Pj4gbXlfc3RyaW5nXG4nSGkgbXkgbmFtZSBpcyB7bmFtZX0gYW5kIEkgbGl2ZSBpbiB7c3RhdGV9J1xuPj4+IG15X3N0cmluZy5mb3JtYXQoJ0Rlbm5pcycsICdTeWRuZXknKVxuVHJhY2ViYWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxuICBGaWxlIFwiPHN0ZGluPlwiLCBsaW5lIDEsIGluIDxtb2R1bGU+XG5LZXlFcnJvcjogJ25hbWUnXG4+Pj4gbXlfc3RyaW5nLmZvcm1hdCgnbmFtZSc9J0Rlbm5pcycsIHN0YXRlPSdTeWRuZXknKVxuICBGaWxlIFwiPHN0ZGluPlwiLCBsaW5lIDFcblN5bnRheEVycm9yOiBrZXl3b3JkIGNhbid0IGJlIGFuIGV4cHJlc3Npb25cbj4+PiBteV9zdHJpbmcuZm9ybWF0KG5hbWU9J0Rlbm5pcycsIHN0YXRlPSdTeWRuZXknKVxuJ0hpIG15IG5hbWUgaXMgRGVubmlzIGFuZCBJIGxpdmUgaW4gU3lkbmV5J1xuXG4jIGhvdyBkbyB3ZSBtYWtlIHRoaXMgcHJvZ3JhbW1hdGljP1xuPj4+IHRlc3RfZGljdCA9IHsnbmFtZSc6J0Rlbm5pcycsICdzdGF0ZSc6J1N5ZG5leSd9XG4+Pj4gbXlfc3RyaW5nLmZvcm1hdCgqKnRlc3RfZGljdClcbidIaSBteSBuYW1lIGlzIERlbm5pcyBhbmQgSSBsaXZlIGluIFN5ZG5leSdcbiIpKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjg2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkNvZGUgQ2hhbGxlbmdlOiBDcmVhdGUgYSBmdW5jdGlvbiBuYW1lZCBzdHJpbmdfZmFjdG9yeSB0aGF0IGFjY2VwdHMgYSBsaXN0IG9mIGRpY3Rpb25hcmllcyBhbmQgYSBzdHJpbmcuIFJldHVybiBhIG5ldyBsaXN0IGJ1aWx0IGJ5IHVzaW5nIC5mb3JtYXQoKSBvbiB0aGUgc3RyaW5nLCBmaWxsZWQgaW4gYnkgZWFjaCBvZiB0aGUgZGljdGlvbmFyaWVzIGluIHRoZSBsaXN0LiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDI4NwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMjg3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJkaWN0cyA9IFtcbiAgICB7J25hbWUnOiAnTWljaGVsYW5nZWxvJyxcbiAgICAgJ2Zvb2QnOiAnUElaWkEnfSxcbiAgICB7J25hbWUnOiAnR2FyZmllbGQnLFxuICAgICAnZm9vZCc6ICdsYXNhbmdhJ30sXG4gICAgeyduYW1lJzogJ1dhbHRlcicsXG4gICAgICdmb29kJzogJ3BhbmNha2VzJ30sXG4gICAgeyduYW1lJzogJ0dhbGFjdHVzJyxcbiAgICAgJ2Zvb2QnOiAnd29ybGRzJ31cbl1cblxuc3RyaW5nID0gXCJIaSwgSSdtIHtuYW1lfSBhbmQgSSBsb3ZlIHRvIGVhdCB7Zm9vZH0hXCJcblxuZGVmIHN0cmluZ19mYWN0b3J5KGxpc3Rfb2ZfZGljdCwgc3RyKTpcbiAgICBuZXdfbGlzdCA9IFtdXG4gICAgZm9yIGluZF9saXN0IGluIGxpc3Rfb2ZfZGljdDpcbiAgICAgICAgbmV3X2xpc3QuYXBwZW5kKHN0ci5mb3JtYXQoKippbmRfbGlzdCkpXG4gICAgcmV0dXJuIG5ld19saXN0XG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJkaWN0aW9uYXJ5LWl0ZXJhdGlvbiIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzMDYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIkRpY3Rpb25hcnkgSXRlcmF0aW9uIiksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDMwOQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJBZ2FpbiwgRGljdGlvbmFyaWVzIGluIFB5dGhvbiBkbyBub3QgaGF2ZSBhIHNldCBvcmRlciwgYnV0IHdlIGNhbiBzdGlsbCBpdGVyYXRlIG92ZXIgdGhlbS4iKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzMTAKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDMxMAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiPj4+IG15X2RpY3Rcbnsnam9iJzogJ0RldmVsb3BlcicsICduYW1lJzogJ0Rlbm5pcycsICdhZ2UnOiAyNCwgJ3N0YXRlJzogJ05ldyBTb3V0aCBXYWxlcyd9XG4+Pj4gZm9yIHRoaW5nIGluIG15X2RpY3Q6XG4uLi4gICAgIHByaW50KHRoaW5nKVxuLi4uXG5qb2Jcbm5hbWVcbmFnZVxuc3RhdGVcblxuPj4+IGZvciBrZXkgaW4gbXlfZGljdDpcbi4uLiAgICAgcHJpbnQobXlfZGljdFtrZXldKVxuLi4uXG5EZXZlbG9wZXJcbkRlbm5pc1xuMjRcbk5ldyBTb3V0aCBXYWxlc1xuXG4+Pj4gZm9yIHZhbHVlIGluIG15X2RpY3QudmFsdWVzKCk6XG4uLi4gICAgIHByaW50KHZhbHVlKVxuLi4uXG5EZXZlbG9wZXJcbkRlbm5pc1xuMjRcbk5ldyBTb3V0aCBXYWxlc1xuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzMzYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiQ3JlYXRlIGEgZnVuY3Rpb24gbmFtZWQgbW9zdC1jbGFzc2VzIHRoYXQgdGFrZXMgYSBkaWN0aW9uYXJ5IG9mIHRlYWNoZXJzLiBFYWNoIGtleSBpcyBhIHRlYWNoZXIncyBuYW1lIGFuZCB0aGVpciB2YWx1ZSBpcyBhIGxpc3Qgb2YgY2xhc3NlcyB0aGV5J3ZlIHRhdWdodC4gbW9zdC1jbGFzc2VzIHNob3VsZCByZXR1cm4gdGhlIHRlYWNoZXIgd2l0aCB0aGUgbW9zdCBjbGFzc2VzLiIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzMzcKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiTmV4dCwgY3JlYXRlIGEgZnVuY3Rpb24gbmFtZWQgbnVtX3RlYWNoZXJzIHRoYXQgdGFrZXMgdGhlIHNhbWUgZGljdGlvbmFyeSBvZiB0ZWFjaGVycyBhbmQgY2xhc3Nlcy4gUmV0dXJuIHRoZSB0b3RhbCBudW1iZXIgb2YgdGVhY2hlcnMuIiksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDMzOAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJOb3csIGNyZWF0ZSBhIGZ1bmN0aW9uIG5hbWVkIHN0YXRzIHRoYXQgdGFrZXMgdGhlIHRlYWNoZXIgZGljdGlvbmFyeS4gUmV0dXJuIGEgbGlzdCBvZiBsaXN0cyBpbiB0aGUgZm9ybWF0ICIsICJbIiwgbWR4KCJpbmxpbmVDb2RlIiwgewogICAgcGFyZW50TmFtZTogInAiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzM4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIjx0ZWFjaGVyIG5hbWU+IiksICIsICIsIG1keCgiaW5saW5lQ29kZSIsIHsKICAgIHBhcmVudE5hbWU6ICJwIiwKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDMzOAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICI8bnVtYmVyIG9mIGNsYXNzZXM+IiksICJdIiwgIi4gRm9yIGV4YW1wbGUsIG9uZSBpdGVtIGluIHRoZSBsaXN0IHdvdWxkIGJlICIsICJbJ0RhdmUgTWNGYXJsYW5kJywgMV0iLCAiLiIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzMzkKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiR3JlYXQgd29yayEgRmluYWxseSwgd3JpdGUgYSBmdW5jdGlvbiBuYW1lZCBjb3Vyc2VzIHRoYXQgdGFrZXMgdGhlIHRlYWNoZXJzIGRpY3Rpb25hcnkuIEl0IHNob3VsZCByZXR1cm4gYSBzaW5nbGUgbGlzdCBvZiBhbGwgb2YgdGhlIGNvdXJzZXMgb2ZmZXJlZCBieSBhbGwgb2YgdGhlIHRlYWNoZXJzLiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM0MAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzQwCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJkZWYgbW9zdF9jbGFzc2VzKHRlYWNoZXJzKTpcbiAgICBoaWdoZXN0X3ZhbHVlID0gMFxuICAgIHRlYWNoZXJfbmFtZSA9IFwiXCJcbiAgICBmb3IgdGVhY2hlciBpbiB0ZWFjaGVyczpcbiAgICAgICAgaWYgbGVuKHRlYWNoZXJzW3RlYWNoZXJdKSA+IGhpZ2hlc3RfdmFsdWU6XG4gICAgICAgICAgICBoaWdoZXN0X3ZhbHVlID0gbGVuKHRlYWNoZXJzW3RlYWNoZXJdKVxuICAgICAgICAgICAgdGVhY2hlcl9uYW1lID0gdGVhY2hlclxuICAgIHJldHVybiB0ZWFjaGVyX25hbWVcblxuZGVmIG51bV90ZWFjaGVycyh0ZWFjaGVycyk6XG4gICAgcmV0dXJuIGxlbih0ZWFjaGVycylcblxuZGVmIHN0YXRzKHRlYWNoZXJzKTpcbiAgICByZXR1cm5fbGlzdCA9IFtdXG4gICAgZm9yIHRlYWNoZXIgaW4gdGVhY2hlcnM6XG4gICAgICAgIHJldHVybl9saXN0LmFwcGVuZChbdGVhY2hlciwgbGVuKHRlYWNoZXJzW3RlYWNoZXJdKV0pXG4gICAgcmV0dXJuIHJldHVybl9saXN0XG5cbmRlZiBjb3Vyc2VzKHRlYWNoZXJzKTpcbiAgICBzaW5nbGVfY291cnNlcyA9IFtdXG4gICAgZm9yIGNvdXJzZXMgaW4gdGVhY2hlcnMudmFsdWVzKCk6XG4gICAgICAgIGZvciBjb3Vyc2UgaW4gY291cnNlczpcbiAgICAgICAgICAgIGlmIGNvdXJzZSBub3QgaW4gc2luZ2xlX2NvdXJzZXM6XG4gICAgICAgICAgICAgICAgc2luZ2xlX2NvdXJzZXMuYXBwZW5kKGNvdXJzZSlcbiAgICByZXR1cm4gc2luZ2xlX2NvdXJzZXNcbiIpKSwgbWR4KCJociIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM2NgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCBtZHgoImgyIiwgT2JqZWN0LmFzc2lnbih7CiAgICAiaWQiOiAidHVwbGVzIgogIH0sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM2NwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiVHVwbGVzIiksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM3MAogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJMaXN0cyB0aGVtc2VsdmVzIGNhbiBiZSBtdXRhdGVkLCBidXQgc29tZXRpbWVzIHdlIHdhbnQgdGhlIGNvbGxlY3Rpb25zIHRvIHN0YXkgdGhlIHNhbWUuIFRoYXQncyB3aGVyZSB0dXBsZXMgY29tZSBpbi4gVGhleSB0aGVtc2VsdmVzIGFyZSBpbW11dGFibGUuIiksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM3MQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJUdXBsZXMgZG8gbm90IHN1cHBvcnQgaXRlbSBhc3NpZ25tZW50LiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDM3MgogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzcyCiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICI+Pj4gdHVwbGVUZXN0ID0gKDEsMiwzKVxuPj4+IHR1cGxlVGVzdFxuKDEsIDIsIDMpXG4+Pj4gbXlfc2Vjb25kX3R1cGxlID0gMSwyLDNcbj4+PiBteV9zZWNvbmRfdHVwbGVcbigxLCAyLCAzKVxuPj4+IG15X3RoaXJkX3R1cGxlID0gdHVwbGUoWzEsMiwzXSlcbj4+PiBteV90aGlyZF90dXBsZVxuKDEsIDIsIDMpXG4+Pj4gZGlyKHR1cGxlKVxuWydfX2FkZF9fJywgJ19fY2xhc3NfXycsICdfX2NvbnRhaW5zX18nLCAnX19kZWxhdHRyX18nLCAnX19kb2NfXycsICdfX2VxX18nLCAnX19mb3JtYXRfXycsICdfX2dlX18nLCAnX19nZXRhdHRyaWJ1dGVfXycsICdfX2dldGl0ZW1fXycsICdfX2dldG5ld2FyZ3NfXycsICdfX2dldHNsaWNlX18nLCAnX19ndF9fJywgJ19faGFzaF9fJywgJ19faW5pdF9fJywgJ19faXRlcl9fJywgJ19fbGVfXycsICdfX2xlbl9fJywgJ19fbHRfXycsICdfX211bF9fJywgJ19fbmVfXycsICdfX25ld19fJywgJ19fcmVkdWNlX18nLCAnX19yZWR1Y2VfZXhfXycsICdfX3JlcHJfXycsICdfX3JtdWxfXycsICdfX3NldGF0dHJfXycsICdfX3NpemVvZl9fJywgJ19fc3RyX18nLCAnX19zdWJjbGFzc2hvb2tfXycsICdjb3VudCcsICdpbmRleCddXG4iKSksIG1keCgiaDIiLCBPYmplY3QuYXNzaWduKHsKICAgICJpZCI6ICJ0dXBsZS1wYWNraW5nLWFuZC11bnBhY2tpbmciCiAgfSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzg0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJUdXBsZSBQYWNraW5nIGFuZCBVbnBhY2tpbmciKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzg3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkhlcmUgd2UgY3JlYXRlIGEgdHVwbGUgdGhhdCBoYXMgdmFsdWVkIGFzc2lnbmVkIGJ5IGFub3RoZXIgdHVwbGUuIEl0J3MgcmVmZXJyZWQgdG8gYXMgIiwgbWR4KCJpbmxpbmVDb2RlIiwgewogICAgcGFyZW50TmFtZTogInAiLAogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzg3CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgInNpbXVsYXRuZW91cyBhc3NpZ25tZW50IiksICIuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogMzg4CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiAzODgKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIj4+PiBhLGIgPSAxLDJcbj4+PiBhXG4xXG4+Pj4gYlxuMlxuXG4jIHVucGFja2luZ1xuPj4+IGMgPSAoMyw0KVxuPj4+IChkLGUpID0gY1xuPj4+IGRcbjNcbj4+PiBlXG40XG5cbiMgcGFja2luZ1xuPj4+IGYgPSBkLGVcbj4+PiBmXG4oMywgNClcbj4+PiBmID09IGNcblRydWVcblxuIyBzd2FwcGluZyB0aGUgdmFsdWVcbj4+PiBkZWwgYVxuPj4+IGRlbCBiXG4+Pj4gYSA9IDFcbj4+PiBiID0gMlxuPj4+IGEsYiA9IGIsYVxuPj4+IGFcbjJcbj4+PiBiXG4xXG5cbiMgZnVuY3Rpb24gZXhhbXBsZVxuPj4+IGRlZiBteV9mdW5jKCk6XG4uLi4gICAgIHJldHVybiAxLDIsM1xuLi4uXG4+Pj4gbXlfZnVuYygpXG4oMSwgMiwgMylcbj4+PiBhLGIsYyA9IG15X2Z1bmMoKVxuPj4+IGFcbjFcbj4+PiBiXG4yXG4+Pj4gY1xuM1xuIikpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0MzQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiQ2hhbGxlbmdlOiBDcmVhdGUgYSBmdW5jdGlvbiBuYW1lZCBzdHJpbmdjYXNlcyB0aGF0IHRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIGEgdHVwbGUgb2YgZm91ciB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5nOiB1cHBlcmNhc2VkLCBsb3dlcmNhc2VkLCB0aXRsZWNhc2VkICh3aGVyZSBldmVyeSB3b3JkJ3MgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkKSwgYW5kIGEgcmV2ZXJzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLiIpLCBtZHgoInByZSIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDQzNQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sIG1keCgiY29kZSIsIE9iamVjdC5hc3NpZ24oewogICAgcGFyZW50TmFtZTogInByZSIKICB9LCB7fSwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDM1CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSksICJkZWYgc3RyaW5nY2FzZXMoc3RyKTpcbiAgICB1cHBlcmNhc2VkID0gc3RyLnVwcGVyKClcbiAgICBsb3dlcmNhc2VkID0gc3RyLmxvd2VyKClcbiAgICB0aXRsZWNhc2VkID0gc3RyLnRpdGxlKClcbiAgICByZXZlcnNlID0gc3RyWzo6LTFdXG4gICAgcmV0dXJuIHVwcGVyY2FzZWQsIGxvd2VyY2FzZWQsIHRpdGxlY2FzZWQsIHJldmVyc2VcbiIpKSwgbWR4KCJoMiIsIE9iamVjdC5hc3NpZ24oewogICAgImlkIjogInR1cGxlcy13aXRoLWZ1bmN0aW9ucyIKICB9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NDIKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIlR1cGxlcyB3aXRoIGZ1bmN0aW9ucyIpLCBtZHgoInAiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NDUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCAiV2UgY2FuIHVzZSBlbnVtZXJhdGUgZm9yIHNvbWUgcGFja2luZyBldGMuIiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNDQ2CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA0NDYKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIj4+PiBhbHBoYSA9IGxpc3QoJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jylcbj4+PiBhbHBoYVxuWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onXVxuPj4+IGRpcihlbnVtZXJhdGUpXG5bJ19fY2xhc3NfXycsICdfX2RlbGF0dHJfXycsICdfX2RvY19fJywgJ19fZm9ybWF0X18nLCAnX19nZXRhdHRyaWJ1dGVfXycsICdfX2hhc2hfXycsICdfX2luaXRfXycsICdfX2l0ZXJfXycsICdfX25ld19fJywgJ19fcmVkdWNlX18nLCAnX19yZWR1Y2VfZXhfXycsICdfX3JlcHJfXycsICdfX3NldGF0dHJfXycsICdfX3NpemVvZl9fJywgJ19fc3RyX18nLCAnX19zdWJjbGFzc2hvb2tfXycsICduZXh0J11cbiMgcHJpbnRzIHRoZSBoZWxwXG4+Pj4gaGVscChlbnVtZXJhdGUpXG4+Pj4gZm9yIChpbmRleCwgbGV0dGVyKSBpbiBlbnVtZXJhdGUoYWxwaGEpOlxuLi4uICAgICBwcmludCgne306IHt9JykuZm9ybWF0KGluZGV4LGxldHRlcilcbi4uLlxuMDogYVxuMTogYlxuMjogY1xuMzogZFxuNDogZVxuNTogZlxuNjogZ1xuNzogaFxuODogaVxuOTogalxuMTA6IGtcbjExOiBsXG4xMjogbVxuMTM6IG5cbjE0OiBvXG4xNTogcFxuMTY6IHFcbjE3OiByXG4xODogc1xuMTk6IHRcbjIwOiB1XG4yMTogdlxuMjI6IHdcbjIzOiB4XG4yNDogeVxuMjU6IHpcblxuPj4+IGZvciBzdGVwIGluIGVudW1lcmF0ZShhbHBoYSk6XG4uLi4gICAgIHByaW50KCd7fToge30nLmZvcm1hdCgqc3RlcCkpXG4uLi5cbjA6IGFcbjE6IGJcbjI6IGNcbjM6IGRcbjQ6IGVcbjU6IGZcbjY6IGdcbjc6IGhcbjg6IGlcbjk6IGpcbjEwOiBrXG4xMTogbFxuMTI6IG1cbjEzOiBuXG4xNDogb1xuMTU6IHBcbjE2OiBxXG4xNzogclxuMTg6IHNcbjE5OiB0XG4yMDogdVxuMjE6IHZcbjIyOiB3XG4yMzogeFxuMjQ6IHlcbjI1OiB6XG4iKSksIG1keCgicCIsIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDUxMwogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0sICJXZSBjYW4gYWxzbyB1bnBhY2sgZGljdGlvbmFyaWVzIGluIGEgc2ltaWxhciBtYXR0ZXI6IiksIG1keCgicHJlIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNTE0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgbWR4KCJjb2RlIiwgT2JqZWN0LmFzc2lnbih7CiAgICBwYXJlbnROYW1lOiAicHJlIgogIH0sIHt9LCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA1MTQKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9KSwgIj4+PiBteV9kaWN0XG57J2pvYic6ICdEZXZlbG9wZXInLCAnbmFtZSc6ICdEZW5uaXMnLCAnYWdlJzogMjQsICdzdGF0ZSc6ICdOZXcgU291dGggV2FsZXMnfVxuPj4+IGZvciBrZXksIHZhbHVlIGluIG15X2RpY3QuaXRlbXMoKTpcbi4uLiAgICAgcHJpbnQoJ3t9OiB7fScuZm9ybWF0KGtleS50aXRsZSgpLCB2YWx1ZSkpXG4uLi5cbkpvYjogRGV2ZWxvcGVyXG5OYW1lOiBEZW5uaXNcbkFnZTogMjRcblN0YXRlOiBOZXcgU291dGggV2FsZXNcbiIpKSwgbWR4KCJwIiwgewogICAgX19zb3VyY2U6IHsKICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSwKICAgICAgbGluZU51bWJlcjogNTI0CiAgICB9LAogICAgX19zZWxmOiB0aGlzCiAgfSwgIkNyZWF0ZSBhIGZ1bmN0aW9uIG5hbWVkIGNvbWJvKCkgdGhhdCB0YWtlcyB0d28gaXRlcmFibGVzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0dXBsZXMuIEVhY2ggdHVwbGUgc2hvdWxkIGhvbGQgdGhlIGZpcnN0IGl0ZW0gaW4gZWFjaCBsaXN0LCB0aGVuIHRoZSBzZWNvbmQgc2V0LCB0aGVuIHRoZSB0aGlyZCwgYW5kIHNvIG9uLiBBc3N1bWUgdGhlIGl0ZXJhYmxlcyB3aWxsIGJlIHRoZSBzYW1lIGxlbmd0aC4iKSwgbWR4KCJwcmUiLCB7CiAgICBfX3NvdXJjZTogewogICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLAogICAgICBsaW5lTnVtYmVyOiA1MjUKICAgIH0sCiAgICBfX3NlbGY6IHRoaXMKICB9LCBtZHgoImNvZGUiLCBPYmplY3QuYXNzaWduKHsKICAgIHBhcmVudE5hbWU6ICJwcmUiCiAgfSwge30sIHsKICAgIF9fc291cmNlOiB7CiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsCiAgICAgIGxpbmVOdW1iZXI6IDUyNQogICAgfSwKICAgIF9fc2VsZjogdGhpcwogIH0pLCAiZGVmIGNvbWJvKGl0ZXIxLCBpdGVyMik6XG4gICAgcmV0ID0gW11cbiAgICBsZW5ndGggPSBsZW4oaXRlcjEpXG4gICAgY291bnRlciA9IDBcbiAgICB3aGlsZSBjb3VudGVyIDwgbGVuZ3RoOlxuICAgICAgICByZXQuYXBwZW5kKChpdGVyMVtjb3VudGVyXSxpdGVyMltjb3VudGVyXSkpXG4gICAgICAgIGNvdW50ZXIgKz0gMVxuICAgIHJldHVybiByZXRcblxuIyBiZXR0ZXIgYWx0ZXJuYXRpdmVzXG5cbmRlZiBjb21ibyhpdGVyYWJsZV8xLCBpdGVyYWJsZV8yKTpcbiAgbGlzdF9vZl90dXBsZXMgPSBbXVxuICBmb3IgaW5kZXggaW4gcmFuZ2UobGVuKGl0ZXJhYmxlXzEpKTpcbiAgICBsaXN0X29mX3R1cGxlcy5hcHBlbmQoKGl0ZXJhYmxlXzFbaW5kZXhdLCBpdGVyYWJsZV8yW2luZGV4XSkpXG5cbiAgcmV0dXJuIGxpc3Rfb2ZfdHVwbGVzXG5cbmRlZiBjb21ibyhpdGVyYWJsZV8xLCBpdGVyYWJsZV8yKTpcbiAgbGlzdF9vZl90dXBsZXMgPSBbXVxuICBmb3IgaW5kZXgsIGl0ZW0yIGluIGVudW1lcmF0ZShpdGVyYWJsZV8yKTpcbiAgICBsaXN0X29mX3R1cGxlcy5hcHBlbmQoIChpdGVyYWJsZV8xW2luZGV4XSwgaXRlbTIpIClcblxuICByZXR1cm4gbGlzdF9vZl90dXBsZXNcblxuZGVmIGNvbWJvKGl0ZXJhYmxlXzEsIGl0ZXJhYmxlXzIpOlxuICByZXR1cm4gbGlzdCh6aXAoaXRlcmFibGVfMSwgaXRlcmFibGVfMikpXG5cbmRlZiBjb21ibyhpdGVyMSwgaXRlcjIpOlxuICBjb21ib19saXN0ID0gW11cbiAgZm9yIGluZGV4LCB2YWx1ZSBpbiBlbnVtZXJhdGUoaXRlcjEpOlxuICAgIHR1cGxlID0gdmFsdWUsIGl0ZXIyW2luZGV4XVxuICAgIGNvbWJvX2xpc3QuYXBwZW5kKHR1cGxlKVxuICByZXR1cm4gY29tYm9fbGlzdFxuIikpKTsKfQoKaWYgKHR5cGVvZiBNRFhDb250ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBNRFhDb250ZW50ICYmIE1EWENvbnRlbnQgPT09IE9iamVjdChNRFhDb250ZW50KSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKE1EWENvbnRlbnQpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1EWENvbnRlbnQsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJNRFhDb250ZW50IiwKICAgICAgZmlsZW5hbWU6ICJtYW51YWwvUHl0aG9uL1B5dGhvbi1Db2xsZWN0aW9ucy5tZCIKICAgIH0KICB9KTsKfQoKTURYQ29udGVudC5pc01EWENvbXBvbmVudCA9IHRydWU7CjsKCihmdW5jdGlvbiAoKSB7CiAgdmFyIHJlYWN0SG90TG9hZGVyID0gKHR5cGVvZiByZWFjdEhvdExvYWRlckdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyByZWFjdEhvdExvYWRlckdsb2JhbCA6IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKSkuZGVmYXVsdDsKCiAgaWYgKCFyZWFjdEhvdExvYWRlcikgewogICAgcmV0dXJuOwogIH0KCiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIobWFrZVNob3J0Y29kZSwgIm1ha2VTaG9ydGNvZGUiLCAiL1VzZXJzL2Rlbm5pcy5va2VlZmZlL1Byb2plY3QtSW1wb3N0ZXIvZGV2ZWxvcGVyLW5vdGVzL21hbnVhbC9QeXRob24vUHl0aG9uLUNvbGxlY3Rpb25zLm1kIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIobGF5b3V0UHJvcHMsICJsYXlvdXRQcm9wcyIsICIvVXNlcnMvZGVubmlzLm9rZWVmZmUvUHJvamVjdC1JbXBvc3Rlci9kZXZlbG9wZXItbm90ZXMvbWFudWFsL1B5dGhvbi9QeXRob24tQ29sbGVjdGlvbnMubWQiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihNRFhMYXlvdXQsICJNRFhMYXlvdXQiLCAiL1VzZXJzL2Rlbm5pcy5va2VlZmZlL1Byb2plY3QtSW1wb3N0ZXIvZGV2ZWxvcGVyLW5vdGVzL21hbnVhbC9QeXRob24vUHl0aG9uLUNvbGxlY3Rpb25zLm1kIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoTURYQ29udGVudCwgIk1EWENvbnRlbnQiLCAiL1VzZXJzL2Rlbm5pcy5va2VlZmZlL1Byb2plY3QtSW1wb3N0ZXIvZGV2ZWxvcGVyLW5vdGVzL21hbnVhbC9QeXRob24vUHl0aG9uLUNvbGxlY3Rpb25zLm1kIik7Cn0pKCk7Cgo7CgooZnVuY3Rpb24gKCkgewogIHZhciBsZWF2ZU1vZHVsZSA9ICh0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWwgOiByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykpLmxlYXZlTW9kdWxlOwogIGxlYXZlTW9kdWxlICYmIGxlYXZlTW9kdWxlKG1vZHVsZSk7Cn0pKCk7"},{"version":3,"sources":["/Users/dennis.okeeffe/Project-Imposter/developer-notes/manual/Python/Python-Collections.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":";;;;;;;;;;;;AAAA;AACE,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,GAAT,QAAoB,eAApB;AACA;;AAGF,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,IAAI;AAAA,SAAI,SAASC,mBAAT,CAA6BC,KAA7B,EAAoC;AAChEC,IAAAA,OAAO,CAACC,IAAR,CAAa,eAAeJ,IAAf,GAAsB,yEAAnC;AACA,WAAO,6BAASE,KAAT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAP;AACD,GAHyB;AAAA,CAA1B;;AAKA,IAAMG,WAAW,GAAG,EAApB;AAGA,IAAMC,SAAS,GAAG,SAAlB;AACA,eAAe,SAASC,UAAT,OAGZ;AAAA,MAFDC,UAEC,QAFDA,UAEC;AAAA,MADEN,KACF;;AACD,SAAO,IAAC,SAAD,oBAAeG,WAAf,EAAgCH,KAAhC;AAAuC,IAAA,UAAU,EAAEM,UAAnD;AAA+D,IAAA,OAAO,EAAC,WAAvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADK,EAEL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oCAFK,EAKL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCALK,EAML;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B;AAC5B,iBAAa;AADe,GAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0WAAL,CANK,EAsBL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qDAAmD;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kDAAnD,CAtBK,EAuBL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAvBK,EA0BL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oDAAkD;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAlD,aA1BK,EA2BL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B;AAC5B,iBAAa;AADe,GAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6LAAL,CA3BK,EAmCL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAnCK,EAoCL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B;AAC5B,iBAAa;AADe,GAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sMAAL,CApCK,EAgDL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAhDK,EAmDL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0QAAL,CAnDK,EA6DL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCA7DK,EA8DL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oNAAL,CA9DK,EA2EL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCA3EK,EA8EL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oXAAL,CA9EK,EA8FL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mEA9FK,EAiGL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8XAAL,CAjGK,EAkHL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCAlHK,EAqHL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6DArHK,EAsHL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uJAAL,CAtHK,EA0HL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gMAAL,CA1HK,EAmIL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAnIK,EAoIL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eApIK,EAuIL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kFAAgF;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAhF,MAvIK,EAwIL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yGAxIK,EAyIL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wQAAL,CAzIK,EAuJL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BAvJK,EA0JL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+DA1JK,EA2JL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6YAAL,CA3JK,EA8KL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qCA9KK,EAiLL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAjLK,EAkLL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6GAAL,CAlLK,EAuLL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAG;AAAQ,IAAA,UAAU,EAAC,GAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAH,CAvLK,EAwLL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sGAAL,CAxLK,EA2LL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA3LK,EA4LL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBA5LK,EA+LL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qEA/LK,EAgML;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oIAAL,CAhMK,EAqML;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yEArMK,EAsML;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6KAAL,CAtMK,EA6ML;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qDA7MK,EA8ML;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0JAAL,CA9MK,EAqNL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBArNK,EAwNL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAc;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAd,oDAxNK,EAyNL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,saAAL,CAzNK,EAqOL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yLArOK,EAsOL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,waAAL,CAtOK,EAoPL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BApPK,EAuPL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yFAvPK,EAwPL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6pBAAL,CAxPK,EA0QL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6NA1QK,EA2QL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qcAAL,CA3QK,EA8RL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BA9RK,EAiSL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kGAjSK,EAkSL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gYAAL,CAlSK,EA4TL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iOA5TK,EA6TL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+IA7TK,EA8TL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yHAAuH;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAvH,QAAuL;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAAvL,qFA9TK,EA+TL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oLA/TK,EAgUL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uuBAAL,CAhUK,EA0VL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA1VK,EA2VL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eA3VK,EA8VL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4JA9VK,EA+VL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8CA/VK,EAgWL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0mBAAL,CAhWK,EA4WL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oCA5WK,EA+WL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+FAA6F;AAAY,IAAA,UAAU,EAAC,GAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAA7F,MA/WK,EAgXL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,maAAL,CAhXK,EA8ZL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yPA9ZK,EA+ZL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2MAAL,CA/ZK,EAsaL,wBAAQ;AACN,UAAM;AADA,GAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAtaK,EAyaL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kDAzaK,EA0aL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,u/BAAL,CA1aK,EA6eL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4DA7eK,EA8eL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qQAAL,CA9eK,EAwfL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gPAxfK,EAyfL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAK;AAAM,IAAA,UAAU,EAAC;AAAjB,KAA2B,EAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,42BAAL,CAzfK,CAAP;AA6hBD;;;;;;;;;;;;;AAEDD,UAAU,CAACE,cAAX,GAA4B,IAA5B;;;;;;;;;;0BA5iBMV,a;0BAKAM,W;0BAGAC,S;0BACkBC,U","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"intro-to-python-collections\"\n    }}>{`Intro to Python Collections`}</h2>\n    <p>{`Appending and adding to lists.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`### a_list=[1,2,3]\n### a_list\na_list.append([4,5]) # [1,2,3,[4,5]]\nour_list = list(range(10))\n### our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n### our_list + [10,11,12]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n### our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n### our_list=our_list+[10,11,12]\n### our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n`}</code></pre>\n    <p>{`For splitting strings themselves we can use `}<inlineCode parentName=\"p\">{`str.split(str=\"\", num=string.count(str))`}</inlineCode></p>\n    <h2 {...{\n      \"id\": \"extending-collections\"\n    }}>{`Extending Collections`}</h2>\n    <p>{`Normally cleaner for larger lists than the `}<inlineCode parentName=\"p\">{`+`}</inlineCode>{` symbol.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`>>> our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n>>> our_list.extend(range(13, 20))\n>>> our_list\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n`}</code></pre>\n    <p>{`How do add new items inside the list?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`>>> alpha= list('acdf')\n>>> alpha\n['a', 'c', 'd', 'f']\n>>> alpha.insert(1,'b')\n>>> alpha\n['a', 'b', 'c', 'd', 'f']\n>>> alpha.insert(4,'e')\n>>> alpha\n['a', 'b', 'c', 'd', 'e', 'f']\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"shopping-list\"\n    }}>{`Shopping List`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`# note - you should use enumerate once you get there\n>>> def show_help():\n     print(\"\\\\nDoing a print_\")\n\n>>> def show_list():\n     count=1\n     for item in shopping_list:\n             print(\"{}: {}\".format(count, item))\n             count+=1\n`}</code></pre>\n    <p>{`Other helpful use cases...`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`while True:\n    #do stuff\n    new_stuff = input(\"> \")\n\n    if new_stuff == \"DONE\":\n        print('Done')\n        break\n    elif\n        #do other stuff\n        break\n    else\n        ...\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"removing-items-from-a-list\"\n    }}>{`Removing Items from a List`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`a_list=list('abzde')\na_list.index('z')\ndel a_list[2]\n\na_string = \"Hello\"\n# this will delete the string - although the del can't be used to delete within the string\n# strings themselves are immutable\ndel a_string\n\n# remove for the list\nmy_list = [1,2,3,1]\n# remove ONLY removes the first instance from the list\nmy_list.remove(1)\nmy_list\n# [2,3,1]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"removing-vowels-from-a-list-of-words-and-capitalising-them\"\n    }}>{`Removing vowels from a list of words and capitalising them`}</h2>\n    <pre><code parentName=\"pre\" {...{}}>{`names = [\"Dennis\", \"Billy\", \"Trojan\", \"Horse\"]\nvowels = list('aeiou')\noutput = []\n\nfor name in names:\n    name_list = list(name.lower())\n\n    for vowel in vowels:\n        while True:\n            try:\n                state_list.remove(vowel)\n            except:\n                break\n    output.append(''.join(name_list).capitalize())\n\nprint(output)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"pop-an-item-from-the-list\"\n    }}>{`Pop an item from the list`}</h2>\n    <p>{`pop() removes an item by index but gives us the item.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`names = [\"Dennis\", \"Billy\", \"Trojan\", \"Horse\"]\nfirst = names.pop() // gives the first name\nanother = names.pop(2) // gives index 3\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`// Quiz Challenge\n\n// 1. Move the '1' to the front of the list\n\nthe_list = [\"a\", 2, 3, 1, False, [1, 2, 3]]\n\n# Your code goes below here\nthe_list.insert(0, the_list.pop(3))\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"slices\"\n    }}>{`Slices`}</h2>\n    <p>{`Slices mean we can get back more than one item from a list. We call this `}<inlineCode parentName=\"p\">{`slicing`}</inlineCode>{`.`}</p>\n    <p>{`Something important to not is the useability of have the `}{`[:]`}{` call for a copy of the list!`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_string=\"Hello there!\"\nmy_string[0:5]\n\nmy_list=list(range(1,6))\nmy_list[0:2] // same as my_list[:2]\nmy_list[2:len(my_list)]\n\nmy_list[1:]\nmy_list[:] // gets back a copy of the list\n\nmy_new_list = [4,2,1,3,5]\nmy_new_list.sort()\nmy_new_list\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"slicing-with-a-step\"\n    }}>{`Slicing with a Step`}</h2>\n    <p>{`How can we slice that move backward or that skip items?`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list=list(range(20))\n\n# let's get the even numbers\nmy_list[::2]\n\"Testing\"[::2]\n\n# reversing\n\"Slap\"[::-1]\n\n# getting the middle slice - must swap positions!\nmy_list[8:2:-1]\n\n# negative indexes will also give you the positions from the end\nmy_list[-1]\n\n# example of grabbing the first four iterables through a Python function\ndef first_4(iter):\n    return iter[:4]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"deleting-or-replacing-slices\"\n    }}>{`Deleting or Replacing Slices`}</h2>\n    <p>{`We can delete and replace with lists.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_list = [1,2, 'a', 'b', 5,6,'f','g']\n\n# what if I just want letters?\nmy_list[4:7] = ['e','f']\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Code Challenge`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`def sillycase(c):\n    return c[:round(len(c) / 2)].lower() + c[round(len(c) / 2):].upper()\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"dictionaries\"\n    }}>{`Dictionaries`}</h2>\n    <p>{`Key-Value organisation. They themselves do not have an order.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`my_dict = {'name': 'Dennis', 'job': 'Software Engineer'}\n\n# to access it, you need to use the key name\nmy_dict['name']\n`}</code></pre>\n    <p>{`Dictionaries can contain anything - even your own custom classes.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`named_dict = { 'name' : { 'first' : 'Dennis', 'last': 'OKeeffe'} }\nnamed_dict['name']['first']\n\n# tuple game dict\ngame_dict = {(1,2) : True}\ngame_dict[(1,2)]\n`}</code></pre>\n    <p>{`Challenge: Check if a dict key is in the list`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def members(dict, keys):\n    counter = 0\n    for key in dict:\n        if key in keys:\n            counter = counter + 1\n    return counter\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"managing-keys\"\n    }}>{`Managing Keys`}</h2>\n    <p>{`We can `}<inlineCode parentName=\"p\">{`del`}</inlineCode>{` keys etc similar to the way we do it for keys.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_dict['test'] = 'value'\n>>> my_dict\n{'test': 'value', 'job': 'Software Engineer', 'name': 'Dennis'}\n>>> del my_dict['test']\n>>> my_dict\n{'job': 'Software Engineer', 'name': 'Dennis'}\n\n# we can use update for multiple keys etc\n>>> my_dict.update({'job': 'Developer', 'age': 24, 'state': 'New South Wales'})\n>>> my_dict\n{'job': 'Developer', 'name': 'Dennis', 'age': 24, 'state': 'New South Wales'}\n`}</code></pre>\n    <p>{`Challenge: Create a function named word_count() that takes a string. Return a dictionary with each word in the string as the key and the number of times it appears as the value.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def word_count(sentence):\n    new_dict = {}\n    word_list = sentence.split()\n    count = 0\n\n    for original_word in word_list:\n        if original_word not in new_dict:\n            count = 0\n            for comparison_word in word_list:\n                if original_word == comparison_word:\n                    count += 1\n                    new_dict.update({original_word: count})\n    return new_dict\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"unpacking-dictionaries\"\n    }}>{`Unpacking Dictionaries`}</h2>\n    <p>{`You can give placeholders a name and use dictionaries to make it a little easier.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_string = \"Hi my name is {name} and I live in {state}\"\n>>> my_string\n'Hi my name is {name} and I live in {state}'\n>>> my_string.format('Dennis', 'Sydney')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'name'\n>>> my_string.format('name'='Dennis', state='Sydney')\n  File \"<stdin>\", line 1\nSyntaxError: keyword can't be an expression\n>>> my_string.format(name='Dennis', state='Sydney')\n'Hi my name is Dennis and I live in Sydney'\n\n# how do we make this programmatic?\n>>> test_dict = {'name':'Dennis', 'state':'Sydney'}\n>>> my_string.format(**test_dict)\n'Hi my name is Dennis and I live in Sydney'\n`}</code></pre>\n    <p>{`Code Challenge: Create a function named string_factory that accepts a list of dictionaries and a string. Return a new list built by using .format() on the string, filled in by each of the dictionaries in the list.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`dicts = [\n    {'name': 'Michelangelo',\n     'food': 'PIZZA'},\n    {'name': 'Garfield',\n     'food': 'lasanga'},\n    {'name': 'Walter',\n     'food': 'pancakes'},\n    {'name': 'Galactus',\n     'food': 'worlds'}\n]\n\nstring = \"Hi, I'm {name} and I love to eat {food}!\"\n\ndef string_factory(list_of_dict, str):\n    new_list = []\n    for ind_list in list_of_dict:\n        new_list.append(str.format(**ind_list))\n    return new_list\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"dictionary-iteration\"\n    }}>{`Dictionary Iteration`}</h2>\n    <p>{`Again, Dictionaries in Python do not have a set order, but we can still iterate over them.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_dict\n{'job': 'Developer', 'name': 'Dennis', 'age': 24, 'state': 'New South Wales'}\n>>> for thing in my_dict:\n...     print(thing)\n...\njob\nname\nage\nstate\n\n>>> for key in my_dict:\n...     print(my_dict[key])\n...\nDeveloper\nDennis\n24\nNew South Wales\n\n>>> for value in my_dict.values():\n...     print(value)\n...\nDeveloper\nDennis\n24\nNew South Wales\n`}</code></pre>\n    <p>{`Create a function named most-classes that takes a dictionary of teachers. Each key is a teacher's name and their value is a list of classes they've taught. most-classes should return the teacher with the most classes.`}</p>\n    <p>{`Next, create a function named num_teachers that takes the same dictionary of teachers and classes. Return the total number of teachers.`}</p>\n    <p>{`Now, create a function named stats that takes the teacher dictionary. Return a list of lists in the format `}{`[`}<inlineCode parentName=\"p\">{`<teacher name>`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`<number of classes>`}</inlineCode>{`]`}{`. For example, one item in the list would be `}{`['Dave McFarland', 1]`}{`.`}</p>\n    <p>{`Great work! Finally, write a function named courses that takes the teachers dictionary. It should return a single list of all of the courses offered by all of the teachers.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def most_classes(teachers):\n    highest_value = 0\n    teacher_name = \"\"\n    for teacher in teachers:\n        if len(teachers[teacher]) > highest_value:\n            highest_value = len(teachers[teacher])\n            teacher_name = teacher\n    return teacher_name\n\ndef num_teachers(teachers):\n    return len(teachers)\n\ndef stats(teachers):\n    return_list = []\n    for teacher in teachers:\n        return_list.append([teacher, len(teachers[teacher])])\n    return return_list\n\ndef courses(teachers):\n    single_courses = []\n    for courses in teachers.values():\n        for course in courses:\n            if course not in single_courses:\n                single_courses.append(course)\n    return single_courses\n`}</code></pre>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"tuples\"\n    }}>{`Tuples`}</h2>\n    <p>{`Lists themselves can be mutated, but sometimes we want the collections to stay the same. That's where tuples come in. They themselves are immutable.`}</p>\n    <p>{`Tuples do not support item assignment.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> tupleTest = (1,2,3)\n>>> tupleTest\n(1, 2, 3)\n>>> my_second_tuple = 1,2,3\n>>> my_second_tuple\n(1, 2, 3)\n>>> my_third_tuple = tuple([1,2,3])\n>>> my_third_tuple\n(1, 2, 3)\n>>> dir(tuple)\n['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuple-packing-and-unpacking\"\n    }}>{`Tuple Packing and Unpacking`}</h2>\n    <p>{`Here we create a tuple that has valued assigned by another tuple. It's referred to as `}<inlineCode parentName=\"p\">{`simulatneous assignment`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> a,b = 1,2\n>>> a\n1\n>>> b\n2\n\n# unpacking\n>>> c = (3,4)\n>>> (d,e) = c\n>>> d\n3\n>>> e\n4\n\n# packing\n>>> f = d,e\n>>> f\n(3, 4)\n>>> f == c\nTrue\n\n# swapping the value\n>>> del a\n>>> del b\n>>> a = 1\n>>> b = 2\n>>> a,b = b,a\n>>> a\n2\n>>> b\n1\n\n# function example\n>>> def my_func():\n...     return 1,2,3\n...\n>>> my_func()\n(1, 2, 3)\n>>> a,b,c = my_func()\n>>> a\n1\n>>> b\n2\n>>> c\n3\n`}</code></pre>\n    <p>{`Challenge: Create a function named stringcases that takes a string and returns a tuple of four versions of the string: uppercased, lowercased, titlecased (where every word's first letter is capitalized), and a reversed version of the string.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def stringcases(str):\n    uppercased = str.upper()\n    lowercased = str.lower()\n    titlecased = str.title()\n    reverse = str[::-1]\n    return uppercased, lowercased, titlecased, reverse\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuples-with-functions\"\n    }}>{`Tuples with functions`}</h2>\n    <p>{`We can use enumerate for some packing etc.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> alpha = list('abcdefghijklmnopqrstuvwxyz')\n>>> alpha\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n>>> dir(enumerate)\n['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'next']\n# prints the help\n>>> help(enumerate)\n>>> for (index, letter) in enumerate(alpha):\n...     print('{}: {}').format(index,letter)\n...\n0: a\n1: b\n2: c\n3: d\n4: e\n5: f\n6: g\n7: h\n8: i\n9: j\n10: k\n11: l\n12: m\n13: n\n14: o\n15: p\n16: q\n17: r\n18: s\n19: t\n20: u\n21: v\n22: w\n23: x\n24: y\n25: z\n\n>>> for step in enumerate(alpha):\n...     print('{}: {}'.format(*step))\n...\n0: a\n1: b\n2: c\n3: d\n4: e\n5: f\n6: g\n7: h\n8: i\n9: j\n10: k\n11: l\n12: m\n13: n\n14: o\n15: p\n16: q\n17: r\n18: s\n19: t\n20: u\n21: v\n22: w\n23: x\n24: y\n25: z\n`}</code></pre>\n    <p>{`We can also unpack dictionaries in a similar matter:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`>>> my_dict\n{'job': 'Developer', 'name': 'Dennis', 'age': 24, 'state': 'New South Wales'}\n>>> for key, value in my_dict.items():\n...     print('{}: {}'.format(key.title(), value))\n...\nJob: Developer\nName: Dennis\nAge: 24\nState: New South Wales\n`}</code></pre>\n    <p>{`Create a function named combo() that takes two iterables and returns a list of tuples. Each tuple should hold the first item in each list, then the second set, then the third, and so on. Assume the iterables will be the same length.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`def combo(iter1, iter2):\n    ret = []\n    length = len(iter1)\n    counter = 0\n    while counter < length:\n        ret.append((iter1[counter],iter2[counter]))\n        counter += 1\n    return ret\n\n# better alternatives\n\ndef combo(iterable_1, iterable_2):\n  list_of_tuples = []\n  for index in range(len(iterable_1)):\n    list_of_tuples.append((iterable_1[index], iterable_2[index]))\n\n  return list_of_tuples\n\ndef combo(iterable_1, iterable_2):\n  list_of_tuples = []\n  for index, item2 in enumerate(iterable_2):\n    list_of_tuples.append( (iterable_1[index], item2) )\n\n  return list_of_tuples\n\ndef combo(iterable_1, iterable_2):\n  return list(zip(iterable_1, iterable_2))\n\ndef combo(iter1, iter2):\n  combo_list = []\n  for index, value in enumerate(iter1):\n    tuple = value, iter2[index]\n    combo_list.append(tuple)\n  return combo_list\n`}</code></pre>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "]}]}