(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{"./manual/COMP3520-OS/Pthread.md":function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return d});var n=a("./node_modules/react/index.js"),o=a.n(n),r=a("./node_modules/@mdx-js/tag/dist/index.js");function m(e){return(m="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}function c(e,t){for(var a=0;a<t.length;a++){var n=t[a];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function s(e,t){return!t||"object"!==m(t)&&"function"!==typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function p(e,t){return(p=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var d=function(e){function t(e){var a;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),(a=s(this,l(t).call(this,e))).layout=null,a}var a,n,m;return function(e,t){if("function"!==typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&p(e,t)}(t,o.a.Component),a=t,(n=[{key:"render",value:function(){var e=this.props,t=e.components;i(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:t},o.a.createElement(r.MDXTag,{name:"h1",components:t,props:{id:"pthreads"}},"Pthreads"),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"pthreads-api"}},"Pthreads API"),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Defined in the ANSI/IEEE Posix 1003.1 - 1995 standard"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Subroutines comprise the Pthreads API can be informally grouped into three major classes:")),o.a.createElement(r.MDXTag,{name:"ol",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Thread management"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Mutexes "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Condition variables")),o.a.createElement(r.MDXTag,{name:"h1",components:t,props:{id:"1-thread-management"}},"1: Thread Management"),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"first class of functions work directly on threads - creating, detatching, joining etc "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"also include funcs to set/query thread attributes (joinable, scheduling etc)")),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Create Threads")),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"initially, single default thread - others must be explicitly created")),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{}},"pthread_create(thread, attr, startRoutine, arg)\n// thread - unique identifier for the new thread (pthread_t)\n// attr - attr object used to set thread attributes (pthread_attr) - you can specify a thread attributes object, or NULL for the default values\n// startRoutine - C routine that the thread will execute \n// arg - single arg that may be passed to startRoutine - it must be passed by reference (pointer to struct) and NULL may be used if no arg is to be passed\n\n/*\n    If successful, the pthread_create() function shall return zero; otherwise, an error number shall be returned to indicate the error\n */\n")),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Thread Attributes")),o.a.createElement(r.MDXTag,{name:"p",components:t},"By default, a thread is created with certain attributes."),o.a.createElement(r.MDXTag,{name:"p",components:t},"pthread_attr_init(attr) and pthread_attr_destroy(attr) are used to initialize/destroy the thread attribute object."),o.a.createElement(r.MDXTag,{name:"p",components:t},"Other routines are then used to query/set specific attributes in the thread attribute object."),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Terminating Thread")),o.a.createElement(r.MDXTag,{name:"ol",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Thread makes call to the pthread_exit() subroutine "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Thread is cancelled by another thread via pthread_cancel() routine "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Entire process is terminated due to call to exit subroutine ")),o.a.createElement(r.MDXTag,{name:"p",components:t},"Routine: ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_exit(status)")),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"used to explicitly exit the thread"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"programmer may optionalyl specify a termination status, which is stored as a void pointer for any thread that may join the calling thread")),o.a.createElement(r.MDXTag,{name:"p",components:t},"Cleanup: ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_exit()")," does not close files; any files opened inside the thread will remain open after the thread is terminated."),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Example")),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},'#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define NUM_THREADS 5\n\nvoid *PrintHello(void *threadid) {\n    int *tid;\n    tid = (int *)threadid;\n    printf("Hello World! It\'s me, thread #%d!\n", *tid);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t threads[NUM_THREADS];\n    int rc, t, tids[NUM_THREADS];\n    for (t=0; t< NUM_THREADS; t++) {\n        printf("In main: creating thread %d\n", t);\n        tids[t] = t;\n        rc = pthread_create(&threads[t], NULL, PrintHello, (void *)&tids[t]);\n\n        if (rc) {\n            printf("ERROR; return code from pthread_create() is %d\n", rc);\n            exit(-1);\n        }\n    }\n    pthread_exit(NULL); \n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"passing-arguments-to-threads"}},"Passing Arguments to Threads"),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_create()")," routine permits the programmer to pass one argument to the thread start routine."),o.a.createElement(r.MDXTag,{name:"p",components:t},"For cases where multiple args must be passed, we can create a struct and use the reference pointer as an arg."),o.a.createElement(r.MDXTag,{name:"p",components:t},"All args passed by reference must be cast to (void *)"),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},"struct two_args {\n    int arg1;\n    int arg2;   \n};\n\nvoid *needs_2_args(void *ap) {\n    struct two_args *argp;\n    int a1, a2;\n\n    argp = (struct two_args *) ap;\n\n    // do stuff here\n    \n    a1 = argp->arg1;\n    a2 = argp->arg2;\n    \n    // do stuff here \n\n    free(argp);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t t;\n    struct two_args *ap;\n    int rc;\n\n    // do stuff here \n\n    ap = (struct two_args *)malloc(sizeof(struct two_args));\n    ap->arg1 = 1;\n    ap->arg2 = 2;\n    rc = pthread_create(&t, NULL, needs_2_args, (void *) ap);\n\n    // do stuff here \n\n    pthread_exit(NULL);\n}\n")),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"joining-and-detatching-threads"}},"Joining and Detatching Threads"),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Routines")),o.a.createElement(r.MDXTag,{name:"ol",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"pthread_join(threadid, status)"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"pthread_detach(threadit, status)"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"pthread_attr_setdatachstate(attr, detachstate)"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"pthread_attr_getdetachstate(attr, detachstate)")),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},'"joining" is one way to accomplish synchronization between threads'),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_join()")," subroutine blocks the calling thread until the specified threadid thread terminates"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"The programmer is able to obtain the target thread's termination return status if it was specified in the target thread's call to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_exit()")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"When a thread if created, one of its attributes defines whether it is joinable or detached."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Only threads that are create as joinable can be joined.")),o.a.createElement(r.MDXTag,{name:"p",components:t},"To explicitly create a thread as joinable or detached, the attr argument in the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_create()")," routine is used:"),o.a.createElement(r.MDXTag,{name:"ol",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Declare a pthread attribute ariable of the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_attr_t data")," type "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Initialize the attribute ariable with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_attr_init()")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Set the attribute detached status with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_attr_setdetachedstate()")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"When done, ree library resources used by the attribute with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_attr_destroy()"))),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Example")),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},'void *BusyWork(void *null) {\n    // do stuff \n    pthread_exit((void *) 0);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_attr_t attr;\n    int rc, t;\n    void *status;\n\n    /* init and set thread detached attribute */\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    /* free attribute and wait for the other threads */\n    pthread_attr_destory(&attr);\n    for (t=0; t< NUM_THREADS; t++) {\n        rc = pthread_join(thread[t], &status);\n        // do stuff \n        printf("Completed join with thred %d status = %ld\n", t, (long)status);\n    }\n    pthread_exit(NULL);\n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"syncronisation-issues"}},"Syncronisation Issues"),o.a.createElement(r.MDXTag,{name:"p",components:t},"When multiple threads attempt to manipulate the same data item, the results can often be incoherent if proper care is not take ie. race conditions."),o.a.createElement(r.MDXTag,{name:"h1",components:t,props:{id:"2-mutexes"}},"2: Mutexes"),o.a.createElement(r.MDXTag,{name:"p",components:t},'The second class of functions deal with synchronization - called a "mutex", which is an abbreviation for mutual exclusion.'),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"creating-and-destroying-mutexes"}},"Creating and Destroying Mutexes"),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"routines"}},"Routines"),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_init(mutex, attr)"),o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_destroy(mutex)"),o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutexattr_init(attr)"),o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutexattr_destroy(attr)")),o.a.createElement(r.MDXTag,{name:"p",components:t},"A mutex must be declared with type ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_t"),", and must be initialized before they can be used."),o.a.createElement(r.MDXTag,{name:"p",components:t},"There are two ways to init a mutex variable:\n1. Statically, when declared eg ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER"),"\n2. Dynamically, with the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_init()")," routine. This method permits setting mutex object attributes, ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"attr")," (which my be specified as NULL to accept defaults)."),o.a.createElement(r.MDXTag,{name:"p",components:t},"The mutex is initially unlocked."),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"locking--unlocking-mutexes"}},"Locking & Unlocking Mutexes"),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"routines-1"}},"Routines"),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_lock(mutex)"),o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_unlock(mutex)"),o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_mutex_trylock(mutex)")),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_mutex_lock(mutex)")," will lock the specified mutex"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_mutex_unlock(mutex)")," will unlock a mutex if called by the owning thread\n- throws an error if already unlocked or owned by another thread"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_mutex_trylock(mutex)"),' will attempt to lock a mutex, however if the mutex is already locked it will return a "EBUSY" error code.\n- May be useful to prevent deadlocks!')),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Example 1")),o.a.createElement(r.MDXTag,{name:"p",components:t},"We can now write our previously incorrect code segment as..."),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},"pthread_mutex_t min_value_lock;\n\nmain() {\n    ...\n    pthread_mutex_init(&min_value_lock, NULL);\n    ...\n}\n\nvoid *find_min(void *list_ptr) {\n    ...\n    pthread_mutex_lock(&min_value_lock);\n    if (my_cost < best_cost) {\n        best_cost = my_cost;\n    }   \n    pthread_mutex_unlock(&min_value_lock);\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Example 2")),o.a.createElement(r.MDXTag,{name:"p",components:t},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"producer-consumer")," scenario imposes the following constraints:"),o.a.createElement(r.MDXTag,{name:"ol",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"The producer thread must not overwrite the shared buffer when the previous task has no been picked up by a consumer thread."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"The consumer threads must not pick up tasks until there is something present in the shared data structure."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ol"},"Individual consumer threads should pick up tasks one at a time.")),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},"pthread_mutex_t task_queue_lock;\nint task_available;\n\nmain() {\n    task_available = 0;\n    pthread_mutex_init(&task_queue_lock, NULL);\n}\n\nvoid *producer(void *producer_thread_data) {\n    ...\n    while (!done()) {\n        inserted = 0;\n        create_task(&my_task);\n        while (inserted == 0) {\n            pthread_mutex_lock(&task_queue_lock);\n            if (task_available == 0) {\n                insert_into_queue(my_task);\n                task_available = 1;\n                inserted = 1;\n            }\n            pthread_mutex_unlock(&task_queue_lock);\n        }\n    }\n}\n\nvoid *consumer(void *consumer_thread_data) {\n    ...\n    while (!done()) {\n        extracted = 0;\n        while (extracted == 0) {\n            pthread_mutex_lock(&task_queue_lock);\n            if (task_available == 1) {\n                extract_from_queue(&my_task);\n                task_available = 0;\n                extracted = 1;\n            }\n            pthread_mutex_unlock(&task_queue_lock);\n        }\n        process_task(my_task);\n    }\n}\n")),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"overheads-of-locking"}},"Overheads of Locking"),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Locks represent serialization points since critical sections must be executed by threads one after another."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Encapsulating large segments of the program within locks can lead to significant performance degradation."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"It is often possible to reduce the idling overhead associated with locks using ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_mutex_trylock"),".")),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Alleviating Locking Overhead")),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},"pthread_mutex_t tryLock_lock = PTHREAD_MUTEX_INITIALIZER;\n\nlock_status = pthread_mutex_trylock(&tryLock_lock)\nif (lock_status == EBUSY) {\n    /* do something else */\n    ...\n} else {\n    /* do one thing */\n    ...\n    pthread_mutex_unlock(&tryLock_lock);\n}\n")),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"monitors"}},"Monitors"),o.a.createElement(r.MDXTag,{name:"p",components:t},"Mutexes provide powerful sync tools, but..."),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"lock() and unlock() are scatteed among several threads, therefore it is difficult to understand their effects"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"usage must be correct in all the threads "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"one bad thread (or one programming error) can kill the whole system")),o.a.createElement(r.MDXTag,{name:"p",components:t},"A ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"monitor")," is a high-level abstraction that may provide a convenient and effective mechanism for thread synchronization."),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"local data variables are accessible only by the monitor "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"thread enters monitor by invoking one of its procedures "),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"only one thread may be executing in a the monitor at a time")),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Monitor and Condition Variables")),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Monitor does not need to code certain sync constraints explicitly."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"However, it is not sufficiently powerful for modeling some other synchronization schemes."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"An additional sync mechanism ie ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"condition variable")," is required.")),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"Condition Variables")),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"The third class of functions address communications between threads that share a mutex"),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"A condition variable allows a thread to block itself until specified data reaches a predefined state."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"A condition variable indicates an event and has no value\n- One cannot store a value into nor retrieve a value from a condition variable.\n- If a thread must wait for an event to occur, that tread waits on the corresponding condition variable.\n- A condition variable has a queue for those threads that are waiting the corresponding event to occur to wait on.\n- If another thread causes the event to occur, that thread simply signal the corresponding condition variable."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"This class includes funcs to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"create"),", ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"destroy"),", ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"wait")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"signal")," based on specified variable values."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Funcs to set/quey cond variable attrs are also included."),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Cond variable is always used in conjunction with a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"mutex lock"))),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"create--destroying-cond-variables"}},"Create & Destroying Cond Variables"),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"routines-2"}},"Routines"),o.a.createElement(r.MDXTag,{name:"p",components:t},"pthread_cond_init(condition, attr)\npthread_cond_destroy(condition)\npthread_condattr_init(attr)\npthread_condattr_destroy(attr)"),o.a.createElement(r.MDXTag,{name:"p",components:t},"Condition variables must be declared with type ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_cont_t"),", and must be initialized before they can be used."),o.a.createElement(r.MDXTag,{name:"p",components:t},"2 Ways to declare:\n1. Statically\n2. Dynamically "),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"waiting-and-signaling-on-condition-variable"}},"Waiting and Signaling on Condition Variable"),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_cond_signal()")," is used to signal (or wake up) another thread which is waiting on the condition variable and should be called after the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"mutex")," is locked."),o.a.createElement(r.MDXTag,{name:"p",components:t},"It must unlock ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"mutex")," in order for ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_cond_wait()")," routine to complete."),o.a.createElement(r.MDXTag,{name:"p",components:t},o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"pthread_cond_broadcast()")," routine unlocks all of the threads blocked on the condition variable."),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},"Proper locking and unlocked of mutex is essential for these routines\n- Failing to lock may cause it NOT to block\n- Failing to unlock the mutex may not allow a matching ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"li"},"pthread_cond_wait()")," routine to complete (it will remain blocked)")),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"producer-consumer-using-condition-variables"}},"Producer-Consumer Using Condition Variables"),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-c"}},"pthread_cond_t cond_queue_empty, cond_queue_full;\npthread_mutex_t task_queue_cond_lock;\nint task_available;\n// other data structures here \n\nmain() {\n    // declarations and initializations \n    task_available = 0;\n    pthread_cond_init(&cond_queue_empty, NULL);\n    pthread_cond_init(&cond_queue_full, NULL);\n    pthread_mutex_init(&task_queue_cond_lock, NULL);\n    // create and join producer and consumer threads\n}\n\nvoid *producer(void *producer_thread_data) {\n    while(!done()) {\n        create_task();\n        pthread_mutex_lock(&task_queue_cond_lock);\n        \n        while (task_available == 1) {\n            pthread_cond_wait(&cond_queue_empty,\n                &task_queue_cond_lock);\n        }\n\n        insert_into_queue();\n        task_available = 1;\n        pthread_cond_signal(&cond_queue_full);\n        pthread_mutex_unlock(&task_queue_cond_lock);\n    }\n}\n\nvoid *consumer(void *consumer_thread_data) {\n    while(!done()) {\n        pthread_mutex_lock(&task_queue_cond_lock);\n        while (task_available == 0) {\n            pthread_cond_wait(&cond_queue_full,\n                &task_queue_cond_lock);\n        }\n\n        my_task = extract_from_queue();\n        task_available = 0;\n        pthread_cond_signal(&cond_queue_empty);\n        pthread_mutex_unlock(&task_queue_cond_lock);\n        process_task(my_task);\n    }\n}\n")))}}])&&c(a.prototype,n),m&&c(a,m),t}();d.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-com-p3520-os-pthread.305817e8304de77c75ce.js.map