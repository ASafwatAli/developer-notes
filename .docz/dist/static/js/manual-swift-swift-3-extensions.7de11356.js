(window.webpackJsonp=window.webpackJsonp||[]).push([[231],{"./manual/Swift/Swift-3-Extensions.md":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return u});var a=t("./node_modules/react/index.js"),o=t.n(a),r=t("./node_modules/@mdx-js/tag/dist/index.js");function s(e){return(s="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}function m(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function c(e,n){return!n||"object"!==s(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function p(e){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function l(e,n){return(l=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var u=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=c(this,p(n).call(this,e))).layout=null,t}var t,a,s;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&l(e,n)}(n,o.a.Component),t=n,(a=[{key:"render",value:function(){var e=this.props,n=e.components;i(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"swift-3-extensions"}},"Swift 3 Extensions"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#swift-3-extensions"}},"Swift 3 Extensions"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#extensions"}},"Extensions"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#-----computed-properties"}},"---- Computed Properties")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#-----mutating-instance-methods"}},"---- Mutating Instance Methods")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#-----subscripts"}},"---- Subscripts")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#-----nested-types"}},"---- Nested Types"))))))),o.a.createElement(r.MDXTag,{name:"hr",components:n}),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"extensions"}},"Extensions"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Extensions add new functionality to an existing class, structure, enumeration, or protocol type."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This includes the ability to extend types for which you do not have access to the original source code (known as retroactive modeling). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions do not have names.)"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Extensions in Swift can:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Add computed instance properties and computed type properties"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Define instance methods and type methods"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Provide new initializers"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Define subscripts"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Define and use new nested types"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Make an existing type conform to a protocol")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"extension SomeType: SomeProtocol, AnotherProtocol {\n    // implementation of protocol requirements goes here\n}\n")),o.a.createElement("div",{id:"computed"}),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"-----computed-properties"}},"---- Computed Properties"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"struct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nlet defaultRect = Rect()\nlet memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n                      size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Extensions can add new instance methods and type methods to existing types. The following example adds a new instance method called repetitions to the Int type:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'extension Int {\n    func repetitions(task: () -> Void) {\n        for _ in 0..<self {\n            task()\n        }\n    }\n}\n\n3.repetitions {\n    print("Hello!")\n}\n// Hello!\n// Hello!\n// Hello!\n')),o.a.createElement("div",{id:"mutating"}),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"-----mutating-instance-methods"}},"---- Mutating Instance Methods"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"extension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt is now 9\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"-----subscripts"}},"---- Subscripts"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Extensions can add new subscripts to an existing type. This example adds an integer subscript to Swift\u2019s built-in Int type. This subscript ","[n]"," returns the decimal digit n places in from the right of the number:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"123456789[0] returns 9\n123456789[1] returns 8\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"extension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n        for _ in 0..<digitIndex {\n            decimalBase *= 10\n        }\n        return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n\n746381295[9]\n// returns 0, as if you had requested:\n0746381295[9]\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"-----nested-types"}},"---- Nested Types"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Extensions can add new nested types to existing classes, structures, and enumerations:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'extension Int {\n    enum Kind {\n        case negative, zero, positive\n    }\n    var kind: Kind {\n        switch self {\n        case 0:\n            return .zero\n        case let x where x > 0:\n            return .positive\n        default:\n            return .negative\n        }\n    }\n}\n\n// The nested enumeration can now be used with any Int value:\n\nfunc printIntegerKinds(_ numbers: [Int]) {\n    for number in numbers {\n        switch number.kind {\n        case .negative:\n            print("- ", terminator: "")\n        case .zero:\n            print("0 ", terminator: "")\n        case .positive:\n            print("+ ", terminator: "")\n        }\n    }\n    print("")\n}\nprintIntegerKinds([3, 19, -27, 0, -6, 0, 7])\n// Prints "+ + - 0 - 0 + "\n')))}}])&&m(t.prototype,a),s&&m(t,s),n}();u.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-swift-swift-3-extensions.305817e8304de77c75ce.js.map