(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{"./manual/Machine-Learning/CL-Logistic-Regression.md":function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return g});var a=n("./node_modules/react/index.js"),o=n.n(a),r=n("./node_modules/@mdx-js/tag/dist/index.js");function i(e){return(i="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}function p(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function m(e,t){return!t||"object"!==i(t)&&"function"!==typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var g=function(e){function t(e){var n;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),(n=m(this,l(t).call(this,e))).layout=null,n}var n,a,i;return function(e,t){if("function"!==typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&c(e,t)}(t,o.a.Component),n=t,(a=[{key:"render",value:function(){var e=this.props,t=e.components;s(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:t},o.a.createElement(r.MDXTag,{name:"h1",components:t,props:{id:"classification-logistic-regression"}},"Classification: Logistic Regression"),o.a.createElement(r.MDXTag,{name:"ul",components:t},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#classification-logistic-regression"}},"Classification: Logistic Regression"),o.a.createElement(r.MDXTag,{name:"ul",components:t,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#logistic-regression-intuition"}},"Logistic Regression Intuition"),o.a.createElement(r.MDXTag,{name:"ul",components:t,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#the-scientific-approach"}},"The scientific approach")))),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#implementation-in-python"}},"Implementation in Python"),o.a.createElement(r.MDXTag,{name:"ul",components:t,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#fitting-the-logistic-regression-model-to-the-training-set"}},"Fitting the logistic regression model to the Training Set")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#checking-the-fit-predictions-using-the-confusion-matrix"}},"Checking the fit predictions using the Confusion Matrix")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#visualising-the-predictive-power-using-a-graph"}},"Visualising the predictive power using a graph")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#how-do-we-interpret-the-graph"}},"How do we interpret the graph?")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#what-is-the-point-of-the-classifiers"}},"What is the point of the classifiers?")),o.a.createElement(r.MDXTag,{name:"li",components:t,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:t,parentName:"li",props:{href:"#checking-the-results-when-applied-to-the-test-set"}},"Checking the results when applied to the Test Set"))))))),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"logistic-regression-intuition"}},"Logistic Regression Intuition"),o.a.createElement(r.MDXTag,{name:"p",components:t},"This section can be quite difficult - there will be some ",o.a.createElement(r.MDXTag,{name:"strong",components:t,parentName:"p"},"math"),"."),o.a.createElement(r.MDXTag,{name:"p",components:t},"We know about ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"linear regression"),", ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"multiple linear regression")," etc. (DV on y, IV on x)."),o.a.createElement(r.MDXTag,{name:"p",components:t},"What happens if we classify things along a graph? Eg. 0 and 1 on the y axis and age on the x axis. This one is very black and white, but at the same time we can intuitive see some correlation."),o.a.createElement(r.MDXTag,{name:"p",components:t},"In the example given above, we wouldn't use a linear model (as you could imagine). How about instead, you were able throw in probabilies between 0 and 1. The could be a probability between the x intercept and the y-intecept at x","[hat]",". You could interpret the above and below 100% and 0% respectively. This would be a VERY basic but sensicle attempt to describe the model."),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"the-scientific-approach"}},"The scientific approach"),o.a.createElement(r.MDXTag,{name:"p",components:t},"If we take the linear ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"y = b[0] + b[1]*x")," and take that into the sigmoid function ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"p = 1 / (1 + pow(e, -y))")," and then we through that into ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"ln(p/(1-p)) = b[0] + b[1]*x")," then we can get the y. Therefore the last equation is the one for logistical regression."),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{}},"# MAIN FORMULA\nln(p/(1-p)) = b[0] + b[1]*x\n")),o.a.createElement(r.MDXTag,{name:"p",components:t},"Based on the above formula and plugging in the example data, we will get the best fitting line."),o.a.createElement(r.MDXTag,{name:"p",components:t},"If we now take any particular ages along the x axis of ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"20, 30, 40, 50")," etc, we can then find y","[hat]"," to get the predicted value that it will be a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"1")," or ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"0")," - the higher the probability, the higher the chance of a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"1"),". Any probability that is less than 0.5 is ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"projected down")," whereas anything else is ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"projected up"),"."),o.a.createElement(r.MDXTag,{name:"p",components:t},"After applying to model, we can start drawing conclusions."),o.a.createElement(r.MDXTag,{name:"h2",components:t,props:{id:"implementation-in-python"}},"Implementation in Python"),o.a.createElement(r.MDXTag,{name:"p",components:t},"Using our standard setup, we want to predict whether or not we can get a correlation between the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"purchase")," of something using their ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"age")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"salary"),"."),o.a.createElement(r.MDXTag,{name:"p",components:t},"For accurate predictions, we do use feature scaling and we will also create a classification test and training set."),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-python"}},"# Data Preprocessing Template\n\n# Importing the libraries\nimport sys, json\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# send() for Node.js Python Shell lib\ndef send(arg, type = 0):\n    if type == 1:\n        print json.dumps(json.loads(arg))\n    elif type == 2:\n        print arg\n    else:\n        print json.dumps(arg)\n\n# Importing the dataset\ndataset = pd.read_csv('data/Social_Network_Ads.csv')\n# We jut want the estimate of purchase using the Age and Estimated Salary\nX = dataset.iloc[:, 2:4].values\ny = dataset.iloc[:, 4].values\n\nsend(X.tolist());\nsend(y.tolist());\n\n# Splitting the dataset into the Training set and Test set\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)\n\n# Feature Scaling\nfrom sklearn.preprocessing import StandardScaler\n# we use this here for accurate predicition\nsc_X = StandardScaler()\nX_train = sc_X.fit_transform(X_train)\nX_test = sc_X.fit_transform(X_test)\n\nsend(X_train.tolist());\n")),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"fitting-the-logistic-regression-model-to-the-training-set"}},"Fitting the logistic regression model to the Training Set"),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-python"}},"# Fitting Logistic Regression to the Training Set\n# Create the Regressor\nfrom sklearn.linear_model import LogisticRegression\nclassifier = LogisticRegression(random_state=0)\nclassifier.fit(X_train, y_train)\n")),o.a.createElement(r.MDXTag,{name:"p",components:t},"In order to make a prediction on the X_test:"),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-python"}},"# y_pred will be the vector of predictions\ny_pred = classifier.predict(X_test)\nsend(y_pred.tolist())\n")),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"checking-the-fit-predictions-using-the-confusion-matrix"}},"Checking the fit predictions using the Confusion Matrix"),o.a.createElement(r.MDXTag,{name:"p",components:t},"We do this by making a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"Confusion Matrix"),"."),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-python"}},'# Create the confusion matrix\nfrom sklearn.metrics import confusion_matrix\ncm = confusion_matrix(y_test, y_pred);\nsend("\nConfusion Matrix")\nsend(cm.tolist())\n')),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"visualising-the-predictive-power-using-a-graph"}},"Visualising the predictive power using a graph"),o.a.createElement(r.MDXTag,{name:"p",components:t},"There is a lot of code required to visualise this:"),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-python"}},"# Visualising the Training Set results\nfrom matplotlib.colors import ListedColormap\nX_set, y_set = X_train, y_train\nX1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),\n                    np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))\nplt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),\n            alpha = 0.75, cmap = ListedColormap(('red', 'green')))\nplt.xlim(X1.min(), X1.max())\nplt.ylim(X2.min(), X2.max())\nfor i, j in enumerate(np.unique(y_set)):\n    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],\n            c = ListedColormap(('red', 'green'))(i), label = j)\nplt.title('Logistical Regression Training Set')\nplt.xlabel('Age')\nplt.ylabel('Estimated Salary')\n# plt.savefig('logistical-regression.png')\nplt.show()\nplt.close()\n")),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"how-do-we-interpret-the-graph"}},"How do we interpret the graph?"),o.a.createElement(r.MDXTag,{name:"p",components:t},"The red points are the training set observations for when the IV purchased = 0, and 1 for green."),o.a.createElement(r.MDXTag,{name:"p",components:t},"In our example, red did not buy the SUV, green are those who did."),o.a.createElement(r.MDXTag,{name:"p",components:t},"Given the x,y axis, those with the lower salary who also didn't have red are also those who didn't but the SUV. We can see those with the higher salaries are more likely to have bought the SUV."),o.a.createElement(r.MDXTag,{name:"p",components:t},"Another observation is that the older above the average even with the lower salary were more likely to buy the SUV."),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"what-is-the-point-of-the-classifiers"}},"What is the point of the classifiers?"),o.a.createElement(r.MDXTag,{name:"p",components:t},"The goal is to classify the right users into the right categories. We do this by plotting the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"prediction regions")," - in the case of the graph, it's the red prediction and the green region is where the classifier does by the SUV."),o.a.createElement(r.MDXTag,{name:"p",components:t},"The data point is the result, the region is the estimate."),o.a.createElement(r.MDXTag,{name:"p",components:t},"When we have a linear classifier, the boundary will always be a straight line."),o.a.createElement(r.MDXTag,{name:"h3",components:t,props:{id:"checking-the-results-when-applied-to-the-test-set"}},"Checking the results when applied to the Test Set"),o.a.createElement(r.MDXTag,{name:"p",components:t},"The results that we can see from this actually come from the same confusion matrix that we saw before."),o.a.createElement(r.MDXTag,{name:"pre",components:t},o.a.createElement(r.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-python"}},"# Visualising the Test Set results\nfrom matplotlib.colors import ListedColormap\nX_set, y_set = X_test, y_test\nX1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),\n                    np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))\nplt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),\n            alpha = 0.75, cmap = ListedColormap(('red', 'green')))\nplt.xlim(X1.min(), X1.max())\nplt.ylim(X2.min(), X2.max())\nfor i, j in enumerate(np.unique(y_set)):\n    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],\n            c = ListedColormap(('red', 'green'))(i), label = j)\nplt.title('Logistical Regression Test Set')\nplt.xlabel('Age')\nplt.ylabel('Estimated Salary')\n# plt.savefig('logistical-regression.png')\nplt.legend()\nplt.show()\nplt.close()\n")))}}])&&p(n.prototype,a),i&&p(n,i),t}();g.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-machine-learning-cl-logistic-regression.305817e8304de77c75ce.js.map