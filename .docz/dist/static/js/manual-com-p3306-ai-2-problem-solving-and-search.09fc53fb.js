(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{"./manual/COMP3306-AI/2-Problem-Solving-And-Search.md":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return g});var t=a("./node_modules/react/index.js"),o=a.n(t),m=a("./node_modules/@mdx-js/tag/dist/index.js");function r(e){return(r="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function l(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},m=Object.keys(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}function s(e,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(e,t.key,t)}}function p(e,n){return!n||"object"!==r(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function c(e){return(c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function i(e,n){return(i=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var g=function(e){function n(e){var a;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(a=p(this,c(n).call(this,e))).layout=null,a}var a,t,r;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&i(e,n)}(n,o.a.Component),a=n,(t=[{key:"render",value:function(){var e=this.props,n=e.components;l(e,["components"]);return o.a.createElement(m.MDXTag,{name:"wrapper",components:n},o.a.createElement(m.MDXTag,{name:"h1",components:n,props:{id:"problem-solving-and-search"}},"Problem Solving and Search"),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Learning Aims")),o.a.createElement(m.MDXTag,{name:"ol",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Uninformed Search: BFS, DFS, UCS and IDS "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Informed Search: Greedy Best-First")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"search-problem-formulation"}},"Search Problem Formulation"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Defined by 4 items:"),o.a.createElement(m.MDXTag,{name:"ol",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Initial state "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Goal state "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Operators = actions "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Path cost function ")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Choosing States and Actions")),o.a.createElement(m.MDXTag,{name:"p",components:n},"Real problems are too complex, to solve them we need to ",o.a.createElement(m.MDXTag,{name:"em",components:n,parentName:"p"},"abstract")," them! Simplify them by removing unnecessary details."),o.a.createElement(m.MDXTag,{name:"p",components:n},"Eg. If we need to find the path somewhere, we can ignore things such as weather, road conditions, scenary."),o.a.createElement(m.MDXTag,{name:"p",components:n},'Actions need to be suitable specified eg not "turn the steering wheel left by 5 degrees".'),o.a.createElement(m.MDXTag,{name:"p",components:n},"The ",o.a.createElement(m.MDXTag,{name:"em",components:n,parentName:"p"},"level of abstraction")," must be appropriate."),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"State = set of real states "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Action = complex combination of real actions "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Solution = set of real paths that are solutions in the real world")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"8-Queens Problem")),o.a.createElement(m.MDXTag,{name:"ol",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Incremental - stat with empty space, add 1 queen at a time "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Complete-state - start with all 8 queens and move them around ")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"For 1:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"States? Any arrangement of 0 to 8 queens "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Initial state? No queens on the board "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Operators? Add any queen to any square "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"State space? 1.8 ",o.a.createElement(m.MDXTag,{name:"em",components:n,parentName:"li"}," 10^14 states (= 64 ")," 63 ",o.a.createElement(m.MDXTag,{name:"em",components:n,parentName:"li"}," ... ")," 57)")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"For 2:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"States? Any arrangement of 0 to 8 queens, 1 in each column with no queen attacking each other"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Initial state? No queens on the board"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Operators? Place a queen in the left-most-empty column such that it is not attacked by any other queen "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"State space? 2057 states ")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"For 100-queens:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"1: 10^400 states "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"2: 10^52 states (hugh improvement but problem still not tractable)")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"searching-for-solutions"}},"Searching for solutions"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Searching the state space "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Generate a search tree starting from the initial state and applying the operators "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"We can generate a search graph - in a graph the same state can be reached rom multiple paths")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"tree-search-algorithm---pseudo-code"}},"Tree search algorithm - pseudo code"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Basic idea: offline exploration of the state space by generating successors of the explored states (i.e. exapnding states)"),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"We keep two lists:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Expanded - for nodes that have been expanded "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Fringe - for nodes that bae been generated but not expanded yet")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"nodes-vs-states"}},"Nodes vs States"),o.a.createElement(m.MDXTag,{name:"p",components:n},"A ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"node")," is different than a ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"state"),"."),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"A node:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"represents a state "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"is a data structure used in the search tree "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"includes ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"parent"),", ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"children"),", and other relevant information e.g. ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"depth")," and ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"path cost g"))),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"search-strategies"}},"Search Strategies"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"A ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"search strategy")," defines which node from the fringe is most promising and should be expanded next"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"We always keep the nodes in the fringe orded based on the search strategy and always expand the first one ")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Evaluation Critera")),o.a.createElement(m.MDXTag,{name:"table",components:n},o.a.createElement(m.MDXTag,{name:"thead",components:n,parentName:"table"},o.a.createElement(m.MDXTag,{name:"tr",components:n,parentName:"thead"},o.a.createElement(m.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Term"),o.a.createElement(m.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Definition"))),o.a.createElement(m.MDXTag,{name:"tbody",components:n,parentName:"table"},o.a.createElement(m.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Completeness"),o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"is it guaranteed to find a solution if one exists?")),o.a.createElement(m.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Optimality"),o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"is it guaranteed to find an ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"optimal (least cost path)")," solution?")),o.a.createElement(m.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Time complexity"),o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"How long does it take to find the solution? (measured as no. of generated nodes)")),o.a.createElement(m.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Space complexity"),o.a.createElement(m.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"what is the max number of nodes in memory?")))),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Time and space complexity")),o.a.createElement(m.MDXTag,{name:"p",components:n},"Measured in terms of:"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"b: max branching factor of the search tree (we can assume that it is finite)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"d: depth of the optimal (least cost) solution "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"m: maximum depth of the state space (can be finite or not finite)")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"There are two types of search methods:")),o.a.createElement(m.MDXTag,{name:"ol",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Uninformed (blind)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Informed (heuristic)")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"uninformed-blind-search-strategies"}},"Uninformed (Blind) Search Strategies"),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Uninformed strategies:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Generate children in a systematic way eg level by level, from left to right "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Know if a child node is a goal or non-goal node "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Do not know if one non-goal child is better (more promising) than another one. By contrast, informed (heuristic) search strategies know this")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"5 uninformed search strategies:")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Breadth first "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Uniform-cost "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Depth-first "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Depth-limited "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Iterative deepening")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"bfs---breadth-first-search"}},"BFS - Breadth First Search"),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"Is the first node in the fringe a goal node?\n    Yes => stop and return solution\n    No => expand it:\n        - Move it to the expanded list\n        - Generate its children and put them in the fringe in a order defined by the search strategy\n")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Properties")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Complete? Yes"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Optimal? Not optimal in general; Yes, if step cost is the same, e.g. =1"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Time? generated nodes = ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"1+b+b^2+ ... + b^d = O(b^d)"),", exponential"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Space? O(b^d) (keeps every node in memory)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Both time and space are problems as they grow exponentially with depth but space is the bigger problem!")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"ucs---uniform-cost-search"}},"UCS - Uniform Cost Search"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Complete? Yes ( if step cost>0 )"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Optimal? Yes"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Time? # nodes with g \uf0a3 cost of optimal solution O(bd)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Space? # nodes with g \uf0a3 cost of optimal solution O(bd)")),o.a.createElement(m.MDXTag,{name:"p",components:n},"UCS is equivalent to BFS if the step cost is 1 or the same"),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"dfs---depth-firth-search"}},"DFS - Depth-Firth Search"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Expands deepest unexpanded node"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Implementation: insert children at the front of the fringe Fringe: A\nExpanded: none")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"ids---iterative-deepening-searh-ids"}},"IDS - Iterative Deepening Searh (IDS)"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(m.MDXTag,{name:"p",components:n,parentName:"li"},"Sidesteps issue o choosing the best depth limit by trying all possible depth limits in turn (0, 1, 2, etc.) and applying DFS.")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(m.MDXTag,{name:"p",components:n,parentName:"li"},"Depth-limited search = DFS with depth limit l\n- i.e. it imposes a cutoff on the maximum depth")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(m.MDXTag,{name:"p",components:n,parentName:"li"},"Properties - similar to DFS\n- Complete? Yes (as the search depth is always finite)\n- Optimal? No\n- Time? 1+b^2+b^3+b^4 + ... +b^l = O(b^l)\n- Space? O(bl)"))),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Overhead of multiple expansion")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"May seem wasteful as many nodes are expanded multiple times"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"But for most problems the overhead of this multiple expansion is small!")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Common properties of IDS")),o.a.createElement(m.MDXTag,{name:"pre",components:n},o.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"b - branching factor \nd - depth of least cost solution \nm - max depth \n")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Combines the benefits of DFS and BFS"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Complete? As BFS:\n- Yes ","[DFS: yes, if m is finite; no otherwise]","* "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Optimal? As BFS:\n- No in general; Yes if step cost=1 ","[DFS: not optimal, even if step cost=1]"," *"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Time? As BFS:\n- ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"(d+1)b^0+db^1+(d-1)b^2+ ... +bd = O(b^d) [DFS: O(bm)] *")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Space? As DFS: O(bd), linear"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Where are the improvements of IDS in comparison to DFS? - in completeness, optimality and time (shown with *)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Can be modified to explore uniform-cost tree")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"informed-vs-uninformed-search"}},"Informed vs Uninformed Search"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"A search strategy defines the order of node expansion")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Uniformed")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Uninformed search strategies do not use problem specific knowledge beyond the definition of the problem, i.e. they do not use heuristic knowledge.\n- expand nodes systematically\n- know if node is goal or non-goal\n- cannot compare two non-goal nodes (do not know if one goal node is better than another)\n- typically inefficient")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Informed")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Informed search strategies use problem-specific heuristic knowledge to select the order of node expansion. They:\n- can compare non-goal nodes \u2013 they know if one non-goal node is better than another one\n- are typically more efficient")),o.a.createElement(m.MDXTag,{name:"hr",components:n}),o.a.createElement(m.MDXTag,{name:"h1",components:n,props:{id:"best-first-search"}},"Best First Search"),o.a.createElement(m.MDXTag,{name:"p",components:n},"How can informed strategies compare non-goal nodes?"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"By using domain specific knowledge to devise an evaluation function which estimates how good each node is"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"The evaluation function assigns a value to each node"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"At each step, the best node is expanded (the one with the best\nvalue)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"This is called best-first search\n- Note that we don\u2019t really know which is the best node as we use an estimate based on the evaluation function. So best-first search expands the node that appears to be the best."),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Fringe: insert children in decreasing order of desirability"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"We will study 2 best-first search algorithms: greedy and A*")),o.a.createElement(m.MDXTag,{name:"hr",components:n}),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"greedy-search-gs"}},"Greedy Search (GS)"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Uses ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h")," value as an evaluation function (h - heuristic)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(n)")," for node ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"n")," is the estimated cost from ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"n")," to a ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"goal")," node"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Eg for the Romania example we can use ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(n)=SLD(n, Bucharest)")," = straight-line distance from ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"n")," to Bucharest"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h")," value of a goal node is 0, i.e. ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(goal)=0"))),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Properties")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Complete? As DFS\n- Yes in finite spaces (if ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"m")," is finite)\n- No - fails in infinite spaces (can get stuck in a loop)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Optimal? No "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Time? O(b^m) but good heauristic can give dramatic improvement"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Space? O(b^m), keeps every node in memory")))}}])&&s(a.prototype,t),r&&s(a,r),n}();g.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-com-p3306-ai-2-problem-solving-and-search.305817e8304de77c75ce.js.map