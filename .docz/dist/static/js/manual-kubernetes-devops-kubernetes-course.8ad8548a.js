(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{"./manual/Kubernetes/Devops-Kubernetes-Course.md":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return u});var t=a("./node_modules/react/index.js"),o=a.n(t),r=a("./node_modules/@mdx-js/tag/dist/index.js");function s(e){return(s="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function m(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}function l(e,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(e,t.key,t)}}function c(e,n){return!n||"object"!==s(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function p(e){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function i(e,n){return(i=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var u=function(e){function n(e){var a;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(a=c(this,p(n).call(this,e))).layout=null,a}var a,t,s;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&i(e,n)}(n,o.a.Component),a=n,(t=[{key:"render",value:function(){var e=this.props,n=e.components;m(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"devops-kubernetes-course"}},"DevOps Kubernetes Course"),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"course-layout"}},"Course layout"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Introduction"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Kubernetes Basics"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Advanced Topics"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Administration")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"objectives"}},"Objectives"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"To understand, deploy and use Kubernetes"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"To get straight with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"containerization")," and run those containers on Kubernetes"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"To use Kubernetes as a single node and on AWS"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"To be able to run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"stateless")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"stateful")," applications on Kubernetes"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"To be able to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"administer")," Kubernetes")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"support"}},"Support"),o.a.createElement(r.MDXTag,{name:"p",components:n},"All resources are in a github repository."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"getting-started"}},"Getting Started"),o.a.createElement(r.MDXTag,{name:"p",components:n},"kubectl: Install via brew\nminikube: ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/kubernetes/minikube/releases"}},"https://github.com/kubernetes/minikube/releases"),"\nkops: Install via brew"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Minikube test commands:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"minikube status # check status\nminikube start # start cluster\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"For OSX install:"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.25.0/minikube-darwin-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Install Docker Edge to use the latest features with Kubernetes."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Otherwise follow the base instructions to get everything up and going."),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"https://gist.github.com/kevin-smets/b91a34cea662d0c523968472a81788f7")),o.a.createElement(r.MDXTag,{name:"p",components:n},"This resolves DL issue: ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mv minikube-v0.25.1.iso ~/.minikube/cache/iso/minikube-v0.25.1.iso"),"."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"procedure-document"}},"Procedure Document"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'Kubernetes Procedure Document\nGithub repository [Read this first]\nDownload all the course material from: https://github.com/wardviaene/kubernetes-course\n\nQuestions?\nSend me a message\n\nUse Q&A\n\nJoin our facebook group: https://www.facebook.com/groups/840062592768074/\n\nDownload Kubectl\nLinux: https://storage.googleapis.com/kubernetes-release/release/v1.6.1/bin/linux/amd64/kubectl\n\nMacOS: https://storage.googleapis.com/kubernetes-release/release/v1.6.1/bin/darwin/amd64/kubectl\n\nWindows:\nhttps://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe\n\nMinikube\nProject URL: https://github.com/kubernetes/minikube\n\nLatest Release and download instructions: https://github.com/kubernetes/minikube/releases\n\nVirtualBox: http://www.virtualbox.org\n\nMinikube on windows:\nDownload the latest minikube-version.exe\n\nRename the file to minikube.exe and put it in C:minikube\n\nOpen a cmd (search for the app cmd or powershell)\n\nRun: cd C:minikube and enter minikube start\n\nTest your cluster commands\nMake sure your cluster is running, you can check with minikube status.\n\nIf your cluster is not running, enter minikube start first.\n\nkubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.4 --port=8080\nkubectl expose deployment hello-minikube --type=NodePort\n\nminikube service hello-minikube --url\n\n<open a browser and go to that url>\n\nKops\nProject URL\nhttps://github.com/kubernetes/kops\n\nFree DNS Service\nSign up at http://freedns.afraid.org/\n\nChoose for subdomain hosting\n\nEnter the AWS nameservers given to you in route53 as nameservers for the subdomain\n\nhttp://www.dot.tk/ provides a free .tk domain name you can use and you can point it to the amazon AWS nameservers\n\n###h2\n\nNamecheap.com often has promotions for tld\u2019s like .co for just a couple of bucks\n\n\n\nCluster Commands\nkops create cluster --name=kubernetes.newtech.academy --state=s3://kops-state-b429b --zones=eu-west-1a --node-count=2 --node-size=t2.micro --master-size=t2.micro --dns-zone=kubernetes.newtech.academy\n\nkops update cluster kubernetes.newtech.academy --yes --state=s3://kops-state-b429b\n\nkops delete cluster --name kubernetes.newtech.academy --state=s3://kops-state-b429b\n\nkops delete cluster --name kubernetes.newtech.academy --state=s3://kops-state-b429b --yes\n\nKubernetes from scratch\n\n\n\n\n\n\nYou can setup your cluster manually from scratch\n\nIf you\u2019re planning to deploy on AWS / Google / Azure, use the tools that are fit for these platforms\n\nIf you have an unsupported cloud platform, and you still want Kubernetes, you can install it manually\n\nCoreOS + Kubernetes: ###a href="https://coreos.com/kubernetes/docs/latest/getting-started.html">https://coreos.com/kubernetes/docs/latest/getting-started.html\n\nDocker\nYou can download Docker Engine for:\n\nWindows: https://docs.docker.com/engine/installation/windows/\n\nMacOS: https://docs.docker.com/engine/installation/mac/\n\nLinux: https://docs.docker.com/engine/installation/linux/\n\nDevOps box\nVirtualbox: http://www.virtualbox.org\n\nVagrant: http://www.vagrantup.com\n\nDevOps box: https://github.com/wardviaene/devops-box\n\nLaunch commands (in terminal / cmd / powershell):\n\ncd devops-box/\n\nvagrant up\n\nLaunch commands for a plain ubuntu box:\n\nmkdir ubuntu\n\nvagrant init ubuntu/xenial64\n\nvagrant up\n\nDocker commands\nDescription\n\nCommand\n\nBuild image\n\ndocker build .\n\nBuild & Tag\n\ndocker build -t wardviaene/k8s-demo:latest .\n\nTag image\n\ndocker tag imageid wardviaene/k8s-demo\n\nPush image\n\ndocker push wardviaene/k8s-demo\n\nList images\n\ndocker images\n\nList all containers\n\ndocker ps -a\n\nKubernetes commands\nCommand\n\nDescription\n\nkubectl get pod\n\nGet information about all running pods\n\nkubectl describe pod `<pod>`\n\nDescribe one pod\n\nkubectl expose pod `<pod>` --port=444\n\n--name=frontend\n\nExpose the port of a pod (creates a new service)\n\nkubectl port-forward `<pod>` 8080\n\nPort forward the exposed pod port to your local machine\n\nkubectl attach `<podname>` -i\n\nAttach to the pod\n\nkubectl exec `<pod>` -- command\n\nExecute a command on the pod\n\nkubectl label pods `<pod>` mylabel=awesome\n\nAdd a new label to a pod\n\nkubectl run -i --tty busybox --image=busybox\n\n--restart=Never -- sh\n\nRun a shell in a pod - very useful for debugging\n\nkubectl get deployments\n\nGet information on current deployments\n\nkubectl get rs\n\nGet information about the replica sets\n\nkubectl get pods --show-labels\n\nget pods, and also show labels attached to those pods\n\nkubectl rollout status deployment/helloworld-deployment\n\nGet deployment status\n\nkubectl set image deployment/helloworld-deployment\n\nk8s-demo=k8s-demo:2\n\nRun k8s-demo with the image label version 2\n\nkubectl edit deployment/helloworld-deployment\n\nEdit the deployment object\n\nkubectl rollout status deployment/helloworld-deployment\n\nGet the status of the rollout\n\nkubectl rollout history deployment/helloworld-deployment\n\nGet the rollout history\n\nkubectl rollout undo deployment/helloworld-deployment\n\nRollback to previous version\n\nkubectl rollout undo deployment/helloworld-deployment --to-revision=n\n\nRollback to any version version\n\nAWS Commands\naws ec2 create-volume --size 10 --region us-east-1 --availability-zone us-east-1a --volume-type gp2\n\nCertificates\nCreating a new key for a new user: openssl genrsa -out myuser.pem 2048\n\nCreating a certificate request: openssl req -new -key myuser.pem -out myuser-csr.pem -subj "/CN=myuser/O=myteam/"\n\nCreating a certificate: openssl x509 -req -in myuser-csr.pem -CA /path/to/kubernetes/ca.crt -CAkey /path/to/kubernetes/ca.key -CAcreateserial -out myuser.crt -days 10000\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"what-is-kubernetes"}},"What is Kubernetes?"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Open source orchestration system for Docker."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Let's you schedule containers on a cluster of machines"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can run multiple containers on one machine"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can run long running services (like web apps)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"K8s will manage the state of these containers",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Can start the container on specific nodes"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Will restart a container when it gets killed"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Can move containers from one node to another node"))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Instead of just running a few docker containers on one host manually, K8s can manage that for you"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"K8 clusters can go to thousands of nodes"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Other orcherstrators:",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Docker Swarm"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Mesos")))),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can run K8s anywhere:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"One premise (private)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Public"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Hybrid")),o.a.createElement(r.MDXTag,{name:"p",components:n},"It is highly modular and open source. It is also backed by Google."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"containers-intro"}},"Containers intro"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Container VS VM: No Hypervisor and Guest OS layer."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Containers on Cloud Providers do still use the hypervisor to seperate users."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Docker is the most popular container software. An alternative is ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"rkt"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Benefits? It works in isolation. You ship the binary with all the dependencies and create a closer parity."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Docker makes development teams able to ship faster."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can run the same image on prem and in the cloud with what should be the same results."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"kubernetes-setup"}},"Kubernetes Setup"),o.a.createElement(r.MDXTag,{name:"p",components:n},'Something to note is that there are more integrations for certain Cloud Providers like AWS & GCE. Thingsl ike "Volumes" and "External Load Balancers" work only with support Cloud Providers.'),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"running-locally"}},"Running locally"),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"minikube")," to spin up a local single machine with a Kubernetes cluster."),o.a.createElement(r.MDXTag,{name:"h4",components:n,props:{id:"minikube"}},"Minikube"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Minikube is a tool that makes running k8s locally easy."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It runs a single-node Kubernetes cluster inside a Linux VM."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It's aimed on users who just want to just test it out or use if for development."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It cannot spin up a roduction cluster, it's a one node machine with no high availability."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You need VM to run all this."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To run a cluster, just run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"minikube start"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To check your config after spinning up Kubernetes, use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"cat ~/.kube/config"),"."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"running-on-aws"}},"Running on AWS"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Until EKS comes out, we can spin up a Kubernetes cluster using KOPS."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You need to ensure that you download Vagrant and a VM."),o.a.createElement(r.MDXTag,{name:"p",components:n},"For running the Vagrant box, you can run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"vagrant up --provider virtualbox"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can then use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"vagrant ssh")," to ssh in."),o.a.createElement(r.MDXTag,{name:"p",components:n},"After you are in, download Kops:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"curl -LO https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '\"' -f 4)/kops-linux-amd64\nchmod +x kops-linux-amd64\nsudo mv kops-linux-amd64 /usr/local/bin/kops\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Ensure that you also download ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"python-pip"),":"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"sudo apt-get install software-properties-common\nsudo apt-add-repository universe\nsudo apt-get update\nsudo apt-get install python-pip\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Then install awscli:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"export LC_ALL=C # if run into an error about locale settings\nsudo pip install awscli\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"You will then need to create an AWS account."),o.a.createElement(r.MDXTag,{name:"p",components:n},"After setting up the AWSCLI, installing Kops and creating a S3 Bucket + setting up the Route53 Name Servers (on somewhere like NameCheap), you can move on."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"cluster-setup-on-kops"}},"Cluster setup on Kops"),o.a.createElement(r.MDXTag,{name:"p",components:n},"First, download Kops for Linux on the Vagrant box and move it."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Before creating the cluster, you will need to create new keys. ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ssh-keygen -f .ssh/id_rsa"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To create the cluster (example), run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kops create cluster --name=kubernetes.test --state=s3://kops-state-oeiajrie93 --zones=ap-southeast-2a --node-count=2 --node-size=t2.micro --master-size=t2.micro --dns-zone=givemeyeezy.online")),o.a.createElement(r.MDXTag,{name:"p",components:n},"This DNS zone is basically just the one that we set up."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You'll get something back like"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'I0311 21:48:46.821364    7553 create_cluster.go:439] Inferred --cloud=aws from zone "ap-southeast-2a"\nI0311 21:48:46.821506    7553 create_cluster.go:971] Using SSH public key: /home/vagrant/.ssh/id_rsa.pub\nI0311 21:48:48.232635    7553 subnets.go:184] Assigned CIDR 172.20.32.0/19 to subnet ap-southeast-2a\nPreviewing changes that will be made:\n\nI0311 21:48:52.305360    7553 executor.go:91] Tasks: 0 done / 73 total; 31 can run\nI0311 21:48:53.503124    7553 executor.go:91] Tasks: 31 done / 73 total; 24 can run\nI0311 21:48:53.958875    7553 executor.go:91] Tasks: 55 done / 73 total; 16 can run\nI0311 21:48:54.237870    7553 executor.go:91] Tasks: 71 done / 73 total; 2 can run\nI0311 21:48:54.262347    7553 executor.go:91] Tasks: 73 done / 73 total; 0 can run\nWill create resources:\n  AutoscalingGroup/master-ap-southeast-2a.masters.kubernetes.test\n  MinSize               1\n  MaxSize               1\n  Subnets               [name:ap-southeast-2a.kubernetes.test]\n  Tags                  {k8s.io/role/master: 1, Name: master-ap-southeast-2a.masters.kubernetes.test, KubernetesCluster: kubernetes.test, k8s.io/cluster-autoscaler/node-template/label/kops.k8s.io/instancegroup: master-ap-southeast-2a}\n  LaunchConfiguration   name:master-ap-southeast-2a.masters.kubernetes.test\n\n  AutoscalingGroup/nodes.kubernetes.test\n  MinSize               2\n  MaxSize               2\n  Subnets               [name:ap-southeast-2a.kubernetes.test]\n  Tags                  {k8s.io/cluster-autoscaler/node-template/label/kops.k8s.io/instancegroup: nodes, k8s.io/role/node: 1, Name: nodes.kubernetes.test, KubernetesCluster: kubernetes.test}\n  LaunchConfiguration   name:nodes.kubernetes.test\n\n  DHCPOptions/kubernetes.test\n  DomainName            ap-southeast-2.compute.internal\n  DomainNameServers     AmazonProvidedDNS\n\n  EBSVolume/a.etcd-events.kubernetes.test\n  AvailabilityZone      ap-southeast-2a\n  VolumeType            gp2\n  SizeGB                20\n  Encrypted             false\n  Tags                  {KubernetesCluster: kubernetes.test, k8s.io/etcd/events: a/a, k8s.io/role/master: 1, Name: a.etcd-events.kubernetes.test}\n\n  EBSVolume/a.etcd-main.kubernetes.test\n  AvailabilityZone      ap-southeast-2a\n  VolumeType            gp2\n  SizeGB                20\n  Encrypted             false\n  Tags                  {k8s.io/etcd/main: a/a, k8s.io/role/master: 1, Name: a.etcd-main.kubernetes.test, KubernetesCluster: kubernetes.test}\n\n  IAMInstanceProfile/masters.kubernetes.test\n\n  IAMInstanceProfile/nodes.kubernetes.test\n\n  IAMInstanceProfileRole/masters.kubernetes.test\n  InstanceProfile       name:masters.kubernetes.test id:masters.kubernetes.test\n  Role                  name:masters.kubernetes.test\n\n  IAMInstanceProfileRole/nodes.kubernetes.test\n  InstanceProfile       name:nodes.kubernetes.test id:nodes.kubernetes.test\n  Role                  name:nodes.kubernetes.test\n\n  IAMRole/masters.kubernetes.test\n  ExportWithID          masters\n\n  IAMRole/nodes.kubernetes.test\n  ExportWithID          nodes\n\n  IAMRolePolicy/masters.kubernetes.test\n  Role                  name:masters.kubernetes.test\n\n  IAMRolePolicy/nodes.kubernetes.test\n  Role                  name:nodes.kubernetes.test\n\n  InternetGateway/kubernetes.test\n  VPC                   name:kubernetes.test\n  Shared                false\n\n  Keypair/apiserver-aggregator\n  Subject               cn=aggregator\n  Type                  client\n  Signer                name:apiserver-aggregator-ca id:cn=apiserver-aggregator-ca\n\n  Keypair/apiserver-aggregator-ca\n  Subject               cn=apiserver-aggregator-ca\n  Type                  ca\n\n  Keypair/apiserver-proxy-client\n  Subject               cn=apiserver-proxy-client\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/ca\n  Subject               cn=kubernetes\n  Type                  ca\n\n  Keypair/kops\n  Subject               o=system:masters,cn=kops\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/kube-controller-manager\n  Subject               cn=system:kube-controller-manager\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/kube-proxy\n  Subject               cn=system:kube-proxy\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/kube-scheduler\n  Subject               cn=system:kube-scheduler\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/kubecfg\n  Subject               o=system:masters,cn=kubecfg\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/kubelet\n  Subject               o=system:nodes,cn=kubelet\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/kubelet-api\n  Subject               cn=kubelet-api\n  Type                  client\n  Signer                name:ca id:cn=kubernetes\n\n  Keypair/master\n  Subject               cn=kubernetes-master\n  Type                  server\n  AlternateNames        [100.64.0.1, 127.0.0.1, api.internal.kubernetes.test, api.kubernetes.test, kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local]\n  Signer                name:ca id:cn=kubernetes\n\n  LaunchConfiguration/master-ap-southeast-2a.masters.kubernetes.test\n  ImageID               kope.io/k8s-1.8-debian-jessie-amd64-hvm-ebs-2018-01-14\n  InstanceType          t2.micro\n  SSHKey                name:kubernetes.kubernetes.test-e8:be:8d:cf:90:3b:52:6e:f7:23:29:0a:32:d1:cd:de id:kubernetes.kubernetes.test-e8:be:8d:cf:90:3b:52:6e:f7:23:29:0a:32:d1:cd:de\n  SecurityGroups        [name:masters.kubernetes.test]\n  AssociatePublicIP     true\n  IAMInstanceProfile    name:masters.kubernetes.test id:masters.kubernetes.test\n  RootVolumeSize        64\n  RootVolumeType        gp2\n  SpotPrice\n\n  LaunchConfiguration/nodes.kubernetes.test\n  ImageID               kope.io/k8s-1.8-debian-jessie-amd64-hvm-ebs-2018-01-14\n  InstanceType          t2.micro\n  SSHKey                name:kubernetes.kubernetes.test-e8:be:8d:cf:90:3b:52:6e:f7:23:29:0a:32:d1:cd:de id:kubernetes.kubernetes.test-e8:be:8d:cf:90:3b:52:6e:f7:23:29:0a:32:d1:cd:de\n  SecurityGroups        [name:nodes.kubernetes.test]\n  AssociatePublicIP     true\n  IAMInstanceProfile    name:nodes.kubernetes.test id:nodes.kubernetes.test\n  RootVolumeSize        128\n  RootVolumeType        gp2\n  SpotPrice\n\n  ManagedFile/kubernetes.test-addons-bootstrap\n  Location              addons/bootstrap-channel.yaml\n\n  ManagedFile/kubernetes.test-addons-core.addons.k8s.io\n  Location              addons/core.addons.k8s.io/v1.4.0.yaml\n\n  ManagedFile/kubernetes.test-addons-dns-controller.addons.k8s.io-k8s-1.6\n  Location              addons/dns-controller.addons.k8s.io/k8s-1.6.yaml\n\n  ManagedFile/kubernetes.test-addons-dns-controller.addons.k8s.io-pre-k8s-1.6\n  Location              addons/dns-controller.addons.k8s.io/pre-k8s-1.6.yaml\n\n  ManagedFile/kubernetes.test-addons-kube-dns.addons.k8s.io-k8s-1.6\n  Location              addons/kube-dns.addons.k8s.io/k8s-1.6.yaml\n\n  ManagedFile/kubernetes.test-addons-kube-dns.addons.k8s.io-pre-k8s-1.6\n  Location              addons/kube-dns.addons.k8s.io/pre-k8s-1.6.yaml\n\n  ManagedFile/kubernetes.test-addons-limit-range.addons.k8s.io\n  Location              addons/limit-range.addons.k8s.io/v1.5.0.yaml\n\n  ManagedFile/kubernetes.test-addons-rbac.addons.k8s.io-k8s-1.8\n  Location              addons/rbac.addons.k8s.io/k8s-1.8.yaml\n\n  ManagedFile/kubernetes.test-addons-storage-aws.addons.k8s.io-v1.6.0\n  Location              addons/storage-aws.addons.k8s.io/v1.6.0.yaml\n\n  ManagedFile/kubernetes.test-addons-storage-aws.addons.k8s.io-v1.7.0\n  Location              addons/storage-aws.addons.k8s.io/v1.7.0.yaml\n\n  Route/0.0.0.0/0\n  RouteTable            name:kubernetes.test\n  CIDR                  0.0.0.0/0\n  InternetGateway       name:kubernetes.test\n\n  RouteTable/kubernetes.test\n  VPC                   name:kubernetes.test\n\n  RouteTableAssociation/ap-southeast-2a.kubernetes.test\n  RouteTable            name:kubernetes.test\n  Subnet                name:ap-southeast-2a.kubernetes.test\n\n  SSHKey/kubernetes.kubernetes.test-e8:be:8d:cf:90:3b:52:6e:f7:23:29:0a:32:d1:cd:de\n  KeyFingerprint        c4:89:af:59:a1:1d:6e:ef:7a:9d:12:65:bc:e2:82:4f\n\n  Secret/admin\n\n  Secret/kube\n\n  Secret/kube-proxy\n\n  Secret/kubelet\n\n  Secret/system:controller_manager\n\n  Secret/system:dns\n\n  Secret/system:logging\n\n  Secret/system:monitoring\n\n  Secret/system:scheduler\n\n  SecurityGroup/masters.kubernetes.test\n  Description           Security group for masters\n  VPC                   name:kubernetes.test\n  RemoveExtraRules      [port=22, port=443, port=2380, port=2381, port=4001, port=4002, port=4789, port=179]\n\n  SecurityGroup/nodes.kubernetes.test\n  Description           Security group for nodes\n  VPC                   name:kubernetes.test\n  RemoveExtraRules      [port=22]\n\n  SecurityGroupRule/all-master-to-master\n  SecurityGroup         name:masters.kubernetes.test\n  SourceGroup           name:masters.kubernetes.test\n\n  SecurityGroupRule/all-master-to-node\n  SecurityGroup         name:nodes.kubernetes.test\n  SourceGroup           name:masters.kubernetes.test\n\n  SecurityGroupRule/all-node-to-node\n  SecurityGroup         name:nodes.kubernetes.test\n  SourceGroup           name:nodes.kubernetes.test\n\n  SecurityGroupRule/https-external-to-master-0.0.0.0/0\n  SecurityGroup         name:masters.kubernetes.test\n  CIDR                  0.0.0.0/0\n  Protocol              tcp\n  FromPort              443\n  ToPort                443\n\n  SecurityGroupRule/master-egress\n  SecurityGroup         name:masters.kubernetes.test\n  CIDR                  0.0.0.0/0\n  Egress                true\n\n  SecurityGroupRule/node-egress\n  SecurityGroup         name:nodes.kubernetes.test\n  CIDR                  0.0.0.0/0\n  Egress                true\n\n  SecurityGroupRule/node-to-master-tcp-1-2379\n  SecurityGroup         name:masters.kubernetes.test\n  Protocol              tcp\n  FromPort              1\n  ToPort                2379\n  SourceGroup           name:nodes.kubernetes.test\n\n  SecurityGroupRule/node-to-master-tcp-2382-4000\n  SecurityGroup         name:masters.kubernetes.test\n  Protocol              tcp\n  FromPort              2382\n  ToPort                4000\n  SourceGroup           name:nodes.kubernetes.test\n\n  SecurityGroupRule/node-to-master-tcp-4003-65535\n  SecurityGroup         name:masters.kubernetes.test\n  Protocol              tcp\n  FromPort              4003\n  ToPort                65535\n  SourceGroup           name:nodes.kubernetes.test\n\n  SecurityGroupRule/node-to-master-udp-1-65535\n  SecurityGroup         name:masters.kubernetes.test\n  Protocol              udp\n  FromPort              1\n  ToPort                65535\n  SourceGroup           name:nodes.kubernetes.test\n\n  SecurityGroupRule/ssh-external-to-master-0.0.0.0/0\n  SecurityGroup         name:masters.kubernetes.test\n  CIDR                  0.0.0.0/0\n  Protocol              tcp\n  FromPort              22\n  ToPort                22\n\n  SecurityGroupRule/ssh-external-to-node-0.0.0.0/0\n  SecurityGroup         name:nodes.kubernetes.test\n  CIDR                  0.0.0.0/0\n  Protocol              tcp\n  FromPort              22\n  ToPort                22\n\n  Subnet/ap-southeast-2a.kubernetes.test\n  VPC                   name:kubernetes.test\n  AvailabilityZone      ap-southeast-2a\n  CIDR                  172.20.32.0/19\n  Shared                false\n  Tags                  {Name: ap-southeast-2a.kubernetes.test, KubernetesCluster: kubernetes.test, kubernetes.io/cluster/kubernetes.test: owned, kubernetes.io/role/elb: 1}\n\n  VPC/kubernetes.test\n  CIDR                  172.20.0.0/16\n  EnableDNSHostnames    true\n  EnableDNSSupport      true\n  Shared                false\n  Tags                  {Name: kubernetes.test, KubernetesCluster: kubernetes.test, kubernetes.io/cluster/kubernetes.test: owned}\n\n  VPCDHCPOptionsAssociation/kubernetes.test\n  VPC                   name:kubernetes.test\n  DHCPOptions           name:kubernetes.test\n\nMust specify --yes to apply changes\n\nCluster configuration has been created.\n\nSuggestions:\n * list clusters with: kops get cluster\n * edit this cluster with: kops edit cluster kubernetes.test\n * edit your node instance group: kops edit ig --name=kubernetes.test nodes\n * edit your master instance group: kops edit ig --name=kubernetes.test master-ap-southeast-2a\n\nFinally configure your cluster with: kops update cluster kubernetes.test --yes\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"To edit the cluster, run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kops edit cluster kubernetes.test --state=s3://kops-state-oeiajrie93")," and then to update run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kops update cluster kubernetes.test --yes --state=s3://kops-state-oeiajrie93")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If we now run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"cat ~/.kube/config")," we can see the password and username information needed."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To check if the nodes are up, run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl get node"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Then, we can again run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl run hello-minikube ...")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you have issues hit up ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"https://www.digitalocean.com/community/tutorials/how-to-set-up-time-synchronization-on-ubuntu-16-04")," for date syncing."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"kops-quicklist"}},"KOPS QuickList"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"# create\nkops create cluster --name=doksandbox.com --state=s3://kops-state-doksandbox --zones=ap-southeast-2a --node-count=1 --node-size=t2.micro --master-size=t2.micro --dns-zone=doksandbox.com\n\n# edit\nkops edit cluster doksandbox.com --state=s3://kops-state-doksandbox\n\n# update\nkops update cluster doksandbox.com --yes --state=s3://kops-state-doksandbox\n\n# delete\nkops delete cluster doksandbox.com --yes --state=s3://kops-state-doksandbox\n\n# suggestions\nkops validate cluster --state=s3://kops-state-doksandbox  # validate cluster\nkubectl get nodes --show-labels # list nodes\nssh -i ~/.ssh/id_rsa admin@api.kubernetes.doksandbox.com # ssh to the master\nThe admin user is specific to Debian. If not using Debian please use the appropriate user based on your OS.\n\n# check DNS\ndig afxr doksandbox.com\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To get a basic service up and running, hit ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.4 --port=8080")," and head to the VPC security network to update and expose that port to all IPs to prove that is all works correctly. The port will be dynamic."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"building-docker-containers"}},"Building Docker Containers"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If installing onto Linux, check ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce-1")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To do a demo, ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sudo apt-get install git")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"git clone https://github.com/wardviaene/docker-demo")," to get a demo folder."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Change in, ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sudo docker build .")," and then to run the container use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"docker run -p 3000:3000 -t <id>")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"docker-registery"}},"Docker registery"),o.a.createElement(r.MDXTag,{name:"p",components:n},"To upload to the registry:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"docker login # fill in login details\ndocker tag imageid okeeffed/docker-demo\ndocker push okeeffed/docker-demo\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are a few limitations for each Docker/Kubernetes relationship:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Don't try to create one giant docker image fo you app, but split it up if necessary."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"All data in the container is not preserved. You need volumes for this."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Check 12factor.net for methodologies")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"running-the-docker-app-on-kubernetes"}},"Running the Docker app on Kubernetes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"We need to create a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"pod definition"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This describes an application running on Kubernetes."),o.a.createElement(r.MDXTag,{name:"p",components:n},"A pod can container ",o.a.createElement(r.MDXTag,{name:"em",components:n,parentName:"p"},"one or more tightly coupled containers")," that make up the app."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Those apps can easily communicate with each other using their local ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"port numbers"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The app for us at the moment has only one container."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To build this, we create a podfile with all the pod definition:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  containers:\n  - name: k8s-demo\n    image: okeeffed/docker-demo\n    ports:\n    - containerPort: 3000\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To create this pod, we run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl create -f ./pod-helloworld.yml")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Some useful commands")),o.a.createElement(r.MDXTag,{name:"table",components:n},o.a.createElement(r.MDXTag,{name:"thead",components:n,parentName:"table"},o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"thead"},o.a.createElement(r.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Command"),o.a.createElement(r.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Description"))),o.a.createElement(r.MDXTag,{name:"tbody",components:n,parentName:"table"},o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl get pod"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get info about all running pods")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl describe pod ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"<pod>")),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Describe one pod")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl expose pod ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"<pod>")," --port=444 --name=frontend"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Expose the port of a pod (creates a new service)")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl port-forward ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"<pod>")," 8080"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Port forward the local machine")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl attach ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"<podname>")," -i"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Attach to pod")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl exec ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"<pod>")," -- command"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Execute a command on the pod")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl label pods ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"td"},"<pod>")," mylabel=awesome"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Add new label to pod")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl run -i -tty busybox --image=busybox --restart=Never -- sh"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Run a shell in a pod - very useful for debugging")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"how-to-port-forward"}},"How to port-forward"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Running ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl describe pod nodehelloworld.example.com")," will then give us info on what is going on here."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To listen locally, we can port-forward: ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl port-forward nodehelloworld.example.com 8081:3000")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"exposing-the-pod"}},"Exposing the pod"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl expose pod nodehelloworld.example.com --type=NodePort --name nodehelloworld-service")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Check this with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl get service")),o.a.createElement(r.MDXTag,{name:"p",components:n},"When you see what port is being forwarded, you can again open that up on the security settings and direct to that port."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"setting-up-the-external-load-balancer"}},"Setting up the external load balancer"),o.a.createElement(r.MDXTag,{name:"p",components:n},"This will allow the outside world to have traffic routed to the correct pod."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To create the service for this:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: v1\nkind: Service\nmetadata:\n  name: helloworld-service\nspec:\n  ports:\n  - port: 80\n  targetPort: nodejs-port\n  protocol: TCP\n  selector:\n  app: helloworld\n  type: LoadBalancer\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Using ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl create -f <file>")," will create the pods and kops will autoconfigure what is required."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"kubernetes-basics"}},"Kubernetes Basics"),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"node-architecture"}},"Node Architecture"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Within each node can be a collection of pods routed by iptables and within each pod are the Docker containers."),o.a.createElement(r.MDXTag,{name:"p",components:n},"These containers can talk easily to each other using localhost and ports."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Each node also has a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubelet")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kube-proxy"),". The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubelet")," talks to the master node and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kube-proxy")," talks to the iptables."),o.a.createElement(r.MDXTag,{name:"p",components:n},"A service itself can be like the load balancer. The service will be publicly available."),o.a.createElement(r.MDXTag,{name:"p",components:n},"When we look deeper at a pod yaml file, we have the containers called as the specs."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n    image: okeeffed/docker-demo\n    ports:\n    - containerPort: 3000\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"replication-controller"}},"Replication Controller"),o.a.createElement(r.MDXTag,{name:"h4",components:n,props:{id:"scaling"}},"Scaling"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If your application is ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"stateless")," you can horizontally scale it."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Stateless = your appllication doesn't have a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"state"),", it doesn't write any local files / keeps local sessions. This prevents pods from falling out of sync."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"All traditional databases are ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"stateful")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Most ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"web applications")," can be made stateless",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Session management needs to be done outside the container"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Any file to be saved cannot be saved locally")))),o.a.createElement(r.MDXTag,{name:"p",components:n},"If needed, you can use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"volumes")," to still run stateful apps."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Those stateful apps can't horizontally scale, but you can run them in a single container and vertically scale (allocate more CPU/Mem/Disk)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Scaling in Kubernetes can be done using the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Replication Controller"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The replication controller will ensure a specified number of pod replicas will run at all times."),o.a.createElement(r.MDXTag,{name:"p",components:n},"A pod created with the replica controller will automatically be replaced if they fail, get deleted or are terminated."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Using the replication controller is also recommended if you just want to make sure 1 pod is always running, even after reboots."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can then run a replication controller with just 1 replica to ensure that it is always running."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To create a replication controller:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# rc-helloworld.yml\napiVersion: v1\nkind: ReplicationController # Changed from Pod\nmetadata:\n  name: helloworld-container\nspec: # Replation controller also has a spec\n  replicas: 2 # set two pod replicas\n  selector:  # select the app\n  app: helloworld\n  template:\n  # stand Pod metadata and spec\n  metadata:\n    name: nodehelloworld.example.com\n    labels:\n    app: helloworld\n  spec:\n    # The containers are listed here\n    containers:\n    - name: k8s-demo\n      image: okeeffed/docker-demo\n      ports:\n      - containerPort: 3000\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"When this controller is created with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl"),", you will see that the two pods are created with a differing suffix."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Now we have horizontally scaled this pod."),o.a.createElement(r.MDXTag,{name:"p",components:n},"If one of these pods is now deleted, the master node will automatically schedule a new one."),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can also scale this by using ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl scale --replicas=4 -f <replication-controller-name.yml>"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can also use it with the following:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"kubectl get rc # get replication controllers\n# assume helloworld-controller shows up\nkubectl scale --replicas=1 rc/helloworld-container\nkubectl get pods # will show only one pod remaining\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"deployments"}},"Deployments"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Replication Set is the next gen Replication Controller:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},'It supports new selector that can do selection based on filtering according a set of values eg environment either "dev" or "qa"'),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It's not only based on equality. You can do more complex things."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This RS is used by the Deployment.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"A deployment is a declaration that allows you to do app ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"deployments")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"updates"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"When using the deployment object, you definte the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"state")," of your application. Kubernetes will then make sure the clusters matches your desired state."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Just using the replication controller or replication set might be cumbersome to deploy apps."),o.a.createElement(r.MDXTag,{name:"p",components:n},"With a deployment object you can:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create a deployment (e.g. deploying an app)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Update a deployment (e.g. new version)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Do rolling updates (zero downtime deployments)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Roll back"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Pause/resume a deployment (ie rollout to only certain percentage of pods)")),o.a.createElement(r.MDXTag,{name:"p",components:n},"An example of a deployment:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# deployment-helloworld.yml\napiVersion: extensions/v1beta1\nkind: Deployment # Changed from Pod\nmetadata:\n  name: helloworld-deployment\nspec: # Replation controller also has a spec\n  replicas: 3 # set two pod replicas\n  template:\n  # stand Pod metadata and spec\n  metadata:\n    labels:\n    app: helloworld\n  spec:\n    # The containers are listed here\n    containers:\n    - name: k8s-demo\n      image: okeeffed/docker-demo\n      ports:\n      - containerPort: 3000\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"useful-commands"}},"Useful commands"),o.a.createElement(r.MDXTag,{name:"table",components:n},o.a.createElement(r.MDXTag,{name:"thead",components:n,parentName:"table"},o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"thead"},o.a.createElement(r.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Command"),o.a.createElement(r.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Description"))),o.a.createElement(r.MDXTag,{name:"tbody",components:n,parentName:"table"},o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl get deployments"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get info on current deployments")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl get rs"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get info about the replica set")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl get pods --show-labels"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get pods + labels attached to pods")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl rollout status deployment/helloworld-deployment"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get deployment status")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl set image deployment/helloworld-deployment k8s-demo=k8s-demo:2"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Run k8s-demo with the image label version 2")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl edit deployment/helloworld-deployment"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Edit the deployment object")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl rollout status deployment/helloworld-deployment"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get the status of the rollout")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl rollout history ","[deployment]"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Get the rollout history")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl rollout undo ","[deployment]"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Rollback to previous version")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"kubectl rollout undo ","[deployment]"," --to-revision=n"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Rollback to previous version")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-deployment-notes"}},"Demo: Deployment notes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Again, get pods will sho the pods with appended suffixes auto-determined by Kubernetes."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can verify rollout status using the commands above."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"services"}},"Services"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Pods themselves are very dynamic, they come and go on the Kubernetes cluster."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"When using a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Replication Controller"),", pods are termined and created during scaling operations."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Wehn using ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Deployments"),", when updating the image version, pods are terminated and new pods take the place of older pods.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"That's why Pods should never be accessed directly, but always through a Service."),o.a.createElement(r.MDXTag,{name:"p",components:n},"A service is the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"logical bridge"),' between the "mortal" pods and other services or end-users.'),o.a.createElement(r.MDXTag,{name:"p",components:n},"When using the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl expose")," command, you create a service for you pod to be accessed externally."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Creating a service will create an endpoint for your pod(s):"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"A ClusterIP: a virtual IP address only reachable from within the cluster (this is default)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"A NodePort: a port that is the same on each node that is also reachable externally."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"A LoadBalancer: created by the Cloud provider that will route external traffic on every node on the NodePort")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The options shown only allow virtual IPs and ports."),o.a.createElement(r.MDXTag,{name:"p",components:n},"There is also a possibility to use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"DNS Names")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ExternalName")," can provide a DNS name for the service e.g. for service discovery using DNS."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"only")," works when the DNS add-on is enabled."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# helloworld-service.yml\napiVersion: v1\nkind: Service\nmetadata:\n  name: helloworld-service\nspec:\n  ports: # specify the ports the service uses\n  - port: 31001\n    nodePort: 31001\n    # name below defined from pod\n    targetPort: nodejs-port\n    protocol: TCP\n  selector:\n  # service for this app\n  app: helloworld\n  type: NodePort\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"tags"}},"Tags"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Similar to Labels for AWS"),o.a.createElement(r.MDXTag,{name:"p",components:n},"For example, you can label your objects."),o.a.createElement(r.MDXTag,{name:"p",components:n},"For instance: Key could be ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"environment"),", and the value could be ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"dev"),"/",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"staging"),"/",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"qa"),"/",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"prod"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Maybe you could also tag the department that is comes from etc."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Labels are not unique. You can then use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"label selectors")," to match labels."),o.a.createElement(r.MDXTag,{name:"p",components:n},'Eg. a particular pod can only run on a node label with "evironment" equals "development".'),o.a.createElement(r.MDXTag,{name:"p",components:n},'More complex matching: "environment" in "development" or "qa".'),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can also use labels to tag nodes. Once tagged, you can use labels selectors to let pods only run on specific nodes."),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are two steps required to run a pod on a specific set of nodes:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"First you tag the node"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Then you add a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"nodeSelector")," to your pod configuration")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"kubectl label nodes node1 hardware=high-spec\nkubectl label nodes node1 hardware=low-spec\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Secondly, add a pod that uses those labels:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n    image: okeeffed/docker-demo\n    ports:\n    - containerPort: 3000\n  nodeSelector:\n  hardware: high-spec\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-using-tags"}},"Demo: Using tags"),o.a.createElement(r.MDXTag,{name:"p",components:n},"It only really makes sense if you have multiple nodes (doesn't really make sense on minikube)."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"healthchecks"}},"Healthchecks"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If the application malfunctions, the pod and container may still be running but the application may no longer be running. This is where health checks come in."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Two types:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Running a command in the container periodically"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Periodic checks on a URL")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The typical prod application behind a load balancer should always have health checks implemented in some way to ensure availability and resiliency."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Below you can see where the healthcheck is. You can check the port or container port name."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n    image: okeeffed/docker-demo\n    ports:\n    - containerPort: 3000\n    # @@@ This is the health check\n    livenessProbe:\n    httpGet:\n      path: /\n      port: 3000\n    initialDelaySeconds: 15\n    timeoutSeconds: 30\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"secrets"}},"Secrets"),o.a.createElement(r.MDXTag,{name:"p",components:n},"A way to distribute credentials, keys, passwords or secret data to the pods."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Kubernetes itself uses this Secrets mechanism to provide the credentials to access the internal API."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can use the same mechanism to provide secrets to your application."),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"secrets")," is just one way to provide secrets that is native to Kubernetes. There are still other ways to do this."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"how-to-use-them"}},"How to use them"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Use as env vars"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Use as a file in a pod",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This requires volumes to be mounted"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"In this volume you have files"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This can be use for things like dotenv files"))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can use an external image to pull secrets (private image registry)")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Generating:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},'echo -n "root" > ./username.txt\necho -n "password" > ./password.txt\nkubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt\n# > secret "db-user-pass" created\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"A secret can also be a SSH key or SSL cert."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"kubectl create secret generic ssl-cert --from-file=ssh-privatekey=~/.ssh/id_rsa --ssl-cert-=ssl-cert=mysslcert.crt\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To generate secrets using yaml defs:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: db-secret\ntype: Opaque\ndata:\n  password: pwd\n  username: usr\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Then, you can generate it as base64 like so:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},'echo -n "password" | base64\n# > pwd\n\nkubectl create -f secrets-db-secret.yml\n# > secret "db-secret" created\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"To create a pod that uses secrets:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n    image: okeeffed/docker-demo\n    ports:\n    - containerPort: 3000\n    # @@@ This are the envs\n    env:\n    - name: SECRET_USERNAME\n      valueFrom:\n      secretKeyRef:\n        name: db-secret\n        key: username\n    - name: SECRET_PASSWORD\n      [...]\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Alternatively when providing in a file:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n  image: okeeffed/docker-demo\n  ports:\n  - containerPort: 3000\n  # @@@ This are the envs in a volume mount\n  volumeMounts:\n  - name: credvolume\n    mountPath: /etc/creds\n    readOnly: true\n  volumes:\n  - name: credvolume\n  secret:\n    secretName: db-secrets\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-wordpress-secrets"}},"Demo: Wordpress Secrets"),o.a.createElement(r.MDXTag,{name:"p",components:n},"This demo ends up creating a secrets file, a pod definition and a service to expose the wordpress pod."),o.a.createElement(r.MDXTag,{name:"p",components:n},"However, note that deleting the current setup will result in a container restarting to maintain state, but when that happens the WordPress site has to be re-installed because the data was not saved. The solution for this will be in the volumes lab."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"web-ui"}},"Web UI"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Kubernetes comes with a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Web UI")," you can use instead of kubectl commands."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can use it to:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Get an overview of running applications on your cluster"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Creating and modifying individual Kubernetes resources and workloads (like kubectl create and delete)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Retrieve info on state or resources.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can reach this UI at ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"https://<kubernetes-master>/ui")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you cannot access it, you can install it manually:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml\n# If the password is asked\nkubectl config view\n\n# If you're on minikube\nminikube dashboard # or --url for the url\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-web-ui"}},"Demo: Web UI"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Using the web ui you can see some really interesting info and graphs on usage."),o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"advanced-topics"}},"Advanced Topics"),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"service-discovery"}},"Service Discovery"),o.a.createElement(r.MDXTag,{name:"p",components:n},"As of Kubernetes 1.3, DNS is a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"built-in")," service launched automatically using the addon manager."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The addons are in the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"/etc/kubernetes/addons")," directory on the master node."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The service can be used within pods to find other services running on the same cluster."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Multiple containers within 1 pod don't need this service, as they can contact each other directly. A container in the same pod can just use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"localhost:port"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To make DNS work, a pod will need a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"service definition"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"How can app 1 reach app 2 using DNS? The container itself can talk to the service of App 2."),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you ran the host for ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"app1-service")," and got back 10.0.0.1, ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"host app2-service")," could get back 10.0.0.2."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Examples from the CL"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"host app1-service\n# has addr 10.0.0.1\nhost app2-service\n# has addr 10.0.0.2\nhost app2-service.default\n# app2-service.default has address 10.0.0.2\nhost app2-service.default.svc.cluster.local\n# app2-service.default.svc.cluster.local has addr 10.0.0.2\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"default")," stands for default namespace. Pods and services can be launched in different namespaces (to logically seperate your cluster)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"So how does this resolution work?"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Say we have a pod and we run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl run -i -tty busybox --image=busybox --restart=Never -- sh")," and the from the shell run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"cat /etc/resolv.conf"),", can can see that there will be a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"nameserver"),". If you do a lookup of the service name in this folder, you'll see why the above works with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".default")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".default.svc.whatever"),"."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-service-discovery"}},"Demo: Service Discovery"),o.a.createElement(r.MDXTag,{name:"p",components:n},"After creating a secrets type, pod type for a database (SQL using the secrets), and a service for exposing certain ports for the database and then deploying three replicas for a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"helloworld-deployment")," that also has a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"index-db.js")," file which we run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"node index-db.js")," which will have code that works on the service. The value of the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"MYSQL_HOST")," being set to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"database-service")," will resolve with the database-service.yml file where the metadata ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"name")," is ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"database-service"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Running ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl get pod")," we should see the database plus 3 pods running for the deployment."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Running ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl logs [deployment-name]")," will also show us the logs for that pod."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Again, remember that running ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl get svc")," will get all the services available."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"configmap"}},"ConfigMap"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Config params that are not secret can be put in the ConfigMap."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The input is again key-value pairs."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ConfigMap")," key-value pairs can then be read by the app using:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Env variables"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Container commandline args in the Pod config"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Using volumes")),o.a.createElement(r.MDXTag,{name:"p",components:n},"It can also contain full config files eg. a webserver config file. Then that file can then be mounted using volumes where the application expects its config file."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This was you can ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"inject")," config settings into containers without changing the container itself."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To generate a configmap using files:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ cat << EOF > app.properties\ndriver=jdbc\ndatabase=postgres\nlookandfeel=1\notherparams=xyz\nparam.with.hierarchy=xyz\nEOF\n$ kubectl create configmap app-config --from-file=app.properties\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"How to use it? You can create a pod that exposes the ConfigMap using a volume."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n  image: okeeffed/docker-demo\n  ports:\n  - containerPort: 3000\n  # @@@ This are the envs in a volume mount\n  volumeMounts:\n  - name: credvolume\n    mountPath: /etc/creds\n    readOnly: true\n  # @@@ For the ConfigMap\n  - name: config-volume\n    mountPath: /etc/config\n  volumes:\n  - name: credvolume\n  secret:\n    secretName: db-secrets\n  # @@@ For the ConfigMap\n  - name: config-volume\n  configMap:\n    name: app-config\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"From ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"/etc/config")," , the config values will be stored in files at ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"/etc/config/driver")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"/etc/config/param/with/hierarchy"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is an example of a pod that exposes the ConfigMap as env variables:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nodehelloworld.example.com\n  labels:\n  app: helloworld\nspec:\n  # The containers are listed here\n  containers:\n  - name: k8s-demo\n  image: okeeffed/docker-demo\n  ports:\n  - containerPort: 3000\n  # @@@ This are the envs in a volume mount\n  env:\n  - name: DRIVER\n    valueFrom: # where you get the value from\n    configMapKeyRef: # ensuring the ref comes from the configMap\n    name: app-config\n    key: driver\n  - name: DATABASE\n  [ ... ]\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-config-map"}},"Demo: Config Map"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Using an example for a reverse proxy config for NGINX:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"server {\n  listen  80;\n  server_name localhost;\n\n  location / {\n  proxy_bind 127.0.0.1;\n  proxy_pass http://127.0.0.1:3000;\n  }\n\n  error_page  500 502 503 504 /50x.html;\n  location = /50x.html {\n  root    /usr/share/nginx/html;\n  }\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"We could then create this config map with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl create configmap nginx-config --from-file=reverseproxy.conf"),"."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hellonginx.example.com\n  labels:\n  app: hellonginx\nspec:\n  # The containers are listed here\n  containers:\n    - name: nginx\n    image: nginx:1.11\n    ports:\n    - containerPort: 80\n    # @@@ The import conf stuff\n    volumeMounts:\n    - name: config-volume\n        mountPath: /etc/nginx/conf.d\n  - name: k8s-demo\n  image: okeeffed/docker-demo\n  ports:\n    - containerPort: 3000\n  # @@@ The important mounting\n  volumes:\n    - name: config-volume # @@@ this is referred to above in volumeMounts\n    configMap:\n        name: nginx-config\n        items:\n        - key: reverseproxy.conf\n        path: reverseproxy.conf\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"After then also creating the service, we can grab the minikube service url and use curl to get info on that request. From here, would could see that it is ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"nginx")," answer the request and transferring it to the Node port."),o.a.createElement(r.MDXTag,{name:"p",components:n},"If we then want to jump into the nginx container to see what is going on, we can run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl exec -i -t helloworld-nginx -c nginx -- bash")," (-c flag to specify container) and run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ps x")," to see the processes and we can ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"cat /etc/nginx/conf.d/reverseproxy.conf"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"At this stage, we can enable SSL for NGINX."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"ingress-controller"}},"Ingress Controller"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Ingress a solution since Kub 1.1 that allows inbound connections to the cluster."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It's an alternative to the external ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"LoadBalancer")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"nodePorts"),". It allows you to easily expose services that need to be accessible from outside to the cluster."),o.a.createElement(r.MDXTag,{name:"p",components:n},"With ingress you can run your own ingress controller (basically a loudbalancer) within the Kub Cluster."),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are default ingress controller available, or you can write your own ingress controller."),o.a.createElement(r.MDXTag,{name:"p",components:n},"How does it work? If you connect over 80/443 you will first hit the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Ingress Controller"),". You can use the NGINX controller that comes with Kubernetes. That controller will the dirrect all the traffic."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ingress rules")," could define that if you go to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"host-x.example.com")," you go to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Pod 1")," etc. You can even redirect slash URLs specifically."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To create an Ingress Controller:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# ingress-controller.yml w/ secrets\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: helloworld-rules\nspec:\n  # @@@ Setting the important rules\n  rules:\n    - host: helloworld-v1.example.com\n      http:\n        paths:\n          - path: /\n          backend:\n            serviceName: helloworld-v1\n            servicePort: 80\n    - host: helloworld-v2.example.com\n      http:\n        paths:\n          - path: /\n          backend:\n            serviceName: helloworld-v2\n            servicePort: 80\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-ingress-controller"}},"Demo: Ingress Controller"),o.a.createElement(r.MDXTag,{name:"p",components:n},"In the example, the ingress controller is a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Replication Controller")," to ensure that there is always one up and running."),o.a.createElement(r.MDXTag,{name:"p",components:n},"After deploying, if we curl with the -H host flag with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"helloworld-v1.whatever.com")," and v2 respectively, it would have the ingress controller route to each server."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"external-dns"}},"External DNS"),o.a.createElement(r.MDXTag,{name:"p",components:n},"On public cloud providers, you can use the ingress controller to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"reduce the cost of your LoadBalancers"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You could use 1 LoadBalancer that captures all the external traffic and send it to the ingress controller."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"IngCont can be configured to route the different traffic to all your apps based on HTTP rules."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Only works for HTTP(s)-based apps")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The External DNS tool will automatically create the necessary DNS records in your external DNS server (like route53)."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"For every hostname used in ingress, it'll create a new record to send traffic to load balancer."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The major DNS providers are supported: Route53, Google CloudDNS, CloudFlare etc.")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1539998347/Screen_Shot_2018-10-20_at_12.18.14_pm.png",alt:"Diagram"}})),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"volumes"}},"Volumes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"How can we run stateful apps?"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Volumes in kubernetes allow you to store data outside of the container. So far, all the applications have been stateless for this reason. This can be done with external services like a database, caching server (eg MySQL, AWS S3)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Persistent Volumes in Kubernetes allow you to attach a volume to a container that exists even when the container stops. Volumes can be attached using different volume plugins. Eg local volume, EBS Storage etc."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"using-ebs-storage"}},"Using EBS Storage"),o.a.createElement(r.MDXTag,{name:"p",components:n},"With this, we can keep state. You could run a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"MySQL")," database using persistent volumes, although this may not be ready for production yet."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The use case is that if your node stops working, the pod can be rescheduled on another node, and the volume can be attached to the new node."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To use volumes, you first need to create the volume:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"aws ec2 create-volume --sze 1- --region us-east-1 --availability-zone us-east-1 --volume-type gp2\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Next, we need to create a pod with a volume def:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hellonginx.example.com\n  labels:\n  app: hellonginx\nspec:\n  # The containers are listed here\n  containers:\n    - name: k8s-demo\n    image: okeeffed/k8s-demo\n    volumeMounts:\n    - name: myvolume\n      mountPath: myvolume\n  # @@@ The important mounting\n  volumes:\n    - name: myvolume # @@@ this is referred to above in volumeMounts\n      awsElasticBlockStore:\n        volumeID: vol-9835id\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-volumes"}},"Demo: Volumes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Using Vagrant for kops, we can first create a volume using the above mentioned command."),o.a.createElement(r.MDXTag,{name:"p",components:n},"After receiving a response, you can replace the .yml pod definition config file to attach that volumeID. Once the deployment is created and deployed. "),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"After create and confirmation, we can get the pod name ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"kubectl get pod")," and attach ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"kubectl exec helloworld-deployment-923id -i -t -- bash")," and then run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"ls -ahl /myvol/")," to check for volume."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If we run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"echo 'test' > /myvol/myvol.txt")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"echo 'test 2' > /test.txt"),", we know that the latter file will not persist if the pod is restarted/rescheduled."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If we run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"kubectl drain ip --force")," we can drain the pod. Assuming this is a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Replication Controller")," or ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Deployment"),", another container should spin up."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Once that pod is attached to another node, we can also attach back to the pod on the new node with the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"exec")," command and we can confirm that the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"/myvol/myvol.txt")," is still there, although the other ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"/test.txt")," is no longer there since it was not saved to the volume.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you need to remove the ebs volume, you can run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"aws ec2 delete-volume --volume-id vol-[id]"),"."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"volume-provisioning"}},"Volume Provisioning"),o.a.createElement(r.MDXTag,{name:"p",components:n},"The kubs plugins have the capability to ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"provision storage")," for you. The AWS Plugin can for instance ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"provision storage")," for you by creating the volumes in AWS before attaching them to a node."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is done using the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"StorageClass")," object -- this is beta for the course but should be stable soon."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To use autoprovisioing, create the following:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# storage.yml\nkind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: standard\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\n  zone: ap-southeast-1\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Next, you can create a volume claim and specify the size:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# my-volume-claim.yml\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: myclaim\n  annotations:\n    volume.beta.kubernetes.io/storage-class: "standard"\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8Gi\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"Finally, if launching a pod:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# pod-helloworld.yml w/ secrets\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mypod\nspec:\n  # The containers are listed here\n  containers:\n    - name: myfrontend\n    image: nginx\n    volumeMounts:\n    - name: mypd\n      mountPath: '/var/www/html'\n  # @@@ The important mounting\n  volumes:\n    - name: mypd # @@@ this is referred to above in volumeMounts\n      persistentVolumeClaim:\n        claimName: myclaim # @@@ refers to my claim from the previous type definition\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"demo-using-wordpress-with-volumes"}},"Demo: Using Wordpress with Volumes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"After declaring a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"StorageClass")," class from a yaml file and a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"PersistentVolumeClaim")," class."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# storage.yml\nkind: StorageClass\napiVersion: storage.k8s.io/v1beta1\nmetadata:\n  name: standard\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\n  zone: eu-west-1a\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# PV Claim\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: db-storage\n  annotations:\n    volume.beta.kubernetes.io/storage-class: "standard"\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8Gi\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"There is also a simple ReplicationController for the Wordpress DB. In the spe for the container for mysql, we declare where the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mountPath")," will be."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: wordpress-db\nspec:\n  replicas: 1\n  selector:\n    app: wordpress-db\n  template:\n    metadata:\n      name: wordpress-db\n      labels:\n        app: wordpress-db\n    spec:\n      containers:\n      - name: mysql\n        image: mysql:5.7\n        args:\n          - "--ignore-db-dir=lost+found"\n        ports:\n        - name: mysql-port\n          containerPort: 3306\n        env:\n          - name: MYSQL_ROOT_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: db-password\n        volumeMounts:\n        - mountPath: "/var/lib/mysql"\n          name: mysql-storage\n      volumes:\n        - name: mysql-storage\n          persistentVolumeClaim:\n            claimName: db-storage\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"Having a makeshift secrets file for secrets:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: wordpress-secrets\ntype: Opaque\ndata:\n  db-password: cGFzc3dvcmQ=\n  # random sha1 strings - change all these lines\n  authkey: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ4OA==\n  loggedinkey: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ4OQ==\n  secureauthkey: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ5MQ==\n  noncekey: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ5MA==\n  authsalt: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ5Mg==\n  secureauthsalt: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ5Mw==\n  loggedinsalt: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ5NA==\n  noncesalt: MTQ3ZDVhMTIzYmU1ZTRiMWQ1NzUyOWFlNWE2YzRjY2FhMDkyZGQ5NQ==\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To open up the service for the port:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: v1\nkind: Service\nmetadata:\n  name: wordpress-db\nspec:\n  ports:\n  - port: 3306\n    protocol: TCP\n  selector:\n    app: wordpress-db\n  type: NodePort\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Opening up the web and web service:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: wordpress-deployment\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        app: wordpress\n    spec:\n      containers:\n      - name: wordpress\n        image: wordpress:4-php7.0\n        # uncomment to fix perm issue, see also https://github.com/kubernetes/kubernetes/issues/2630\n        # command: ['bash', '-c', 'chown www-data:www-data /var/www/html/wp-content/uploads && apache2-foreground']\n        ports:\n        - name: http-port\n          containerPort: 80\n        env:\n          - name: WORDPRESS_DB_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: db-password\n          - name: WORDPRESS_AUTH_KEY\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: authkey\n          - name: WORDPRESS_LOGGED_IN_KEY\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: loggedinkey\n          - name: WORDPRESS_SECURE_AUTH_KEY\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: secureauthkey\n          - name: WORDPRESS_NONCE_KEY\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: noncekey\n          - name: WORDPRESS_AUTH_SALT\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: authsalt\n          - name: WORDPRESS_SECURE_AUTH_SALT\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: secureauthsalt\n          - name: WORDPRESS_LOGGED_IN_SALT\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: loggedinsalt\n          - name: WORDPRESS_NONCE_SALT\n            valueFrom:\n              secretKeyRef:\n                name: wordpress-secrets\n                key: noncesalt\n          - name: WORDPRESS_DB_HOST\n            value: wordpress-db\n        volumeMounts:\n        # shared storage for things like media\n        - mountPath: /var/www/html/wp-content/uploads\n          name: uploads\n      volumes:\n      - name: uploads\n        nfs:\n          server: eu-west-1a.fs-5714e89e.efs.eu-west-1.amazonaws.com\n          path: /\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: v1\nkind: Service\nmetadata:\n  name: wordpress\nspec:\n  ports:\n  - port: 80\n    targetPort: http-port\n    protocol: TCP\n  selector:\n    app: wordpress\n  type: LoadBalancer\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"With the AWS Commandline, you can create a file system and mount target. For the fs, run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"aws efs create-file-system --creation-token")," and then after grabbing the file-system-id and subnet-id, you can run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"aws efs create-mount-target --file-system-id <id> --security-groups <sg>"),". Ensure in the above ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"nfs")," volume you update the fs id."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"pod-presets"}},"Pod Presets"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Pod presets can inject information into pods at runtime."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Used to inject Kubernetes Resources like Secrets, ConfigMaps, Volumes and Environment variables. ")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Imagine you have 20 apps to deploy, all with a specific credential. You can edit the 20 specs and add the creds, or you can use presets to create 1 ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Preset Object"),", which will ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"inject an environment variable or config file to all matching pods.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"When injecting env vars and volume mounts, the Pod Preset will apply the changes to ll containers within the pod."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# PodPreset File\napiVersion: settings.k8s.io/v1alpha1\nkind: PodPreset\nmetadata:\n  name: allow-database\nspec:\n  selector:\n    matchLabels:\n      role: frontend\n  env:\n    - name: DB_PORT\n      value: '6379'\n  volumeMounts:\n    - mountPath: /cache\n      name: cache-volume\n  volumes:\n    - name: cache-volume\n      emptyDir: {}\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yml"}},"# Pod file using PodPreset\napiVersion: v1\nkind: Pod\nmetadata:\n  name: website\n  labels:\n    app: website\n    role: frontend\nspec:\n  containers:\n    - name: website\n      image: nginx\n      ports:\n        - containerPort: 80\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl create -f pod-preset.yml\n$ kubectl create -f pod.yml\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"stateful-sets---formerly-pet-sets"}},"Stateful Sets - (formerly Pet Sets)"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Stateful dist apps - new feature from Kub 1.3."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It is introduced to be able to run ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"stateful applications")," that need:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"A stable pod hostname (instead of podname-randomstr) - will have an index ie podname-0, podname-1 etc."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Stateful app requires multi pods with vols based on their ordinal number. Currently deleting and/or scaling a PetSet down will not deleted volumes associated.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"A pet set will allow your stateful app to use DNS to find out peers. One running node of the Pet Set is called a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Pet"),". Using Pet Sets you can run for instance 5 cassandra nodes on Kubs named cass-1 until cass-5."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The big difference is that you don't want to connect just any specific service, you want to make sure pod whatever definitely connects to another pod."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This pet set also allows order to startup and teardown of pets."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Still a lot of work for future work."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"daemon-sets"}},"Daemon Sets"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Ensure that every single node in the Kubernetes cluster runs the same pod resource. This is useful to ensure a certain pod is running on every single kubernetes node."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"When a node is added to the cluster, a new pod will be started automatically"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Same when a node is removed, the pod will not be rescheduled on another node")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Use cases:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Logging aggregators"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Monitoring"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Load Balancers/Reverse Proxies/API Gateways")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"resource-usage-monitoring"}},"Resource Usage Monitoring"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Heapster enables ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Container Cluster Monitoring")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Performance Analysis"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It's providing a monitoring platform for Kubernetes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It's a prerequisite if you want to do ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"pod auto-scaling")," in Kubernetes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Heapster exports cluster metrix ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"via REST endpoints"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can use different backends with Heapster.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Demo uses ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"InfluxDB"),", but Kafka is also possible."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Visualisations can be shown with Grafana. ",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Kubernetes dashboard will also show graphs once monitoring is enabled."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"All these technologies can be started in pods"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"yaml files")," can be found on the github repo of Heapster.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Since Heapster is now deprecated, you would have to use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"metrics-server")," or an alternative like ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Prometheus"),"."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"horiztonal-pod-autoscaling"}},"Horiztonal Pod Autoscaling"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/"}},"Link to main Kubernetes site")),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Kubernetes has the possibility to autoscale pods based on metrics.")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Kubernetes can autoscale Deployment, Replication Controller or ReplicaSet.")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"In Kubernetes 1.3 ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"scaling based on CPU")," usage is possible out of the box."),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Application based metrics are also available (like queries per second or average request latency).",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"To enable, the cluster has to be started with env var ENABLE_CUSTOM_METRICS to be true."))))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"It will periodically query the utilization for the targeted pods."),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"By default 30 sec, can be changed using the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"--horizontal-pod-autoscaler-sync-period"),"flag when launching the controller manager."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Requires the metrics system to work."))),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: autoscaling/v1\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: hpa-example-autoscaler\nspec:\n  scaleTargetRef:\n    apiVersion: extensions/v1beta1\n    kind: Deployment\n    name: hpa-example\n  minReplicas: 1\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 50\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"affinityanti-affinity"}},"Affinity/Anti-Affinity"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The affinity/anti-affinity feature allows you to do ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"more complex scheduling")," than the nodeSelector and also ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"works on Pods"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The language is ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"more expressive"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can create ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"rules that are not hard requirements"),", but rather a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"preferred rule"),", meaning that the scheduler will stil be able to schedule your pod, even if the rules cannot be met."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can create rules to take other pod labels into account",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Example, you can make sure two different pods are never on the same node."))))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Kubernetes can do ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node affinity")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"pod affinity/anti-affinity"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Node affinity is similar to the nodeSelector."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Pod affinity/anti-affinity allows you to create rules ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"how pods should be scheduled taking into account other running pods"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Affinity/anti-affinity mechanism is only relevant during scheduling, once a pod is running, it'll need to be recreated to apply the rules again."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"There are currently 2 types you can use for node affinity:",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"1) requiredDuringSchedulingIgnoredDuringExecution"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"2) preferredDuringSchedulingIgnoredDuringExecution"))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"first one")," sets a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"hard requirement")," (like the nodeSelector).",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The rules must be met before the pod can be scheduled."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"second type")," will try to enforce the rule, but it will not guarantee it.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Even if the rule is not met, the pod can still be scheduled, it's a soft requirement, a preference.")))),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: <% helloworld-deployment %>\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        app: <% app_name %>\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n              - matchExpressions:\n                  - key: env\n                    operator: In\n                    values:\n                      - dev\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - weight: 1 # higher the weighting, the more emphasis on rule\n              preference:\n                matchExpressions:\n                  - key: team\n                    operator: In\n                    values:\n                      - engineering-project1\n      containers:\n        - name: k8s-demo\n          image: <% image_name %>\n          port:\n            - containerPort: 3000\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"When scheduling, Kubernetes will score every node by summarizing the weightings per node."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Eg two different rules with weights 1and 5.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If both rules match, score 6."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If only rule with weight 1 matches, score 1."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The node that has the highest total score, that's where the pod will be scheduled on.")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"313-interpod-affinityanti-affinity"}},"3.13 Interpod Affinity/Anti-Affinity"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This allows you to influence scheduling based on the labels of other pods that are ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"already running")," on the cluster."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Pods belong to a namespace, so rules apply to namespace (default to pod name).")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Two types:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"requiredDuringSchedulingIgnoredDuringExecution"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"preferredDuringSchedulingIgnoredDuringExecution")),o.a.createElement(r.MDXTag,{name:"p",components:n},'The required type create rules that must be met for the pod to be scheduled, the preferred type is a "soft" type and the rules may be met.'),o.a.createElement(r.MDXTag,{name:"p",components:n},"A good use case for ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"pod affinity is co-located pods"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Example, you have an app that uses redis as cache and you want to have the Redis pod on the same node as the app itself."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Another use-case is to co-locate pods within the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"same availability zone"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"When writing your pod affinity and anti-affinity rules, you need to specify a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"topology domain"),", called ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"topologyKey")," in the rules.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Key refers to a node label."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If affinity rule matches, ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"new pod")," will only be scheduled on ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"nodes")," that have the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"same topologyKey")," value as the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"current running pod"),".")))),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540165720/Screen_Shot_2018-10-22_at_10.48.04_am.png",alt:"Interpod Affinity and anti-affinity"}})),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540165853/Screen_Shot_2018-10-22_at_10.50.27_am.png",alt:"Zone topology"}})),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"anti-affinity"}},"Anti-affinity"),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can use anti-affinity to make sure a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"pod is only scehduled once on a node"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Example 3 nodes and you want to schedule 2 pods but they shouldn't be on the same node."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Pod anti-affinity allows you to create a rule that say to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"not schedule on the same host if a pod label matches"),".")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540165853/Screen_Shot_2018-10-22_at_10.50.27_am.png",alt:"Anti-affinity"}})),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"topology-operators"}},"Topology operators"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"In"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"NotIn"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Exists"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"DoesNotExist")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Affinity requires a substantial amount of processor. Take this into account if you have a lot of rules."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# pod-affinity.yml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pod-affinity-1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: pod-affinity-1\n    spec:\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pod-affinity-2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: pod-affinity-2\n    spec:\n      affinity:\n        podAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: "app"\n                    operator: In\n                    values:\n                    - pod-affinity-1\n              topologyKey: "kubernetes.io/hostname" # this could be change for zoning\n      containers:\n      - name: redis\n        image: redis\n        ports:\n        - name: redis-port\n          containerPort: 6379\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can then check this is fine by running ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl get pod -o wide")," to see the Node the pods are running on."),o.a.createElement(r.MDXTag,{name:"p",components:n},"As for anti-affinity:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pod-affinity-1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: pod-affinity-1\n    spec:\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pod-affinity-2\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: pod-affinity-2\n    spec:\n      affinity:\n        podAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: "app"\n                    operator: In\n                    values:\n                    - pod-affinity-1\n              topologyKey: "kubernetes.io/hostname"\n      containers:\n      - name: redis\n        image: redis\n        ports:\n        - name: redis-port\n          containerPort: 6379\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pod-affinity-3\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: pod-affinity-3\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: "app"\n                    operator: In\n                    values:\n                    - pod-affinity-1\n              topologyKey: "kubernetes.io/hostname"\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pod-affinity-4\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: pod-affinity-4\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: "app"\n                    operator: In\n                    values:\n                    - pod-affinity-1\n                    - pod-affinity-3\n              topologyKey: "kubernetes.io/hostname"\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n---\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540170357/Screen_Shot_2018-10-22_at_12.05.28_pm.png",alt:"Resulting run with the affinity/anti-affinity"}})),o.a.createElement(r.MDXTag,{name:"p",components:n},"Note that there are differences between ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"preferred")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"required"),". With preferred, you may still have the pod scheduled in events we don't necessarily want as a best case scenario."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"314-taints-and-tolerations"}},"3.14 Taints and Tolerations"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Tolerations is the opposite of node affinity."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Allows a node to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"repels a set of pods"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Taints mark")," a node, tolerations are applied to pods to influence the scheduling of a pod."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"One use case for taints is to make sure that when you create a new pod, they're not scheduled on the master (",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node-role.kubernetes.io/master:NoSchedule"),"). This is the default.")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"# To add a taint\n$ kubectl taint nodes node1 key=value:NoSchedule # This will make sure that no pods will be scheduled on node1 as long as they don't have a matching toleration\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# tolerations.yml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: tolerations-1\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: tolerations-1\n    spec:\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: tolerations-2\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: tolerations-2\n    spec:\n      tolerations:\n      - key: "type"\n        operator: "Equal"\n        value: "specialnode"\n        effect: "NoSchedule"\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"tolerations-usage"}},"Tolerations usage"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"# Taint a node\n$ kubectl taint nodes NODE-NAME type=specialnode:NoSchedule\n\n# Taint with NoExecute\n$ kubectl taint nodes NODE-NAME testkey=testvalue:NoExecute\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"keys"}},"Keys"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Operators",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Equal")," (providing key + value)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Exists")," (only providing a key, checking only whether a key exists)"))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Effects",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"NoSchedule")," (hard requirement that apod will not be scheduled unless there is a matching toleration)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"PreferNoSchedule")," (avoid placing a pod that doesn't have a matching tolerationg, but it's not a hard requirement)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"NoExecute")," (evict pods with non-matching tolerations)",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"tolerationSeconds")," key can be applied with a time in seconds for how long a node can run before it is evicted.")))))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"use-cases"}},"Use Cases"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Existing node taints for ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"master nodes"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Taint nodes that are ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"dedicated")," for a team or user."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Node for ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"specific hardware")," (ie GPUs) you can taint them to void running non-specific applications on those nodes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Alpha but soon-to-be beta feature is to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"taint nodes by condition"),".")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"useful-taints-and-tolerations"}},"Useful Taints and Tolerations"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/not-ready")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/unreachable")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/out-of-disk")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/memory-pressure")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/disk-pressure")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/network-unavailable")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node.kubernetes.io/unschedulable"))),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"315-customer-resource-definitions-crds"}},"3.15 Customer Resource Definitions (CRDs)"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Let's you extend Kubernetes API."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Resources are the endpoints in the Kubernetes API that store collections of API Objects (ie Deployment, LoadBalancer)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Operators use CRDs to extend the Kubernetes API with their own functionality.")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"316-operators"}},"3.16 Operators"),o.a.createElement(r.MDXTag,{name:"p",components:n},"An ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Operator")," is a method of ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"packaging, deploying and managing")," a Kubernetes Application."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It puts ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"operational knowledge")," in an application."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Brings the user ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"closer to the experience of managed cloud services"),", rather than having to know all the specifics of an application deployed to Kubernetes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Once an Operator is deployed, it can be ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"managed using Custom Resource Definitions")," (arbitraty types that extend the Kubernetes API)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It also provides a great way to deploy Stateful applications to Kubernetes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"There are operators for Prometheus, Valut, Rook (storage), MySQL, PostgresSQL and so on.")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"postgresql-operator-demo"}},"PostgreSQL Operator Demo"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you just deploy a PostgreSQL container, it'd only start the database. But if you're going to use this ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"operator"),", it'll allow you to also ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"create replicas, initiate a failover, create backups, scale"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"An operator contains a lot of the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"management logic")," that you as an administrator or user might want, rather than having to implement it yourself.")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"4-kubernetes-administration"}},"4. Kubernetes Administration"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540175278/Screen_Shot_2018-10-22_at_1.26.57_pm.png",alt:"Kubernetes Master Overview"}})),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"When you deploy a new Pod, the information is stored in ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"etcd"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Schedular talks to REST api."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"REST api is used to handle tasks.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Interfaces with Kubelets on the nodes.")))),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"41-resource-quotas"}},"4.1 Resource Quotas"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Resource management is useful when giving access to a person or a team."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You don't want one person or team ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"taking up all the resources")," (e.g. CPU/Memory) of the cluster."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can divide the cluster into ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"namespaces")," and enable resource quotas on it.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can do this using the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ResourceQuota")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ObjectQuota")," objects."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Each container can specify ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"request capacity")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"capacity limits"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Request capacity")," is an ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"explicit request")," for resources.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The scheduler can use the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"request capacity")," to make decisions on where to put the pod on."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can see it as a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"minimum amount of resources the pod needs"),"."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Resource limit")," is a limit imposed to the container.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Container will not be able to utilize more resources than specified.")))))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"resource-quota-examples"}},"Resource Quota Examples"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You run a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"deployment")," with a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"pod")," with a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"CPU resource")," request of ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"200m"),". (200 millicpu/milliocores)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"200m = 0.2 = 20% of CPU core of running node.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If node has 2 cores, still 20% of a single core."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can also put a limit eg 400m."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Memory quotes defined in MB or GB."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Each pod needs the capacity quota defined during creation.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Admin can specify default request values for pods that don't specify any values for capacity."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The same is valid for limit quotas."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If resource is requested more than the allowed capacity, the server API will give an error 403 FORBIDDEN and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"kubectl")," will show an error.")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"resource-quote-options"}},"Resource Quote options"),o.a.createElement(r.MDXTag,{name:"table",components:n},o.a.createElement(r.MDXTag,{name:"thead",components:n,parentName:"table"},o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"thead"},o.a.createElement(r.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Resource"),o.a.createElement(r.MDXTag,{name:"th",components:n,parentName:"tr",props:{align:null}},"Description"))),o.a.createElement(r.MDXTag,{name:"tbody",components:n,parentName:"table"},o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"requests.cpu"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Sum of CPU reqs of all pos cannot exceed this value")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"requests.mem"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Sum of MEM reqs of all pods cannot exceed this value")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"requests.storage"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Sum of storage reqs of all persistent volume claims cannot exceed this value")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"limits.cpu"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Sum of CPU limits of all pods cannot exceed this value")),o.a.createElement(r.MDXTag,{name:"tr",components:n,parentName:"tbody"},o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"limits.memory"),o.a.createElement(r.MDXTag,{name:"td",components:n,parentName:"tr",props:{align:null}},"Sum of MEM limits of all pods cannot exceed this value")))),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can also set limits on:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"configmaps"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"persistentvolumeclaims"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"pods"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"replicationcontrollers"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"resourcequotas"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"services"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"services.loadbalancer"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"services.nodeports"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"secrets")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"42-namespaces"}},"4.2 Namespaces"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Namespaces allow you to create ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"virtual clusters")," within the same physical cluster."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Namespaces ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"logically separates")," your cluster."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The standard namespace is called ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},'"default"')," and that's where all the resources are launched by default.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"There is also ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"kube-system")," - a namespace for kubernetes specific resources."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Namespaces are intended when you have ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"multiple teams/projects")," using the Kubernetes cluster."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Resource names within namespace must be unique."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can divide resources of a Kubernetes cluster using namespaces.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can limit resources on a per namespace basis."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"E.g. Marketing team can only use a maximum of 10GiB of memory, 2 loadbalancers, 2 CPU cores.")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"namespace-commands"}},"Namespace commands"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl create namespace myspace # create namespace myspace\n$ kubectl get namespaces # list all namespaces\n# Set default namespace to launch resources in\n$ export CONTEXT=$(kubectl config view | awk '/current-context/{print $2}')\n$ kubectl config set-context $CONTEXT --namespace=myspace\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: 1\nkind: ResourceQuota\nmetadata:\n    name: objects-counts\n    namespace: myspace\nspec:\n    hard:\n        configmaps: "10"\n        persistentvolumesclaim: "4"\n        replicationcontrollers: "20"\n        secrets: "10"\n        services: "10"\n        services.loadbalancers: "2"\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"demo-resourcequotas"}},"Demo ResourceQuotas"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# resourcequota.yml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: myspace\n---\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: compute-quota\n  namespace: myspace\nspec:\n  hard:\n    requests.cpu: "1"\n    requests.memory: 1Gi\n    limits.cpu: "2"\n    limits.memory: 2Gi\n---\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: object-quota\n  namespace: myspace\nspec:\n  hard:\n    configmaps: "10"\n    persistentvolumeclaims: "4"\n    replicationcontrollers: "20"\n    secrets: "10"\n    services: "10"\n    services.loadbalancers: "2"\n')),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# helloworld-with-quotas.yaml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment\n  namespace: myspace\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n        resources:\n          requests:\n            cpu: 200m\n            memory: 0.5Gi\n          limits:\n            cpu: 400m\n            memory: 1Gi\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# helloworld-no-quotas.yaml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: helloworld-deployment\n  namespace: myspace\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: helloworld\n    spec:\n      containers:\n      - name: k8s-demo\n        image: wardviaene/k8s-demo\n        ports:\n        - name: nodejs-port\n          containerPort: 3000\n")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# default.yaml\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: limits\n  namespace: myspace\nspec:\n  limits:\n  - default:\n      cpu: 200m\n      memory: 512Mi\n    defaultRequest:\n      cpu: 100m\n      memory: 256Mi\n    type: Container\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The following commands can be used to get check resources:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl get <% pod_name %> --namespace=myspace\n$ kubectl describe <% pod_name %> --namespace=myspace\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"43-user-management"}},"4.3 User Management"),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are two user types:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Normal user (used to access the cluster externally) ie through kubctl."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Service user (which is managed by an object in Kubernetes).",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Used to authenticate within the cluster ie from inside pod of kubelet."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"These creds are managed like ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"secrets"),".")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"normal-users"}},"Normal Users"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Auth strategies include:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Client certificates"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Bearer Tokens "),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Authentication Proxy"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"HTTP Basic Authentication"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"OpenID"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Webhooks")),o.a.createElement(r.MDXTag,{name:"p",components:n},"They have the following attributes:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Username (e.g. user123 or email@email.com)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"A UID"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Groups"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Extra fields to store extra info")),o.a.createElement(r.MDXTag,{name:"p",components:n},"After a normal user authenticates, it was hav access to everything."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"To limit, you need to configure auth."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"There are multiple offerings:",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"AlwaysAllow / AlwaysDeny"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"ABAC (Attribute-Based Access Control)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"RBAC (Role Based Access Control)"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Webhook (auth by remote service)")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"service-users"}},"Service Users"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Service Users are using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Service Account Tokens"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"They are stored as ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"credentials using Secrets"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Those Secrets are also mounted in pods to allow communication between the services."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Service Users are ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"specific to a namespace"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"They are created automatically by the API or manually using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"objects"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Any API call ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"not authenticated")," is considered as an ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"anonymous")," user.")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"other-notes-on-user-management"}},"Other notes on User Management"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Auth is still a work in progress. The demo itself shows the creation of a asymmetric key and updating Minikube to allow that as the user."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"44-rbac-role-based-access-control"}},"4.4 RBAC (Role Based Access Control)"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Regulates access using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"roles"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Allows admins to dynamically configure permission policies."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This is what I'll use in the demo.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"You add RBAC resources with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl")," from a yaml format file."),o.a.createElement(r.MDXTag,{name:"p",components:n},"First, define a role, then assign users/groups to that role."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can create roles limited to a namespace or that applies across all namespaces."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Role")," (single namespace) and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ClusterRole")," (cluster-wide)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"RoleBinding")," (single namespace) and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ClusterRoleBinding")," (cluster-wide).")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"45-networking"}},"4.5 Networking"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Communication topics already covered:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Container to container: communication within a pod.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Through ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"localhost")," and the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"port number"),"."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Pod-To-Service comms",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"NodePort")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"DNS"),"."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"External-To-Service",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"LoadBalancer"),", ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"NodePort"),".")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"pods"}},"Pods"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The pod should always be routable."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Kubernetes assumes that pods should be able to communicate to other pods, regardless of which node they are running."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Kubernetes assumes that pods should be able to communicate to other pods, regardless of which node they are running.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Every pod has its ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"own IP address"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Pods on different nodes need to be able to communicate to each other using those IP addresses.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This is implemented differently depending on your networking setup."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"On AWS: kubenet networking (kops default).")))))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"kubenet-networking"}},"Kubenet Networking"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Every pod can get an IP that is ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"routable")," using the AWS Virtual Private Network (VPC)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The kubernetes master allocates a /24 subnet to each node (254 IP addresses)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The subnet is added to the VPCs route table."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"There is a limit of ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"50 entries"),", which means you can't have more than 50 nodes in a single AWS cluster.")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"vpc-alternatives"}},"VPC Alternatives"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Not every cloud provider has VPC-tech (GCE and Azure do)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The alternatives for things like on-prem etc are:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Container Network Interface (CNI)"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Software that provides libraries/plugins for network interfaces within containers.")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Popular solutions are ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Calico, Weave")," (standalone or with CNI).")))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"An Overlay Network"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Flannel")," is an easy and popular way.")))),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"46-node-maintenance"}},"4.6 Node Maintenance"),o.a.createElement(r.MDXTag,{name:"p",components:n},"It is the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Node Controller")," that is responsible for managing the Node object."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It assigns ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"IP Space")," to the node when a new node is launched."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It keeps the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node list")," up to date with the available machines."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The node controller is also monitoring the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"health of the node"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If a node is ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"unhealthy it gets deleted"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Pods running on the unhealthy node will then get ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"rescheduled"),".")))),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"adding-a-new-node"}},"Adding a new node"),o.a.createElement(r.MDXTag,{name:"p",components:n},"When adding a new node, the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"kubelet")," will attempt to register itself. This is called ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"self-registration")," and is the default behaviour."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It allows you to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"easily add more nodes")," to the cluster without making API changes yourself."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"A new node object is ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"automatically")," created with:",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The metadata (with a name: IP or hostname)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Labels (e.g. cloud region / availability zone / instance size)."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Has ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"node condition")," (e.g. Ready, OutOfDisk)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"When you want to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"decomission")," a node, you want to do it gracefully.",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Drain a node before you shut it down or take it out of the cluster.")))),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"# drain a node\n$ kubectl drain nodename --grace-period=600\n\n# if node runs pods not managed by a controller but just a single pod\n$ kubectl drain nodename --force\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540183374/Screen_Shot_2018-10-22_at_3.42.29_pm.png",alt:"Terminal draining"}})),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"47-high-availability"}},"4.7 High Availability"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you are running in prod, you willwant all master services in ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"high availability"),"."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"setup"}},"Setup"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Clustering etcd:")," at least run 3 etcd nodes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Replicated API servers:")," with a a LoadBalancer"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Running multiple instances of the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"scheduler")," and the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"controllers"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"only one of them will be the leader, the others are on stand-by.")))),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540183580/Screen_Shot_2018-10-22_at_3.46.05_pm.png",alt:"HA Overview"}})),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540183671/Screen_Shot_2018-10-22_at_3.46.52_pm.png",alt:"HA diagram"}})),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"kops-with-multiple-masters-for-ha"}},"Kops with multiple masters for HA"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"kops create cluster --name=... --zones=eu-west-1a,eu-west-1b,eu-west-1c --master-zones=eu-west-1a,eu-west-1b,eu-west-1c\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"This becomes more complex for volumes since EBS volumes are based within zones."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"48-tls-on-elb-using-annotations"}},"4.8 TLS on ELB using Annotations"),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can setup ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"cloud specific features")," (like TLS termination) on AWS LoadBalancers that you create in Kubernetes using services of type LoadBalancer."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can do this using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"annotations")," to pass some flags for cloud configuration eg aws-load-balancer-ssl-cert, aws-load-balancer-backend-protocol etc."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# helloworld-elb-tls-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: helloworld-service\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:region:accountid:certificate/..." #replace this value\n    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"\n    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"\n    service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"\n    service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"\n    service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: "environment=dev,app=helloworld"\nspec:\n  ports:\n  - name: http\n    port: 80\n    targetPort: nodejs-port\n    protocol: TCP\n  - name: https\n    port: 443\n    targetPort: nodejs-port\n    protocol: TCP\n  selector:\n    app: helloworld\n  type: LoadBalancer\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"5-packaging-and-deploying-on-kubernetes"}},"5. Packaging and Deploying on Kubernetes"),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"51-intro-to-helm"}},"5.1 Intro to Helm"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Helm is the best way to find, share and use software built for Kubernetes."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Package manager for Kubernetes."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Helps you manage Kubernetes apps."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Maintained by CNCF.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To use, download the Helm client."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To run, use ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"helm init"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This will installer Tiller"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"If you have RBAC installed (recent clusters have it enabled by default), you'll also need to add a ServiceAccount and RBAC rules.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Helm uses a packaging format call ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"charts"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"A chart is a collection of files that describe a set of Kubernetes resources."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"A single chart can deploy an app, a piece of software or a database."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It can have depencies ie Wordpress chart requires mysql chart."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can also write your own chart.")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"helm-commands"}},"Helm commands"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ helm init # install tiller on the cluster\n$ helm reset # remove tiller\n$ helm install # install chart\n$ helm search redis #looks for redis chart\n$ helm install --name myredis stable/redis # install chart from redis search found under myredis\n$ helm delete myredis # delete redis install named myredis\n$ helm create <% chart_name %> # create your own chart\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"installing-helm"}},"Installing Helm"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ curl https://raw.githubusercontent.com/helm/helm/master/scripts/get > get_helm.sh\n$ chmod 700 get_helm.sh\n$ ./get_helm.sh\n")),o.a.createElement(r.MDXTag,{name:"h4",components:n,props:{id:"linux-distro-install"}},"Linux Distro Install"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ wget https://kubernetes-helm.storage.googleapis.com/helm-v2.11.0-linux-amd64.tar.gz\n$ tar -xzvf helm-v2.11.0-linux-amd64.tar.gz\n$ sudo mv linux-amd64/helm /usr/local/bin/helm\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"adding-to-cluster"}},"Adding to cluster"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl create -f helm-rbac.yaml\n$ helm init --service-account tiller\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"52-creating-your-own-helm-charts"}},"5.2 Creating your own helm charts"),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is the recommended way to deploy applications."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Packaging the app allows you to deploy the app in 1 command.")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Helm allows for upgrades and rollbacks.")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"li"},"Helm chart is also version controlled."))),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"53-setting-up-helm-repo-with-s3"}},"5.3 Setting up Helm Repo with S3"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you have charts stored on S3:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"# Install plugin\n$ helm plugin install https://github.com/hypnoglow/helm-s3.git\n\n# Initialise s3 bucket\n$ helm s3 init s3://helm-bucket/charts\n\n# Add report to helm\n$ helm repo add my-charts s3://helm-bucket/charts\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"6-serverless-on-kubernetes"}},"6. Serverless on Kubernetes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"With the serverless products, you don't need to manage the underlying functions. It can also greatly reduce costs."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Great for not worrying about many operational aspects."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can also use functions to start applications on Kubernetes instead of containers. You can install and use any of the projects to let developers launch functions on your Kubernetes cluster."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"61-intro-to-kubeless"}},"6.1 Intro to Kubeless"),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is a Kubernetes-native framework. It leverages Kubernetes resource to provide auto-scaling, API routing, monitoring and more."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It uses ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Customer Resource Definitions")," to be able to create functions."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You deploy a function with your preferred language. Once you deploy, you need to determine how it will be triggered."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"62-creating-functions-on-kubeless"}},"6.2 Creating functions on Kubeless"),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"installing-the-cli"}},"Installing the CLI"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ wget https://github.com/kubeless/kubeless/releases/download/v1.0.0-alpha.8/kubeless_linux-amd64.zip\n$ sudo apt-get install unzip # if you need to unzip\n$ unzip kubeless_linux-amd64.zip\n$ sudo mv bundles/kubeless_linux-amd64/kubeless /usr/local/bin\n$ rm -r bundles/\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"deploy-kubeless"}},"Deploy kubeless"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl create ns kubeless\n$ kubectl create -f https://github.com/kubeless/kubeless/releases/download/v1.0.0-alpha.8/kubeless-v1.0.0-alpha.8.yaml\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"deploy-function-on-kubernetes"}},"Deploy function on Kubernetes"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"kubeless function deploy myfunc --runtime nodejs6 --dependencies node-example/package.json --handler test.myfunction --from-file node-example/example.js\n")),o.a.createElement(r.MDXTag,{name:"h4",components:n,props:{id:"useful-functions"}},"Useful functions"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"# List function\n$ kubeless function ls\n# Call function\n$ kubeless function call myfunction --data 'this is some data'\n# Expose function\n$ kubectl create -f nginx-ingress-controller-with-elb.yml\n# Linking the function to the ingress controller\n$ kubeless trigger http create myfunction --function-name myfunction --hostname myfunction.domain.name\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"usage-with-kafka"}},"Usage with Kafka"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},'# Kafka installation\nexport RELEASE=$(curl -s https://api.github.com/repos/kubeless/kafka-trigger/releases/latest | grep tag_name | cut -d \'"\' -f 4)\nkubectl create -f https://github.com/kubeless/kafka-trigger/releases/download/$RELEASE/kafka-zookeeper-$RELEASE.yaml\n\n# Trigger and publish\nkubeless trigger kafka create test --function-selector created-by=kubeless,function=uppercase --trigger-topic uppercase\nkubeless topic publish --topic uppercase --data "this message will be converted to uppercase"\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"7-microservices"}},"7. Microservices"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If we have multiple apps that require information from between each other, we need to start talking about the  ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"service mesh"),". Normally between applications,  we run into the following problems:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"There is no encryption"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No retries."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No fallover."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No intelligent load balancer."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No routing decisions."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No metrics/logs/traces."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No access control.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"One solution is to implement ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"sidecars")," which is a proxy to every single microservice. This can resolve issues such as encryption, retries when a connection fails, intelligent load balancing."),o.a.createElement(r.MDXTag,{name:"p",components:n},"You could also add a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"management interface")," which resolves routing decisions, metrics/logs/traces and access control (ie valid certificate etc)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This brings us to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Istio"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540090167/istio-diagram.png",alt:"Istio diagram"}})),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"71-istio-installation"}},"7.1 Istio Installation"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you want to use Istio, it's worth now using a node with enough memory ie t2.medium."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"kops-configuration"}},"Kops configuration"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kops edit cluster kubernetes.newtech.academy\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Add:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"spec:\n  kubeAPIServer:\n    admissionControl:\n    - NamespaceLifecycle\n    - LimitRanger\n    - ServiceAccount\n    - PersistentVolumeLabel\n    - DefaultStorageClass\n    - DefaultTolerationSeconds\n    - MutatingAdmissionWebhook\n    - ValidatingAdmissionWebhook\n    - ResourceQuota\n    - NodeRestriction\n    - Priority\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"download-102"}},"Download (1.0.2):"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ cd ~\n$ wget https://github.com/istio/istio/releases/download/1.0.2/istio-1.0.2-linux.tar.gz\ntar -xzvf istio-1.0.2-linux.tar.gz\n$ cd istio-1.0.2\n# Alternatively just export the PATH so you don't have to logout\n$ echo 'export PATH=\"$PATH:/home/ubuntu/istio-1.0.2/bin\"' >> ~/.profile\n$ istioctl # check everything is running correctly\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"download-latest"}},"Download (latest):"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ cd ~\n$ curl -L https://git.io/getLatestIstio | sh -\n$ echo 'export PATH=\"$PATH:/home/ubuntu/istio-1.0.2/bin\"' >> ~/.profile # change 1.0.2 in your version -- alternative just export the PATH so you don't have to logout\n$ cd istio-1.0.2 # change 1.0.2 in your version\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"istio-install"}},"Istio install"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Apply CRDs:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl apply -f ~/istio-1.0.2/install/kubernetes/helm/istio/templates/crds.yaml\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Wait a few seconds."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Option 1: with no mutual TLS authentication"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl apply -f ~/istio-1.0.2/install/kubernetes/istio-demo.yaml\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Option 2: or with mutual TLS authentication"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl apply -f ~/istio-1.0.2/install/kubernetes/istio-demo-auth.yaml\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"72-example-app"}},"7.2 Example app"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540091246/Screen_Shot_2018-10-21_at_2.07.07_pm.png",alt:"Example app diagram"}})),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"example-app-from-istio"}},"Example app (from istio)"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},'export PATH="$PATH:/home/ubuntu/istio-1.0.2/bin"\nkubectl apply -f <(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml)\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"hello-world-app"}},"Hello world app"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},'export PATH="$PATH:/home/ubuntu/istio-1.0.2/bin"\nkubectl apply -f <(istioctl kube-inject -f helloworld.yaml)\nkubectl apply -f helloworld-gw.yaml\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"mutual-tls-example"}},"Mutual TLS example"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Create pods, services, destinationrules, virtualservices"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"kubectl create -f <(istioctl kube-inject -f helloworld-tls.yaml)\nkubectl create -f helloworld-legacy.yaml\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"end-user-authentication"}},"End-user authentication"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"kubectl create -f <(istioctl kube-inject -f helloworld-jwt.yaml)\nkubectl create -f helloworld-jwt-enable.yaml\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If we want to access a Pod, we need to use a gateway. "),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# helloworld-gw.yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "*"\n  gateways:\n  - helloworld-gateway\n  http:\n  - match:\n    - uri:\n        prefix: /hello\n    route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        port:\n          number: 8080\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you want a service within Istio, you will always need to define the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"VirtualService"),". We don't need the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"VirtualService")," for services that are accessed by the client."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"73-advanced-istio-routing"}},"7.3 Advanced Istio Routing"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540109060/Screen_Shot_2018-10-21_at_7.04.07_pm.png",alt:"Advanced Routing Setup"}})),o.a.createElement(r.MDXTag,{name:"p",components:n},"Thanks to Istio, we can do advanced routing based around the above diagram thanks to the Deployments having different metadata:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  # ! Subsets is where the magic happens!\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "hello.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - match:\n    - headers:\n        end-user:\n          exact: john\n    route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v2 # ! match v2 only\n        port:\n          number: 8080\n  - route: # default route for hello.example.com\n    - destination:\n        host: ! hello.default.svc.cluster.local\n        subset: v1 # match v1 only\n        port:\n          number: 8080\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},'Now, if we apply this virtual service to the service mesh, then based on whether we pass the "end-user" header or not, we will hit either v1 or v2!'),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"74-canary-deployments"}},"7.4 Canary deployments"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Canary deployments basically want routing mainly to the first version, but we also want some A/B testing to have version 2 having a 10% weight."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "hello.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v1\n        port:\n          number: 8080\n      weight: 90\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v2\n        port:\n          number: 8080\n      weight: 10\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"75-running-retries"}},"7.5 Running retries"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If one of the pods stop working, we can retry to another pod without the client seeing any of the issues. The example app has one of three pods running with a 5s latency but a 2s timeout to demonstrate this. It looks like the following:"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540110459/Screen_Shot_2018-10-21_at_7.26.50_pm.png",alt:"Retry diagram"}})),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"76-mutual-tls"}},"7.6 Mutual TLS"),o.a.createElement(r.MDXTag,{name:"p",components:n},"The goals of Istio security are:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Security by default:")," no changes needed for application code and infrastructure."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Defense in depth:")," integrate with existing security systems to provide multiple layers of defense."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Zero-trust network:")," build security solutions on untrusted networks.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Two types of auth:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Transport authentication (service to service authentication) using Mutual TLS."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Origin authentication (end-user authentication). Verifying the end user using JWTs.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Mutual TLS can be turned on ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"without having to change the code of applications")," (because of the sidecar deployment)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"It provides each service with a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"strong identity"),"."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Attacks like impersonation be rerouting DNS records will fail, because a fake application can't prove its identity using the certificate mechanism."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Secures (encrypts)")," service-to-service and end-user-to-service communication."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Provides key and certificate management to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"manage generation, distribution and rotation"),".")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540153502/Screen_Shot_2018-10-22_at_7.24.10_am.png",alt:"TLS Example App"}})),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Legacy applications with not have a sidecar. "),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"One service will go LTR, and the other RTL.")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: v1\nkind: Namespace\nmetadata:\n  name: ns1\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: ns2\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-tls\n  namespace: ns1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world.ns2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-tls\n  namespace: ns2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "end.legacy:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-reverse-tls\n  namespace: ns2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world-reverse\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "end-reverse.ns1:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: end-reverse-tls\n  namespace: ns1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: end-reverse\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  namespace: ns1\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world\n  namespace: ns2\n  labels:\n    app: world\nspec:\n  selector:\n    app: world\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world-reverse\n  namespace: ns2\n  labels:\n    app: world-reverse\nspec:\n  selector:\n    app: world-reverse\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: end-reverse\n  namespace: ns1\n  labels:\n    app: end-reverse\nspec:\n  selector:\n    app: end-reverse\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.ns1.svc.cluster.local\n  # uncomment to enable mutual TLS\n  #trafficPolicy:\n  #  tls:\n  #    mode: ISTIO_MUTUAL\n  subsets:\n  - name: v1-tls\n    labels:\n      version: v1-tls\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello-reverse\nspec:\n  host: hello-reverse.legacy.svc.cluster.local\n  # uncomment to enable mutual TLS\n  #trafficPolicy:\n  #  tls:\n  #    mode: ISTIO_MUTUAL\n  subsets:\n  - name: v1-tls\n    labels:\n      version: v1-tls\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-tls\nspec:\n  hosts:\n  - "hello-tls.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.ns1.svc.cluster.local\n        subset: v1-tls # match v3 only\n        port:\n          number: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-tls-reverse\nspec:\n  hosts:\n  - "hello-tls-reverse.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello-reverse.legacy.svc.cluster.local\n        subset: v1-tls\n        port:\n          number: 8080\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"As for the missing legacy services, they can be found in the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"helloworld-legacy")," file:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: v1\nkind: Namespace\nmetadata:\n  name: legacy\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: end-tls\n  namespace: legacy\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: end\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-reverse-tls\n  namespace: legacy\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello-reverse\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world-reverse.ns2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: end\n  namespace: legacy\n  labels:\n    app: end\nspec:\n  selector:\n    app: end\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello-reverse\n  namespace: legacy\n  labels:\n    app: hello-reverse\nspec:\n  selector:\n    app: hello-reverse\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"Both these files can applied by running the following:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl apply -f <(istioctl kube-inject -f helloworld-tls.yaml)\n$ kubectl apply -f helloworld-legacy.yaml\n$ kubetl get svc -o wide -n istio-system # get services from istio-system services\n# After getting the load balancer, you can then curl the ELB passing the Host header\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Now we need to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"enable TLS authetication.")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# helloworld-rbac-enable.yaml\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\n# ensures mtls is push to side cars\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "legacy"\nspec:\n  host: "end.legacy.svc.cluster.local"\n  trafficPolicy:\n    tls:\n      mode: DISABLE\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"Apply this file to enable mutual TLS that works one way but not the other (as like in the diagram). However, in the above yaml files we did now enable the traffic policy, so you need to update that and apply the updated files for all of this to work."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"77-rbac-with-istio-and-mtls"}},"7.7 RBAC with Istio and MTLS"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Now that we have MTLS, we have strong identites."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Based on those identities, we can start doing ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Role Based Access Control (RBAC)"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"RBAC allows us to limit access ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"between our services")," and from ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"end-user to services"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Istio is able to verify the identity of a service by ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"checking the identity of the x.509 certificate (which comes with enabled mutual TLS)"),". Example: with RBAC, service A might be able to be contacted by B, but not by C."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Istio is using SPIFFE standard (another CNFC project)."),o.a.createElement(r.MDXTag,{name:"p",components:n},"RBAC in istio:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Can provide ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"service-to-service")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"end-user-to-service")," auth."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Supports ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"conditions")," and ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"role-binding"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can bind to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceAccounts")," (which can be linked to pods)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"End-user-to-service can for example let you create ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"condition on being authenticated using JWT"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"It has high performance."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Not enabled by default."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"We can enable it globally or on a namespace.")))),o.a.createElement(r.MDXTag,{name:"p",components:n},'Example for including it on the "default" namespace:'),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'apiVersion: "rbac.istio.io/v1alpha1"\nkind: RbacConfig\nmetadata:\n  name: default\nspec:\n  mode: \'ON_WITH_INCLUSION\'\n  inclusion:\n    namespaces: ["default"]\n---\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can then create a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"ServiceRole")," specifying the rules and a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"ServiceRoleBinding")," to link a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"ServiceRole")," to a subject (example Kubernetes ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"ServiceAccount"),")."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Example of how we want the demo to look when it comes to what it can contact:"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540155683/Screen_Shot_2018-10-22_at_8.00.47_am.png",alt:"Contact rules"}})),o.a.createElement(r.MDXTag,{name:"p",components:n},"The order for the following is:"),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceRoles")," that only enable certain methods and services with specific access."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Enable ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceRoleBindings")," to bind that the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceRoles")," to a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"subject")," (or ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ingress controller name")," in the first case)."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceAccounts")," that have the correct metadata required for the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceRoleBindings"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Deployments")," that have the affiliated ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceAccount")," required."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Service")," for that ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Deployment"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Gateway")," that uses the default ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Istio Gateway")," to access the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Services"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"VirtualService")," that gives us access to the hello world app through the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Gateway")," connected to the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Service")," which sits within the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"ServiceMesh")," from the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"IngressController"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Create the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"DestinationRule")," that allows allows access to the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"VirtualService")," using ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"MTLS")," from the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"IngressController")," which is a ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"Reverse Proxy internal load balancer")," accessed from the external ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"AWS LoadBalancer")," tied to the accessible ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"DNS Records"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"You can now access the microservice from the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"AWS LoadBalancer Route53 alias")," passing the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"internal namespace domain")," as the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"host header"),".")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# ! helloworld-rbac.yaml file\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRole\nmetadata:\n  name: hello-viewer\n  namespace: default\nspec:\n  rules:\n  - services: ["hello.default.svc.cluster.local"]\n    methods: ["GET", "HEAD"]\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRole\nmetadata:\n  name: world-viewer\n  namespace: default\nspec:\n  rules:\n  - services: ["world.default.svc.cluster.local"]\n    methods: ["GET", "HEAD"]\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRole\nmetadata:\n  name: world-2-viewer\n  namespace: default\nspec:\n  rules:\n  - services: ["world-2.default.svc.cluster.local"]\n    methods: ["GET", "HEAD"]\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRoleBinding\nmetadata:\n  name: istio-ingress-binding\n  namespace: default\nspec:\n  subjects:\n  - properties:\n      source.namespace: "istio-system"\n  roleRef:\n    kind: ServiceRole\n    name: "hello-viewer"\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRoleBinding\nmetadata:\n  name: hello-user-binding\n  namespace: default\nspec:\n  subjects:\n  - user: "cluster.local/ns/default/sa/hello"\n  roleRef:\n    kind: ServiceRole\n    name: "world-viewer"\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRoleBinding\nmetadata:\n  name: world-user-binding\n  namespace: default\nspec:\n  subjects:\n  - user: "cluster.local/ns/default/sa/world"\n  roleRef:\n    kind: ServiceRole\n    name: "world-2-viewer"\n---\n###\n### Kubernetes Service accounts\n###\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: hello\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: world\n---\n###\n### helloworld.yaml deployments, including a serviceaccount\n### for the hello deployment and the world deployment\n###\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1\n    spec:\n      serviceAccountName: hello  # service account\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world\n        version: v1\n    spec:\n      serviceAccountName: world  # service account\n      containers:\n      - name: world\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "world-2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world\n  labels:\n    app: world\nspec:\n  selector:\n    app: world\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world-2\n        version: v1\n    spec:\n      containers:\n      - name: world-2\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world-2\n  labels:\n    app: world-2\nspec:\n  selector:\n    app: world-2\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "hello-rbac.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v1\n        port:\n          number: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  # uncomment to enable mutual TLS\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"This again requires the rbac prequisite:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# helloworld-rbac-enable.yaml\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\n# ensures mtls is push to side cars\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "legacy"\nspec:\n  host: "end.legacy.svc.cluster.local"\n  trafficPolicy:\n    tls:\n      mode: DISABLE\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540159695/Screen_Shot_2018-10-22_at_9.07.45_am.png",alt:"After applying the files to Istio"}})),o.a.createElement(r.MDXTag,{name:"p",components:n},"Evidently enough, it is incredibly important to ensure the routing is set up correctly so there is no large scale failure."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"78-end-user-authentication"}},"7.8 End-user Authentication"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Istio currently supports JWT tokens to authenticate users."),o.a.createElement(r.MDXTag,{name:"p",components:n},"In the implementation, the user will receive a JWT token from an authenticated server after logging in."),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"This app will provide us with a token that is ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"signed with a key"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The data is not encrypted, but the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"token contains a signature"),", which can be ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"verified")," to see ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"whether it was really created by the server"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Only the server has the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"private key"),", so we can't recreate or tamper with the token."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Using microservices, every app would need to be ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"seperately configured"),"."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Every service would need to ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"validate the token"),".",o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Once validated the service would need to check whether the user has access to this service."))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"With Istio, ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"this can be taken away from the app code and managed centrally.")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"You can configure the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"jwt token signature/properties")," you expect in into and have ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"policies to allow/disallow access to a service."),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},'Example "hello" app might only be accessible if user is authenticated.'),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"sidecar")," will verify the ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"li"},"validity")," of the signature, to make sure the token is valid.")))),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540160832/Screen_Shot_2018-10-22_at_9.26.42_am.png",alt:"JWT Token setup"}})),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# Istio with JWT Auth\n# helloworld-jwt.yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-auth\nspec:\n  # this is a change to previous\n  hosts:\n  - "auth.kubernetes.newtech.academy"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: auth.default.svc.cluster.local\n        port:\n          number: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-hello\nspec:\n  hosts:\n  - "hello.kubernetes.newtech.academy"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        port:\n          number: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: auth\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: auth\n        version: v1\n    spec:\n      containers:\n      - name: auth\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: this is the authentication service\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: auth\n  labels:\n    app: auth\nspec:\n  selector:\n    app: auth\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: Hello, you can only reach this service when authenticated\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n###\n### Enable TLS\n###\n---\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"To get to auth, we need to create an alias for ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"auth.domain.name")," in Route 53 to expose the load balancer."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To enable the policy for the JWT token auth to take effect, we need to apply the following to the cluster:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},'# helloworld-jwt-enable.yaml\napiVersion: "authentication.istio.io/v1alpha1"\nkind: "Policy"\nmetadata:\n  name: "jwt-example"\nspec:\n  targets:\n  - name: hello\n  peers:\n  - mtls: {}\n  origins:\n  - jwt:\n      # jwksUri is from auth uri we setup in Route53\n      issuer: "http-echo@http-echo.kubernetes.newtech.academy"\n      jwksUri: "http://auth.kubernetes.newtech.academy/.well-known/jwks.json"\n  principalBinding: USE_ORIGIN\n---\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"After fetching the token, we can now access authenticated routes by passing the header ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},'"Authorization": "Bearer $TOKEN"'),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The example uses ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/wardviaene/http-echo/blob/master/main.go"}},"this Github repo")," with the /login route to do auth and another route to check the auth from other services."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Something useful is that you can also check the logs of the Istio proxy. This can be done with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kubectl logs <% pod_name %> -c istio-proxy"),"."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"79-istio-ingress-traffic"}},"7.9 Istio Ingress Traffic"),o.a.createElement(r.MDXTag,{name:"p",components:n},"To enable ingress traffic to allow to access outside services, we can apply an external service file. The following example will allow the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ifconfig.co")," hostname to be accessible from the pods."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-yaml"}},"# external-service.yaml\n#\n# http\n#\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: ifconfig-co-http\nspec:\n  hosts:\n  - ifconfig.co\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: DNS\n  location: MESH_EXTERNAL\n---\n#\n# https\n#\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: ifconfig-co-https\nspec:\n  hosts:\n  - ifconfig.co\n  ports:\n  - number: 443\n    name: https\n    protocol: HTTPS\n  resolution: DNS\n  location: MESH_EXTERNAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: ifconfig-co\nspec:\n  hosts:\n  - ifconfig.co\n  tls:\n  - match:\n    - port: 443\n      sni_hosts:\n      - ifconfig.co\n    route:\n    - destination:\n        host: ifconfig.co\n        port:\n          number: 443\n      weight: 100\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"You should now be able to log into the pod to try out contacting other services."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"710-distributed-tracing-with-jaegar"}},"7.10 Distributed Tracing with Jaegar"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Jaegar is automatically store in the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"isto-system"),". You can confirm this with the following:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl get pod -n istio-system # istio-tracing pod\n$ kubectl get svc -n istio-system # jaegar-[agent/collector/query]\n# You could export the port for jaegar-query by updating the service\n$ kubectl edit svc jaegar-query -n istio-system # changing ClusterIP to LoadBalancer\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"To find the traces, you need to find the svc ",o.a.createElement(r.MDXTag,{name:"strong",components:n,parentName:"p"},"LoadBalancer")," port for Jaegar Query and then you can access the web url using the port."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"711-istio-metrics-with-grafana"}},"7.11 Istio Metrics with Grafana"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Similar to Jaegar, you can find the Grafana service by getting the services for the Istio System."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash"}},"$ kubectl get svc -n istio-system # grafana\n# You could export the port for grafana by updating the service\n$ kubectl edit svc grafana -n istio-system # changing ClusterIP to LoadBalancer\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"8-intro-to-kubeadm"}},"8. Intro to kubeadm"),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is an alternative to running Kubernetes that is not using ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"kops")))}}])&&l(a.prototype,t),s&&l(a,s),n}();u.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-kubernetes-devops-kubernetes-course.305817e8304de77c75ce.js.map