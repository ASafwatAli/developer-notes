(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{"./manual/JavaScript/JS-RxJS.md":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return u});var t=a("./node_modules/react/index.js"),r=a.n(t),o=a("./node_modules/@mdx-js/tag/dist/index.js");function s(e){return(s="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function c(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}function m(e,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(e,t.key,t)}}function l(e,n){return!n||"object"!==s(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function i(e){return(i=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function p(e,n){return(p=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var u=function(e){function n(e){var a;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(a=l(this,i(n).call(this,e))).layout=null,a}var a,t,s;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&p(e,n)}(n,r.a.Component),a=n,(t=[{key:"render",value:function(){var e=this.props,n=e.components;c(e,["components"]);return r.a.createElement(o.MDXTag,{name:"wrapper",components:n},r.a.createElement(o.MDXTag,{name:"h1",components:n,props:{id:"rxjs"}},"RxJS"),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#rxjs"}},"RxJS"),r.a.createElement(o.MDXTag,{name:"ul",components:n,parentName:"li"},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#10-a-brief-recap-of-programming-paradigms"}},"1.0 A Brief Recap of Programming Paradigms")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#11-core-reactive-concepts"}},"1.1: Core Reactive Concepts")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#12-comparing-the-autocomplete-function-using-js-vs-rxjs"}},"1.2: Comparing the Autocomplete function using JS vs RxJS")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#3-the-core-of-reactive-extensions"}},"3: The Core of Reactive Extensions")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#31-obervables-operators-and-subscriptions"}},"3.1: Obervables, Operators and Subscriptions")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#32-creating-observables"}},"3.2 Creating Observables")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#33-built-in-observables"}},"3.3: Built in Observables")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#34-using-rxjs-with-node-jquery-and-promises"}},"3.4: Using RxJS with Node, jQuery and Promises")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#35-subjects"}},"3.5: Subjects")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#36-rxjs-resources-and-documentation"}},"3.6: RxJS Resources and Documentation")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#37-sharing-observable-sequences"}},"3.7: Sharing Observable Sequences")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#40-operators-that-everyone-should-know"}},"4.0: Operators that everyone should know")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#41-do--finally--startwith--filter"}},"4.1: Do / Finally / StartWith / Filter")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#42-merge--concat"}},"4.2: Merge / Concat")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#43-map--mergemap--switchmap"}},"4.3: Map / MergeMap / SwitchMap")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#44-reduce--scan"}},"4.4: Reduce / Scan")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#45-buffer--toarray"}},"4.5: Buffer / ToArray")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#46-first--last--single--skip--take"}},"4.6: First / Last / Single / Skip / Take")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#47-zip--withlatestfrom--combinelatest"}},"4.7: Zip / WithLatestFrom / CombineLatest")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#48-error-handling-catch-and-retry"}},"4.8: Error Handling Catch and Retry"))))),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"10-a-brief-recap-of-programming-paradigms"}},"1.0 A Brief Recap of Programming Paradigms"),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Procedural Program")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"The ideas that programs are a sense of functions"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Goes from top to bottom"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Relies heavily on global state, but any line can change the global state"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"C being a procedural language"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},'"Imperative" execution'),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Easy to write, difficult to maintain"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Prone to difficult bugs")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Object Oriented")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Based around a Primitive: object"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Objects have well defined interfaces"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Localised behaviour"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Objects control state"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Composition"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Code is still imperative - pro AND con! - Still telling the computer EXACTLY what to do."),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Can be more verbose")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Declarative")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Describing what you want to happen, but not telling the computer how to do it"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Eg. SQL, Regex, HTML"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Data is self-describing"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"As powerful as the interpreter allows"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"As limiting as the interpreter allows - You want build a game in SQL etc.")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Functional")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"What we want to happen but not how"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Little state"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Few side effects"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Easy to reason about"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Composition"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Expressive"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Works great with OO"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Basis in higher math"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Cons to think differently"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Not always the best choice"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"No loops, no control logic - Just telling it what we want to happen")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Reactive")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Primitive: Observable"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Instead of describing data in terms of other data, we describe it in terms of streams of events - From this, we create a pipeline such that we certain data changes, a lot is processed and changed - Example: spreadsheets!"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Composition"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Expressive"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Data flows unidirectionally"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Tough to think differently"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Subscriptions help change the data")),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"const cellC2$ = cellA2$\n    .combineLatest(cellB2$)\n    .map((cells) => cells[0] + cells[1]);\n\ncellC2$.subscribe((value) => {\n    console.log(value);\n});\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"11-core-reactive-concepts"}},"1.1: Core Reactive Concepts"),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Core Concept 1: Pull model vs Push model")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},'any data sitting there that you "ask" for at some point - example refresh button - manual button trigger - time interval'),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"observable (stream) which is a reactive data source - produces items over a period of time that will either error, complete, or never complete until a page closes - not telling the stream when to get data, it has inbuilt logic on how to get data - we may transform this data - the display of the data is actually part of the description")),r.a.createElement(o.MDXTag,{name:"p",components:n},"An an example for a ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"pull")," based code, we can think of a window.setInterval() that fires every 5000 seconds."),r.a.createElement(o.MDXTag,{name:"p",components:n},"An example of a push would be to have a function fire and then the return continutes to filter, flatMap, map and subscribe."),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Core Concept 2: Everything is a database")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"mouse movements"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"current user"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"web requests"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"input boxes")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"12-comparing-the-autocomplete-function-using-js-vs-rxjs"}},"1.2: Comparing the Autocomplete function using JS vs RxJS"),r.a.createElement(o.MDXTag,{name:"p",components:n},"In the comparison where the ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"$title.on('keyup', () => {})")," runs with a promise returned. The query can run into race conditions."),r.a.createElement(o.MDXTag,{name:"p",components:n},"Also note that every single result also fires."),r.a.createElement(o.MDXTag,{name:"p",components:n},"The issues:"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"// Fix up and down arrow\n// Stop always querying\n// Getting race condition\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Bad ways")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"generally ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"if last query == currentTitle return")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"using setTimeout to reduce number of queries"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Race condition still happening, but bad attempts may be increasing the timeout - Could also use a current id compared to next query id and then returning before the callback occurs"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"A lot of state across the module being changed")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"The Rx way")),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// npm install rxjs-es for es6\nimport $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nconst keyUps$ = Rx.Observable.fromEvent($title, \"keyup\");\nconst queries$ = keyUps$\n    .map(e => e.target.value)\n    .distinctUntilChanged()\n    .debounceTime(250)\n    .switchMap(getItems);   // similar to merge, but if new query comes in, discard the old data\n    //.mergeMap(getItems);  // alias for flatMap\n\nqueries$.subscribe(query => {\n    // get rid of the promise will stop race condition\n    $results.empty();\n    $results.append(items.map( r => $(`<li />`).text(r)));\n})\n\n\x3c!-- queries$.subscribe(query => {\n    console.log(e); // prints out event\n    getItems(query)\n        .then(items => {\n            $results.empty();\n            $results.append(items.map( r => $(`<li />`).text(r)));\n        });\n}) --\x3e\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},"An even better way."),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"import $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nRx.Observable.fromEvent($title, 'keyup')\n    .map((e) => e.target.value)\n    .distinctUntilChanged()\n    .debounceTime(500)\n    .switchMap(getItems)\n    .subscribe((items) => {\n        $results.empty();\n        $results.append(items.map((r) => $(`<li />`).text(r)));\n    });\n")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"All the Rx has no external state, whereas the other code does."),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Rx doesn't have to wait for us to tell it when to do it.")),r.a.createElement(o.MDXTag,{name:"hr",components:n}),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"3-the-core-of-reactive-extensions"}},"3: The Core of Reactive Extensions"),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"31-obervables-operators-and-subscriptions"}},"3.1: Obervables, Operators and Subscriptions"),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Observable: Something that can be observed which produces values"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Operator: It's an operation that modifies the data being pushed in from the observable - They don't produce values in and of themselves, but move them through the pipeline."),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Subscriptions: Piece of code that will do something with the values returned by the operators")),r.a.createElement(o.MDXTag,{name:"p",components:n},"Note, you can model anything in a reactive context by thinking a little bit differently."),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Web API Request Example")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Reactive can still complete, or it can error out and retry.")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"32-creating-observables"}},"3.2 Creating Observables"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'import Rx from \'rxjs/Rx\';\n\n# promise will always execute - not lazy\nconst promise = new Promise((resolve, reject) => {\n    console.log("In promise");\n    resolve("hey");\n});\n\npromise.then(item => console.log(item));\n\n# this doesn\'t give any output!\n# observables are lazy!\n# won\'t run without a subscription\nconst simple$ = new Rx.Observable(observer => {\n    console.log("Generating observable");\n    setTimeout(() => {\n        observer.next("An items!");\n        setTimeout(() => {\n            observer.next("Another item!");\n            observer.complete();\n        }, 1000);\n    }, 1000);\n});\n\n# creating a subscription\n# first arg is the next function\n# second arg is error\n# third arg is complete\nsimple$.subscribe(\n    item => console.log(`one.next ${item}`),\n    error => console.log(`one.error ${item}`),\n    () => console.log("one.complete")\n);\n\n# Generating observable\n# one.next An item!\n# one.next Another item!\n# one.complete\n\nsetTimeout(() => {\n    simple$.subscribe({\n        next: item => console.log(`two.next ${item}`),\n        error: error => console.log(`two.error ${item}`),\n        complete: () => console.log("two.complete")\n    });\n}, 3000)\n')),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Re-subscribing to an observable allows you to run that generator again")),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'function createInterval(time) {\n    return new Rx.Observable(observer => {\n        let index = 0;\n        let interval = setInterval(() => {\n            observer.next(index++);\n        }, time);\n\n        return () => {\n            // will run when we unsubscribe\n            clearnInterval(interval);\n        };\n    });\n}\n\nfunction createSubscriber(tag) {\n    return {\n        next(item) { console.log(`${tag}.next ${item}`); },\n        error(error) { console.log(`${tag}.error ${error.stack || error }`); },\n        complete() { console.log(`${tag}.complete`); }\n    };\n}\n\nfunction take(observable, amount) {\n    return new Rx.Observable(observer => {\n\n    });\n}\n\n// this is the core of subscriptions\nfunction take(sourceObservable, amount) {\n    return new Rx.Observable(observer => {\n        let count = 0;\n        const subscription = sourceObservable.subscribe({\n            next(item) {\n                observer.next(item);\n                if (++count >= amount) {\n                    observer.complete();\n                }\n            },\n            error(error) { observer.error(error); },\n            complete() { observer.complete(); }\n        });\n\n        return () => subscription.unsubscribe();\n    });\n}\n\nconst everySecond_ = createInterval(1000);\nconst firstFiveSeconds = take(everySecond_, 5);\nconst subscription = everySecond_.subscribe(createSubscriber("one"));\nsetTimeout(() => {\n    subscription.unsubscribe();\n}, 3500);\n')),r.a.createElement(o.MDXTag,{name:"p",components:n},"This subscription will console.log out forever and ever and ever... - unless, we dispose of a description"),r.a.createElement(o.MDXTag,{name:"p",components:n},"How do operators come into play?"),r.a.createElement(o.MDXTag,{name:"p",components:n},"We could run something like ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},'const subscription = everySecond_.take(3)subscribe(createSubscriber("one"));')),r.a.createElement(o.MDXTag,{name:"p",components:n},"The steps for it are that it listens for a source and emits a transformation!"),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"33-built-in-observables"}},"3.3: Built in Observables"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'import Rx from \'rxjs/Rx\';\n\n\nRx.Observable.interval(500)\n    .take(5)\n    .subscribe(createSubscriber("interval"));\n\nRx.Observable.timer(1000, 500)\n    .take(3)\n    .subscribe(createSubscriber("timer");\n\n// note, array doesn\'t work - use from\nRx.Observable.of("Hello world!", 42, "whoa")\n    .subscribe(createSubscriber("of"));\n\nRx.Observable.from(["Hello world!", 42, "whoa"])\n    .subscribe(createSubscriber("of"));\n\nRx.Observable.from(generate())\n    .subscribe(createSubscriber("of"));\n\n\nRx.Observable.from("hello world!")\n    .subscribe(createSubscriber("of"));\n\n// it can also take in a generator function!\n\nfunction* generate() {\n    yield 1;\n    yield 5;\n    yield "HEY";\n}\n\nRx.Observable.throw(new Error("Hey"))\n    .subscribe(createSubscriber("error"));\n\n// empty\nRx.Observable.empty()\n    .subscribe(createSubscriber("empty"));\n\n// defer\nlet sideEffect = 0;\nconst defer = Rx.Observable.defer(() => {\n    sideEffect++;\n    return Rx.Obserable.of(sideEffect);\n});\n\ndefer.subscribe(createSubscriber("defer.one"));\ndefer.subscribe(createSubscriber("defer.two"));\ndefer.subscribe(createSubscriber("defer.three"));\n\nRx.Observable.never()\n    .subscribe(createSubscriber("never"));\n\nRx.Observable.range(10, 30)\n    .subscribe(createSubscriber("range"));\n')),r.a.createElement(o.MDXTag,{name:"p",components:n},"Benefits of the iterable ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"from"),"?"),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"For every iterable, we could map every element.")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"34-using-rxjs-with-node-jquery-and-promises"}},"3.4: Using RxJS with Node, jQuery and Promises"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"Rx.Observable.fromEvent($title, 'keyup')\n    .map((e) => e.target.value)\n    .distinctUntilChanged()\n    .debounceTime(500)\n    .switchMap(getItems)\n    .subscribe((items) => {\n        $results.empty();\n        $results.append(items.map((i) => $('<li />').text(i)));\n    });\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},"NOTE: Without the subscribe, it will never be subscribed to the dom!"),r.a.createElement(o.MDXTag,{name:"p",components:n},"If we have the ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".take(10)")," - it would complete after taking 10 and then furthermore unsubscribe and be great for performance!"),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"fromEvent")," calls from ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"addEventListener"),", so it can do powerful things like ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"keyup")," for those that don't initially support it."),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"import fs from 'fs';\n\nfs.readdir('./src/server', (err, items) => {\n    if (err) console.log(err);\n    else {\n        console.log(items);\n    }\n});\n\n// alternative\nconst readdir = Rx.Observable.bindNodeCallBack(fs.readdir);\n\nreaddir('./src/server')\n    // mergeMap creates iterable converted from array\n    .mergeMap((files) => Rx.Observable.from(files))\n    .map((file) => `MANIPULATED ${file}`)\n    .subscribe(createSubscriber('readdir'));\n\n// promises\n\nfunction getItem() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('Hello');\n        }, 1000);\n    });\n}\n\nRx.Observable.fromPromise(getItem()).subscribe(createSubscriber('promise'));\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"35-subjects"}},"3.5: Subjects"),r.a.createElement(o.MDXTag,{name:"p",components:n},"Subjects are another Rx primitive. They are both an observable and a observer! Used to bridge non-reactive code with reactive code."),r.a.createElement(o.MDXTag,{name:"p",components:n},"Behaviour, replay subjects etc."),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"em",components:n,parentName:"p"},"Warning"),": you should only really consider them as a last resort when bridging non-reactive and reactive code."),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"const simple = new Rx.Subject();\n\nsimple.subscribe(createSubscriber('simple'));\n\nsimple.next('Hello');\nsimple.next('World');\nsimple.complete();\n\nconst interval = Rx.Observable.interval(1000).take(5);\nconst intervalSubject = new Rx.Subject();\nintervalSubject.subscribe(interval);\n\nintervalSubject.subscribe(createSubscriber('sub1'));\nintervalSubject.subscribe(createSubscriber('sub2'));\nintervalSubject.subscribe(createSubscriber('sub3'));\n\n// subscribes after three seconds\nsetTimeout(() => {\n    intervalSubject.subscribe(createSubscriber('LOOK AT ME'));\n}, 3000);\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},"Before, we had to invoke a function that call ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"next")," and ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"complete"),"."),r.a.createElement(o.MDXTag,{name:"p",components:n},"In the above example, intervalSubject is acting as a proxy to another observable."),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// needs init state parameter\nconst currentUser = new Rx.BehaviorSubject({ isLoggedIn: false });\nconst isLoggedIn = currentUser.map((u) => u.isLoggedIn);\n\ncurrentUser.next({ isLoggedIn: false });\nisLoggedIn.subscribe(createSubscriber('isLoggedIn'));\n\nsetTimeout(() => {\n    currentUser.next({ isLoggedIn: true, name: 'nelson' });\n}, 3000);\n\nsetTimeout(() => {\n    isLogged.subscribe(createSubscription('delayed'));\n}, 1500);\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},"How do you remember multiple states?"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'const replay = new Rx.ReplaySubject(3);\nreplay.next(1);\nreplay.next(2);\n\nreplay.subscribe(createSubscriber("one"));\n\nreplay.next(3);\nreplay.next(4);\nreplay.next(5);\n\n// this subscription only gets the previous three items\nreplay.subscribe(createSubscriber("two"));\n\nreplay.next(6);\n\n// what you see\none.next 1\none.next 2\none.next 3  \none.next 4  \none.next 5  \ntwo.next 3\ntwo.next 4\ntwo.next 5\none.next 6\ntwo.next 6\n')),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Async Subjects")),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'const apiCall = new Rx.AsyncSubject();\napiCall.next(1);\n\napiCall.subscribe(createSubscriber("one"));\napiCall.next(2);\n\n// only will emit the final item before it is complete\napiCall.complete();\n\n// if you subscribe to it again, that final value will be emitted\nsetTimeout(() => {\n    apiCall.subscribe(createSubscriber("two"));\n}, 2000);\n\n// output\none.next 2\none.complete\ntwo.next 2\ntwo.complete\n')),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Subject Summary")),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"if you can get around it, don't use subjects unless you have to"),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"you should use an observable workflow where possible")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"36-rxjs-resources-and-documentation"}},"3.6: RxJS Resources and Documentation"),r.a.createElement(o.MDXTag,{name:"p",components:n},"Sources:"),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"https://github.com/ReactiveX/rxjs"}},"RxJS Github")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"http://rxmarbles.com/"}},"RxMarbles")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},r.a.createElement(o.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"http://jaredforsyth.com/rxvision/examples/playground/"}},"RxVision Playground"))),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"37-sharing-observable-sequences"}},"3.7: Sharing Observable Sequences"),r.a.createElement(o.MDXTag,{name:"ul",components:n},r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Hot Observable: It will produce events regardless of if you're listening - eg.",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"fromEvent($title, 'keyup')")),r.a.createElement(o.MDXTag,{name:"li",components:n,parentName:"ul"},"Cold Obserable: Starts once you subscribe - Interval Observables are actually cold observables")),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// this example shows when both start from the beginning eg cold\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000).take(10);\n\nsetTimeout(() => {\n    interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n    interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// HOT\n// connectable observable\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000)\n    .take(10)\n    .publish();\n\ninterval.connect();\n\nsetTimeout(() => {\n    interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n    interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// if you connect after a set interval, then it begins executing and sharing the underlying observable\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"strong",components:n,parentName:"p"},"Why would you want a hot variable?")),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// here subscribe console.log runs twice\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n    console.log('subscribed');\n    socket.on('chat:message', (message) => observer.next(message));\n});\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// without it\n\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n    console.log('subscribed');\n    socket.on('chat:message', (message) => observer.next(message));\n}).publish();\n\nchatMessage.connect();\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// using publishLast()\nconst simple = new Rx.Observable((observer) => {\n    observer.next('one');\n    observer.next('two');\n    observer.complete();\n});\n\n// always returns the last value\nconst published = simple.publishLast();\n\n// even if we subscribe before connect, both will get the last value\npublished.subscribe(createSubscriber('one'));\npublished.connect();\npublished.subscribe(creaSubscriber('two'));\n\n// using publishReplay()\nconst simple = new Rx.Observable((observer) => {\n    observer.next('one');\n    observer.next('two');\n    observer.next('three');\n\n    return () => console.log('Disposed');\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2);\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber('one'));\nconst connection = published.connect();\nconst sub2 = published.subscribe(creaSubscriber('two'));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n\nconnection.unsubscribe();\n")),r.a.createElement(o.MDXTag,{name:"p",components:n},"Refcount is a way to automatically handle the connection and the unsubscription of a connection observable."),r.a.createElement(o.MDXTag,{name:"p",components:n},"It will connect to the first subscription and then disconnected on the last unsubscribe."),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},'// using refCount()\nconst simple = new Rx.Observable(observer => {\n    observer.next("one");\n    observer.next("two");\n    observer.next("three");\n\n    return () => console.log("Disposed");\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2).refCount();\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber("one"));\nconst sub2 = published.subscribe(creaSubscriber("two"));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n')),r.a.createElement(o.MDXTag,{name:"p",components:n},"The ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"publish().refCount()")," is done so often, that is has been turned in ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"share()"),"."),r.a.createElement(o.MDXTag,{name:"p",components:n},"Taxing processes that you don't want to repeat but you want multiple things to hook into the result, then turn it into a hot subscription."),r.a.createElement(o.MDXTag,{name:"hr",components:n}),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"40-operators-that-everyone-should-know"}},"4.0: Operators that everyone should know"),r.a.createElement(o.MDXTag,{name:"p",components:n},"Now we will just talk about the different primary operators that you will work with."),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"41-do--finally--startwith--filter"}},"4.1: Do / Finally / StartWith / Filter"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// do => get the next value and pass it back unchanged\n// finally => only completes after the range has completed, runs right at the end of the final value\n// filter => filters out given statement\n// interval => call timeout\n// startWith => set initial value\n\nRx.Observable.range(1, 10)\n    .do((a) => console.log(`From do ${a}`))\n    .map((a) => a * a)\n    .subscribe(createSubscriber('simple'));\n\nRx.Observable.range(1, 10)\n    .finally(() => console.log(`From finally`))\n    .map((a) => a * 2)\n    .subscribe(createSubscriber('finally'));\n\nRx.Observable.range(1, 10)\n    .filter((a) => a < 5)\n    .map((a) => a * 2)\n    .subscribe(createSubscriber('filter'));\n\nRx.Observable.interval(1000)\n    .startWith(-1)\n    .subscribe(createSubscriber('interval'));\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"42-merge--concat"}},"4.2: Merge / Concat"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'// merge - merge many observables togethers\n// concat - this concatenates observables to the end of another, can also take a list of Observables\n\nRx.Observable.interval(1000)\n    .merge(Rx.Observable.interval(500))\n    .take(5)\n    .subscribe(createSubscriber("merge1"));\n\nRx.Observable.merge(\n    Rx.Observable.interval(1000).map(i => `${i} seconds),\n    Rx.Observable.interval(500).map(i => `${i} half seconds))\n    .take(5)\n    .subscribe(createSubscriber(\'merge2\'));\n\n// different events for merged observables\nRx.Observable.merge(\n    socket.on$("login").map(user => processUser(user),\n    socket.on$("logout").map(() => null));\n\nRx.Observable.range(1, 5)\n    .concat(Rx.Observable.range(10,3))\n    .subscribe(createSubscriber("concat1"));\n')),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"43-map--mergemap--switchmap"}},"4.3: Map / MergeMap / SwitchMap"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// map - a projection on every item that comes in\n// mergeMap - select many, does projection and then has another thing that we will work on\n// switchMap - similar to mergeMap but replaces with the latest value if another emission comes in\n\nfunction arrayMap(arr, proj) {\n    let returnArray = [];\n    for (let i of arr) {\n        returnArray.push(proj(item));\n    }\n\n    return returnArray;\n}\n\narrayMap([1, 2, 3], (a) => a * a);\n\n// imagine array of dicts\nconst albums = [{}, {}];\n\nfunction arrayMergeMap(arr, proj) {\n    let returnArray = [];\n    for (let i of arr) {\n        let projArray = proj(item);\n        for (let j of projArray) {\n            returnArray.push(proj(item));\n        }\n    }\n\n    return returnArray;\n}\n\nconst tracks = arrayMergeMap(albums, (album) => album.tracks);\n\nRx.Observable.range(1, 3)\n    .mergeMap((i) =>\n        Rx.Observable.timer(i * 1000).map(() => `After ${i} seconds`)\n    )\n    .subscribe(createSubscriber('mergeMap'));\n\nRx.Observable.fromPromise(getTracks())\n    .mergeMap((tracks) => Rx.Observable.from(tracks))\n    .subscribe(createSubscriber('tracks'));\n\nfunction getTracks() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(['track 1', 'track 2', 'track 3']);\n        }, 1000);\n    });\n}\n\n// synchronous example\nRx.Observable.of('my query')\n    .do(() => console.log('Querying'))\n    .mergeMap((a) => query(a))\n    .do(() => console.log('After querying'))\n    .subscribe(createSubscriber('query'));\n\nfunction query(value) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('This is the resolved value');\n        }, 1000);\n    });\n}\n\n// switch map\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"44-reduce--scan"}},"4.4: Reduce / Scan"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"// reducer (acc, value) and works on value - doesn't emit until the completion\n// scan - processes and emits as it comes in\nRx.Observable.range(1, 10)\n    .reduce((acc, value) => acc + value)\n    .subscribe(createSubscriber('reduce'));\n\nRx.Observable.range(1, 10)\n    .scan((acc, value) => acc + value)\n    .subscribe(createSubscriber('scan'));\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"45-buffer--toarray"}},"4.5: Buffer / ToArray"),r.a.createElement(o.MDXTag,{name:"p",components:n},"There have been some big changes to how ",r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"buffer")," has been used."),r.a.createElement(o.MDXTag,{name:"p",components:n},"Buffer takes in an observable."),r.a.createElement(o.MDXTag,{name:"p",components:n},"toArray will convert results into an array. - still has a clean exit if the never() is implemented!"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},'Rx.Observable.range(1, 100)\n    .bufferCount(25)\n    .subscribe(createSubscriber("items");\n\n// will take 25 items and pushing them into an array\n\n\nRx.Observable.interval(500)\n    .bufferTime(2000)\n    .subscribe(createSubscriber("bufferTime");\n\n// same behaviour!\n// emitting event causes buffer to flush\nRx.Observable.interval(500)\n    .buffer(Rx.Observable.interval(2000))\n    .subscribe(createSubscriber("buffer");\n\n//\n// toArray\n//\n\nRx.Observable.range(1, 10)\n    .toArray()\n    .subscribe(createSubscriber("range"));\n')),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"46-first--last--single--skip--take"}},"4.6: First / Last / Single / Skip / Take"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"const simple = new Rx.Observable((observer) => {\n    console.log('Generating sequence');\n    observer.next(1);\n    observer.next(2);\n    observer.next(3);\n    observer.next(4);\n    observer.complete();\n});\n\nsimple.first().subscribe(createSubscriber('first'));\n\nsimple.last().subscribe(createSubscriber('last'));\n\n// displays 1 & 4\n// if nothing is in there, there are EmptyError(s) thrown\n\n// single.error thrown is more than one error thrown\nsimple.single().subscribe(createSubscriber('single'));\n\n// take and skip won't throw errors\n// take does the first however emissions\n// skip will take the emissions after a number\nsimple.take(2).subscribe(createSubscriber('take'));\n\nsimple.skip(2).subscribe(createSubscriber('skip'));\n\n// 3, 4\nsimple\n    .skip(2)\n    .take(2)\n    .subscribe(createSubscriber('skip'));\n\n// skipWhile / takeWhile\nRx.Observable.interval(500)\n    .skipWhile((i) => i < 4)\n    .takeWhile((i) => i < 10)\n    .subscribe(createSubscriber('skipWhile/takeWhile'));\n\n// what's until and take emissions until\nRx.Observable.interval(500)\n    .skipUntil(Rx.Observable.timer(1000))\n    .takeUntil(Rx.Observable.timer(4000))\n    .subscribe(createSubscriber('skipUntil'));\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"47-zip--withlatestfrom--combinelatest"}},"4.7: Zip / WithLatestFrom / CombineLatest"),r.a.createElement(o.MDXTag,{name:"p",components:n},"How can we combine observables in different ways?"),r.a.createElement(o.MDXTag,{name:"pre",components:n},r.a.createElement(o.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript"}},"function arrayZip(arr1, arr2, selectorFunc) {\n    const count = Math.min(arr1.length, arr2.length);\n    const results = [];\n\n    for (let i = 0; i < count; i++) {\n        const combined = selector(arr1[i], arr2[i]);\n        results.push(combined);\n    }\n\n    return results;\n}\n\nconst arr1 = [32, 2, 52, 43, 54];\nconst arr2 = [1, 0, 10, 4, 1, 4, 6, 2];\nconst results = arrayZip(arr1, arr2, (left, right) => left * right);\n\nconsole.log(results);\n\n// in RxJS\nRx.Observable.range(1.1)\n    .zip(\n        Rx.Observable.interval(500),\n        (left, right) => `item: ${left}, at ${right * 500}`\n    )\n    .subscribe(createSubscriber('zip'));\n\n// emits value when source emits\n// can also pass (left, right) function like zip as second parameter\nRx.Observable.interval(1000)\n    .withLatestFrom(Rx.Observable.interval(500))\n    .subscribe(createSubscriber('withLatestFrom'));\n\n// emit value if either do\nRx.Observable.interval(1000)\n    .combineLatest(Rx.Observable.interval(500))\n    .subscribe(createSubscriber('withLatestFrom'));\n")),r.a.createElement(o.MDXTag,{name:"h2",components:n,props:{id:"48-error-handling-catch-and-retry"}},"4.8: Error Handling Catch and Retry"),r.a.createElement(o.MDXTag,{name:"p",components:n},"If an error happens, an observer stops emitting and can prevent values from emitting at all. Error handling is very important!"),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".catch(error => Rx.Observable.of(error))")," can pass this down as an Observable."),r.a.createElement(o.MDXTag,{name:"p",components:n},r.a.createElement(o.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".retry()")," we can pass in with a numeral to ensure that we either keep retrying or retry a certain number of times."))}}])&&m(a.prototype,t),s&&m(a,s),n}();u.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-java-script-js-rx-js.305817e8304de77c75ce.js.map