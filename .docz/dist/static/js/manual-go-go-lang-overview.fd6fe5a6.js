(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{"./manual/Go/Go-Lang-Overview.md":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return g});var t=a("./node_modules/react/index.js"),o=a.n(t),r=a("./node_modules/@mdx-js/tag/dist/index.js");function m(e){return(m="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function c(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}function s(e,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(e,t.key,t)}}function l(e,n){return!n||"object"!==m(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function p(e){return(p=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function i(e,n){return(i=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var g=function(e){function n(e){var a;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(a=l(this,p(n).call(this,e))).layout=null,a}var a,t,m;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&i(e,n)}(n,o.a.Component),a=n,(t=[{key:"render",value:function(){var e=this.props,n=e.components;c(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"go-language-overview"}},"Go Language Overview"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#go-language-overview"}},"Go Language Overview"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#types"}},"Types")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#packages---public-and-private-variables"}},"Packages - public and private variables")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#variables"}},"Variables"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#variable-declarations-and-assigning"}},"Variable declarations and assigning")))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#functions"}},"Functions"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#multiple-return-values"}},"Multiple return values")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#the-go-formatting-tool"}},"The Go Formatting Tool")))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#control-structures"}},"Control Structures"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#for-loops"}},"For loops")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#if-statements"}},"If statements")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#switch-statement"}},"Switch statement")))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#data-structures"}},"Data Structures"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#pointers"}},"Pointers")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#arrays"}},"Arrays")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#slices"}},"Slices")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#maps"}},"Maps")))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#custom-types"}},"Custom Types"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#methods"}},"Methods")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#structs"}},"Structs")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#interfaces"}},"Interfaces"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#challenge"}},"Challenge")))))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#concurrency"}},"Concurrency"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#channels"}},"Channels"),o.a.createElement(r.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#challenge-1"}},"Challenge")))))),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"#summary"}},"Summary"))))),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"types"}},"Types"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"int, int8 etc"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"bool"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"string"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"float32, float64 (64 by default)")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"packages---public-and-private-variables"}},"Packages - public and private variables"),o.a.createElement(r.MDXTag,{name:"p",components:n},"When it comes to declaring variables, to have them available to other files when the package is imported, declare the variable with a capital letter."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Lowercase variables are private."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"variables"}},"Variables"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'// outside of func\nvar greeting = "hello"\n\nfunc main() {\n    // inside of func\n    greeting := "Hello from Go"\n    fmt.Println(test)\n    fmt.Println(greeting)\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"variable-declarations-and-assigning"}},"Variable declarations and assigning"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},"func main() {\n    var a int\n    a = 2\n    var b, c int\n    b = 2\n    c = 3\n    d := 5  // same as var d = 5\n    var e = 10 // type is inferred\n\n    // you'll need to use all the above variables\n    // otherwise there will be a declaration err\n    // thrown\n}\n")),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Variable names must start with a letter"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Uppercase variables and funcs can be used outside of the package"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Lowercase cannot"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Declaring type can come after the variable name eg ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"var floating float64 = 1.4")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Casting ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"float64(variable)")),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Errors are thrown for mismatched types"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"For scope, you are able to declare blocks by themselves - Each package is a implicit block")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"functions"}},"Functions"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'// not available outside the package\nfunc main() {\n    myFunction()\n}\n\nfunc myFunction() {\n    fmt.Println("Running myFunction")\n}\n\nfunc MyPublicFunction() {\n    fmt.Println("Running MyPublicFunction")\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can enforce type safety for parameters by adding the type expected to the function ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"func myFunc(test string, number int) {}")),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Go doesn't allow default parameter values"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No named values"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"No method overloading")),o.a.createElement(r.MDXTag,{name:"p",components:n},"For returning a certain value, you can enfore this by the following"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"func myFunc(test string, number int) int {}\nfunc myFuncTwo(numberOne int, number int) (sum int) {\n    return number + numberOne;\n}\nfunc myFuncThree(number int) (difference int) {\n    difference = number + 4;\n}\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"multiple-return-values"}},"Multiple return values"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt",\n    "math",\n    "log"\n)\n\nfunc main() {\n    squareRoot, err := squareRoot(-1)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(squareRoot)\n}\n\nfunc squareRoot(x float64) (float64, error) {\n    x < 0 {\n        return 0, fmt.Errorf("Can\'t take a negative number")\n    }\n    return math.Sqrt(x), nil\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"As for errors"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt",\n    "os"\n)\n\n// panic errors - no good!\nfunc mainBad() {\n    fileInfo, _ := os.Stat("existent.txt")\n    fmt.Println(fileInfo.Size())\n    fileInfo, _ := os.Stat("nonexistent.txt")\n    fmt.Println(fileInfo.Size())\n}\n\n// instead, do this\nfunc main() {\n    fileInfo, error := os.Stat("existent.txt")\n    if error != nil {\n        fmt.Println(error)\n    } else {\n        fmt.Println(fileInfo.Size())\n    }\n    fileInfo, error := os.Stat("nonexistent.txt")\n    if error != nil {\n        fmt.Println(error)\n    } else {\n        fmt.Println(fileInfo.Size())\n    }\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"the-go-formatting-tool"}},"The Go Formatting Tool"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"go fmt <filename>")," will update the file itself and it will nicely format it."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"control-structures"}},"Control Structures"),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"for-loops"}},"For loops"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},"for i := 1; i <= 3; i++ {\n    fmt.Println(i)\n}\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"if-statements"}},"If statements"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'if true {\n    fmt.Println("You\'ll come here")\n} else if false {\n    // ...\n} else {\n    // ...\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"switch-statement"}},"Switch statement"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Switch statements look like they do not need a break."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'switch doorNumber {\n    case 1:\n        fmt.Println("new car ")\n    case 2:\n        // ...\n    default:\n        // ...\n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"data-structures"}},"Data Structures"),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"pointers"}},"Pointers"),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can create a pointer to a variable too."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport "fmt"\n\nfunc main() {\n    var aValue float64 = 1.23\n    var aPointer *float64 = &aValue\n    fmt.Println("aPointer", aPointer)\n    fmt.Println("*aPointer", *aPointer)\n}\n\n/*\n    Prints\n    aPointer 0xc42000a3b8\n    *aPointer 1.23\n */\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are situations where the pointer is better to use than using a value directly."),o.a.createElement(r.MDXTag,{name:"ol",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Functions that need to affect their argument. Args in funcs are always passed by value. The function recieves a copy of the value."),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ol"},"Passing a complex value to a function - example a complex struct")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'// Example\npackage main\n\nimport "fmt"\n\n// Not using the pointer\nfunc main() {\n    num := 8.2\n    halve(num)\n    fmt.Println(num)\n}\n\nfunc halve(number float64) {\n    number = number / 2;\n    fmt.Println(number)\n}\n\n// Using the pointer\npackage main\n\nimport "fmt"\n\n// Not using the pointer\nfunc main() {\n    num := 8.2\n    halve(&num)\n    fmt.Println(num)\n}\n\nfunc halve(number *float64) {\n    *number = *number / 2\n    fmt.Println(*number)\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"arrays"}},"Arrays"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Slices are used more commonly used than arrays, but given they are built on arrays, we'll explore arrays first."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'func main() {\n    var months [3]string // array of three strings\n    months[0] = "Jan"\n    months[1] = "Feb"\n    months[2] = "Mar"\n    fmt.Println(months[0])\n    // also could be months := [3]string{"Jan", "Feb", "Mar"}\n\n    for i := 0; i < len(months); i++ {\n        fmt.Println(months[i])\n    }\n\n    // another way to loop through the array\n    for i, month := range months {\n        fmt.Println(month)\n    }\n\n    // omit the index\n    for _, month := range months {\n        fmt.Println(month)\n    }\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"The main limitation arrays are used are because you cannot assign values to an array larger than it's initial allocated memory size."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"slices"}},"Slices"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Slices also represent an array. Slices are easier to work with."),o.a.createElement(r.MDXTag,{name:"p",components:n},"While ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"len")," shows the length, ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"cap")," shows the capacity of how it can grow."),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"append")," can be used to append to a slice."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport "fmt"\n\nfunc main() {\n    a := [5]int{0,1,2,3,4}\n    s1 := a[0:3]\n    s2 := a[2:5]\n    fmt.Println(a, s1, s2)\n    // prints [0 1 2 3 4] [0 1 2] [2 3 4]\n    a[2] = 88\n    fmt.Println(a, s1, s2)\n    // prints [0 1 88 3 4] [0 1 88] [2 3 88]\n    s1 = s1[0:4]\n    fmt.Println(a, s1, s2)\n    // prints [0 1 88 3 4] [0 1 88 3] [88 3 4]\n    s2 = s2[0:4] // throws an error\n    s2 = append(s2, 5) // returns a new slice\n    fmt.Println(a, s1, s2)\n    // prints [0 1 88 3 4] [0 1 88 3] [88 3 4 5]\n    s2[0] = 999\n    // prints [0 1 88 3 4] [0 1 88 3] [999 3 4 5]\n\n    // Declaring an array on its own\n    s3 := []int{1, 2, 3}\n    fmt.Println(s3) // prints [1 2 3]\n    s3 = append(s3, 4, 5)\n    fmt.Println(s3) // [1 2 3 4 5]\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"maps"}},"Maps"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Slices are good for storing collections, but the only way to get elements back is by the index."),o.a.createElement(r.MDXTag,{name:"p",components:n},"While in most collections you have dictionaries, hashes, hash maps, Go refers to these data structures as ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Maps"),"."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'func main() {\n    ages := map[string]float64{}\n    ages["Alice"] = 12\n    ages["Bob"] = 9\n    fmt.Println(ages) // prints map[Alice:12 Bob:9]\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"Similar to arrays or slices, we can use a literal to prefill the values."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'func main() {\n    ages := map[string]float64{"Alice":12, "Bob":9}\n    fmt.Println(ages) // prints map[Alice:12 Bob:9]\n    for name, age := range ages {\n        fmt.Println(name, age)\n    }\n\n    for _, age := range ages {\n        fmt.Println(age)\n    }\n\n    for name := range ages {\n        fmt.Println(name)\n    }\n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"custom-types"}},"Custom Types"),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can use the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"type")," keyword to define a type and it's underlying type."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport "fmt"\n\ntype Minutes int\ntype Hours int\n\nfunc main() {\n    minutes := Minutes(37)\n    hours := Hours(37)\n\n    fmt.Println(minutes, hours)\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can also compare custom types to their underlying type. However two custom types with the same underlying type cannot be compared."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The more commonly used aggregate type is a Struct which is how we can base custom types on them."),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"methods"}},"Methods"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Define new behaviours for types."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt"\n    "strings"\n)\n\ntype Title string\n\n// the following has an extra reciever arg t\nfunc (t Title) FixCase() string {\n    return strings.Title(string(t))\n}\n\nfunc main() {\n    name := Title("the matrix")\n    fixed := name.FixCase()\n    fmt.Println(fixed)\n}\n')),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt"\n)\n\ntype Hours int\n\nfunc (h *Hours) Increment() Hours {\n  *h = (*h + 1) % 24\n  return *h\n}\n\nfunc main() {\n  hours := Hours(23)\n  hours.Increment()\n  fmt.Println(hours) // Prints "0"\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"structs"}},"Structs"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport "fmt"\n\ntype Monitor struct {\n    Resolution  string\n    Connector   string\n    Value       float64 // fields with a name and a type\n}\n\nfunc main() {\n    monitor := Monitor{}\n    monitor.Resolution = "1080p"\n    monitor.Connector = "HDMI"\n    monitor.Value = 249.99\n    fmt.Println(monitor.Resolution, monitor.Connector, monitor.Value)\n\n    // could also go monitor := Monitor{"1080p", "HDMI", 249.99}\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you init and allocate a struct, it will initialise with some default values."),o.a.createElement(r.MDXTag,{name:"p",components:n},'You can also add a "exported" get and set method to help enforce the concept of private variables.'),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt"\n)\n\ntype Clock struct {\n  Hours int\n  Minutes int\n}\n\n// DEFINE A "Noon" FUNCTION HERE\nfunc Noon(hours int, min int) Clock {\n  c := Clock{}\n  c.Hours = 12\n  c.Minutes = 0\n\n  return c\n}\n\nfunc main() {\n  c := Noon(12, 10)\n  fmt.Println(c)\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"interfaces"}},"Interfaces"),o.a.createElement(r.MDXTag,{name:"p",components:n},"When you have a concrete type, you know what it is and what it can do. An interface is defining what something is but not what it can do."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},"type FourLegged interface {\n    Walk()\n    Sit()\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Implementation in practise"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'type Part interface {\n    Specs() string\n    Price() string\n}\n\nfunc Summary(part Part) string {\n    return part.Specs() + "/n" + part.Price()\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"If we create slice with that type as well, then we can use that slice for anything that satisfies the interface. This could allow us to slice, append to the slice and use the range to iterate through."),o.a.createElement(r.MDXTag,{name:"h4",components:n,props:{id:"challenge"}},"Challenge"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'// calendar.go\npackage calendar\n\nimport "fmt"\n\ntype Calendar struct {\n  Year int\n  Month int\n  Day int\n}\n\nfunc (c Calendar) Display() {\n  fmt.Printf("%04d-%02d-%02d", c.Year, c.Month, c.Day)\n}\n\n// clock.go\npackage clock\n\nimport "fmt"\n\ntype Clock struct {\n    Hours int\n    Minutes int\n}\n\nfunc (c Clock) Display() {\n    fmt.Printf("%02d:%02d", c.Hours, c.Minutes)\n}\n\n// schedule.go\npackage schedule\n\n// DECLARE A Displayable INTERFACE HERE\ntype Displayable interface {\n    Display()\n}\n// DECLARE A Print FUNCTION HERE\nfunc Print(display Displayable) {\n    display.Display()\n}\n')),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"concurrency"}},"Concurrency"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt"\n    "time"\n)\n\nfunc longTask() {\n    fmt.Println("Starting long task")\n    time.Sleep(3 * time.Second)\n    fmt.Println("Long task finished")\n}\n\nfunc main() {\n    go longTask()\n    go longTask()\n    go longTask()\n    time.Sleep(4 * time.Second) // just for show - we can use channels instead\n}\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"channels"}},"Channels"),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can't simply try to use the time.Sleep with the keyword go given that the go routine doesn't give a value right away."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt"\n    "math/rand"\n    "time"\n)\n\nfunc longTask() int {\n    delay := rand.Intn(5)\n    fmt.Println("Starting long task")\n    time.Sleep(time.Duration(delay) * time.Second)\n    fmt.Println("Long task finished")\n    return delay\n}\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    time := longTask()\n    fmt.Println("Took", time, "seconds")\n}\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"What we can do instead is use a channel to pass a message back to the main go routine."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-go"}},'package main\n\nimport (\n    "fmt"\n    "math/rand"\n    "time"\n)\n\n// notice we get rid of the int return value\nfunc longTask(channel chan int) {\n    delay := rand.Intn(5)\n    fmt.Println("Starting long task")\n    time.Sleep(time.Duration(delay) * time.Second)\n    fmt.Println("Long task finished")\n    channel <- delay\n}\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    channel := make(chan int)\n    for i := 1; i <= 3; i++ {\n        go longTask(channel)\n    }\n    // uses the arrow prefix\n    for i := 1; i <= 3; i++ {\n        fmt.Println("Took", <-channel, "seconds")\n    }\n}\n')),o.a.createElement(r.MDXTag,{name:"h4",components:n,props:{id:"challenge-1"}},"Challenge"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{}},"package channels\n\nfunc readFromChannel() string {\n    // CREATE A CHANNEL FOR string VALUES HERE\n    channel := make(chan string)\n    // HERE, CALL writeToChannel AS A GOROUTINE, AND PASS IT YOUR CHANNEL\n    go writeToChannel(channel)\n    // HERE, READ A STRING FROM YOUR CHANNEL AND RETURN IT\n    return <-channel\n}\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"summary"}},"Summary"),o.a.createElement(r.MDXTag,{name:"p",components:n},"In the course, we've looked at:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Packages"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Type"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Functions"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Go format tool"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Arrays, Slices and Maps"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Structs for field aggregation - Adding methods - Interfaces"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"Using Go routines and Channels")))}}])&&s(a.prototype,t),m&&s(a,m),n}();g.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-go-go-lang-overview.305817e8304de77c75ce.js.map