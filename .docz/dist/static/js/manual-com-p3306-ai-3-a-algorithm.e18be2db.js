(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{"./manual/COMP3306-AI/3-A*-Algorithm.md":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return g});var t=a("./node_modules/react/index.js"),o=a.n(t),m=a("./node_modules/@mdx-js/tag/dist/index.js");function r(e){return(r="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},m=Object.keys(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(t=0;t<m.length;t++)a=m[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}function l(e,n){for(var a=0;a<n.length;a++){var t=n[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(e,t.key,t)}}function c(e,n){return!n||"object"!==r(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function p(e,n){return(p=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var g=function(e){function n(e){var a;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(a=c(this,s(n).call(this,e))).layout=null,a}var a,t,r;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&p(e,n)}(n,o.a.Component),a=n,(t=[{key:"render",value:function(){var e=this.props,n=e.components;i(e,["components"]);return o.a.createElement(m.MDXTag,{name:"wrapper",components:n},o.a.createElement(m.MDXTag,{name:"h1",components:n,props:{id:"week-3---a-algorithm"}},"Week 3 - A* Algorithm"),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Aims")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"A* search algorithm "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"How to invent admissible heuristics")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"a-search"}},"A* Search"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"UCS minimizes the cost so far ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"g(n)")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"GS minimizes the estimated cost to the goal ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(n)")),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"A* combining UCS and GS"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Evaluation function: ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"f(n)=g(n)+h(n)"),"\n- ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"g(n) = cost so far to reach n"),"\n- ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(n) = est. cost from n to goal"),"\n- ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"f(n) = est. total cost of path through n to the goal"))),o.a.createElement(m.MDXTag,{name:"p",components:n},"The idea is that we take into account both the cost and estimated cost and combine them to decide which nodes to add to the fringe queue!"),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"BFS and UCS Special Case")),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"BFS is a special case of A* when f(n)=depth(n)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"BFS is also a special case of UCS when g(n)=depth(n)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"UCS is a special case of A* when h(n)=0")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"admissible-heauristic"}},"Admissible Heauristic"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Heuristic ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(n)")," is admissible if for every node n:\n- ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h(n) <= h*(n)")," where ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h*(n)")," is the true cost to reach a goal from ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"n"),"\n- The estimate to reach the goal is smaller or equal to the true cost to reach the goal"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Admissible heuristics are ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"optimistic")," - they think that the cost of solving the problem is less than it actually is.\n- heuristic never overestimates actual cost -> it is admissible")),o.a.createElement(m.MDXTag,{name:"p",components:n},o.a.createElement(m.MDXTag,{name:"strong",components:n,parentName:"p"},"Theorem")),o.a.createElement(m.MDXTag,{name:"p",components:n},"If ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"h")," is an ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"admissible heuristic")," than A* is complete and optimal."),o.a.createElement(m.MDXTag,{name:"p",components:n},"How to check?"),o.a.createElement(m.MDXTag,{name:"p",components:n},"See if the estimated cost for a node is <= the actual cost from that node to the goal node."),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"optimality-of-a---proof"}},"Optimality of A* - Proof"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Compare f(G2) and f(G)"),o.a.createElement(m.MDXTag,{name:"ol",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"f(G2)=g(G2)+h(G2) (by definition) = g(G2) as h(G2)=0, G2 is a goal"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"f(G)=g(G)+h(G) (by definition) = g(G) as h(G)=0, G is a goal"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"g(G2)>g(G) as G2 is suboptimal"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"=> f(G2)>f(G) by substituting 1) and 2) into 3)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"f(n)=g(n)+h(n) (by definition)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"h(n) <= h",o.a.createElement(m.MDXTag,{name:"em",components:n,parentName:"li"},"(n) where h"),"(n) is the true cost from n to G (as h is admissible)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"=> f(n)<=g(n) + h*(n) (5 & 6)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"= g(G) path cost from S to G via n"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"g(G) = f(G) as f(G)=g(G)+h(G)=g(G)+0 as h(G)=0, G is a goal "),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"=> f(n)<=f(G) (7,8,9)",o.a.createElement(m.MDXTag,{name:"ul",components:n,parentName:"li"},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"Thus f(G)<f(G2) (4) & f(n)<=f(G) (10)"))),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"f(n)<=f(G)<f(G2) (10, 4)"),o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"f(n)<f(G2) => n will be expanded not G2; A* will not select G2 for expansion")),o.a.createElement(m.MDXTag,{name:"h2",components:n,props:{id:"dominance"}},"Dominance"),o.a.createElement(m.MDXTag,{name:"p",components:n},"Two admissibleheuristics h(1) and h(2)"),o.a.createElement(m.MDXTag,{name:"ul",components:n},o.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h[2]")," dominates ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h[1]")," if for all nodes ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"n")," we have ",o.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"h[2](n) >= h[1](n)"))))}}])&&l(a.prototype,t),r&&l(a,r),n}();g.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=manual-com-p3306-ai-3-a-algorithm.305817e8304de77c75ce.js.map